---
title: Squirell Language
date: 2009-07-10 20:36:00
abbrlink: 19863
tags: squirell
---

Несколько дней назад начал разбираться с языком Squirell.

Ощущения от использования (в качестве средства написания игровой логики по сравнению с C++):

**1** Удобно, что можно запихать в параметр функции безымянную функцию или сделать из таких функций массив, да еще и "замкнуть" на них внешние переменные. Переменные для замыкания нужно указывать явно (как param1 в примере). Например, так можно выбрать в игре случайную базу игрока, в которую можно добавить пушку типа `param1`:

```nim
        local cp = getCheckPointFromPred(
        function(checkpoint):(param1) { return checkpoint.m_ConflictSide == SIDE_Player && checkpoint.canAddCannon(param1)}
        )
```

Внутри `getCheckpointFromPred` с помощью цикла `foreach` (встроенных функций вроде `filter` и `reduce` не нашел) перебираются все базы. и проверяются на соответствие предикату.

**2** Глобальные переменные объявляются и инициализируются с помощью оперотора "<-", а локальные - с помощью слова local и "=", таким образом интерпретатор отлавливает ошибки, связанные с тем, что программист опечатался в имени переменной:

```nim
Var1 <- "Some value"
local Var2 = "Other value"
Var3 = "Error value" //здесь ошибка, если переменная Var3 не была объявлена где-то раньше.
```

**3** Поначалу напрягало отлавливание синтаксических ошибок, так как место ошибки даже примерно не узнать. но потом понял, где я обычно допускаю ошибки и стал их очень быстро находить - если Squirell ругается на остутствие "," - значит, надо искать в таблицах между парами ключ-значение, если не хватает ")" - скорее всего ее забыли после сложного условия в `if`'е или `while`'е, ну а ";" не хватает обычно в `for`'e.

**4** Порадовала возможность отладить код "на лету", без перекомпиляции или даже без перезапуска приложения иногда получается. Ну, понятно, это фишка любого скриптового языка.

**5** Еще для игрового кода очень удобной по сравнению с С++ (да, там с помощью шаблонов можно похоже сделать) показалась возможность утиной типизации. То есть, если функция ожидает объект определенного класса (то есть, зовет функции этого класса), в нее можно запихать объект другого класса, который будет иметь те функции или члены, которые надеется увидеть в нем вызывающая функция.

**6** Использование сишного синтаксиса приводит к возникновению сишных ошибок. Например, в одной проверке вместо сравнения на равенство сделал присваивание. И после этой проверки вертолеты ВНЕЗАПНО перестали приземляться в аэропорты, так как принимали их за танковые базы.

Вообще, имхо, главное удобство от вынесения игровой логики в скрипты - не надо перекомпилировать программу, чтобы поиграться с параметрами, влиящими только на геймплей. Остальное - приятные плюшки
