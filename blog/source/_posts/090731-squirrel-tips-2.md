---
title: Squirrel tips - 2
date: 2009-07-31 19:56:00
abbrlink: 16779
tags: squirell
---

Еще пара заметок про язык squirrel и грабли в нем

Оператор `in` проверяет, есть ли ключ в таблице, но не проверяет вхождение элемента в массив  
т.е. так нельзя:

```js
    if (1 in [1,2,3]) doSomethink();
```

Но можно так:  

```js
    if (1 in {[1]=null,[2]=null,[3]=null]) doSomethink();  
```

При создании функций с последующей их передачей в другие функции следует помнить, что Squirell будет искать переменные в текущей области видимости (там, куда мы передадим фукнцию).  
Например:

```js
class a { val = 1 }
class a { val = 1 }
function a::f(fun) { fun() }
function b::f(fun) { fun() }
vA <- a()
vB <- b()
 
val <-3
 
vA.f(function() { val = 0 })
print(val)     //3 - осталось неизменным, изменилось Va.val
vB.f(function() { val = 0 })
print(val)     //0 - изменилось
```

Т.е. при функция может повести себя по разному, в зависимости от того, куда ее передать.  
Если же мы хотим передать в функцию метод объекта, изменяющий сам объект, то необходимо передать сам объект в замыкании функции:  

```js
class Do
  {
    function call(fun)
    {
       fun()
    } 
  }
 
  class A
  { 
     val=0 
     constructor()
     {
       local th = this                     //получить ссылку на себя
       Do.call(function():(th) {th.val++}) //и передать вместе с функцией
     }
  }
```