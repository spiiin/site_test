<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2021-05-04T15:32:35.817Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nim in imaginary world</title>
    <link href="http://spiiin.github.io/blog/1808122922/"/>
    <id>http://spiiin.github.io/blog/1808122922/</id>
    <published>2021-05-04T11:00:08.000Z</published>
    <updated>2021-05-04T15:32:35.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Когда я изучаю новый язык, то после базового изучения синтаксиса пробую решать на нём выдуманную задачку, взятую из игры <code>James Bond Jr</code> для платформы NES. Попробовал решить её на <a href="https://nim-lang.org/" target="_blank" rel="noopener">Nim</a> и сравнить с решениями на других языках.<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">В этой игрушке в первой зоне сын известного спецагента Джеймса Бонда должен деактивировать 5 ракет главзлодея.</span><br><span class="line">Чтобы “выключить” ракету, необходимо решить головоломку:</span><br><span class="line">Заданы исходное поле из разноцветных клеток и целевая позиция, </span><br><span class="line">в которую надо перевести поле, сдвигая любую строку или столбец.</span><br></pre></td></tr></table></figure><p><img src="/blog/1808122922/bomb_1_small.png" alt="bomb1"><br>(Первая, самая простая, версия загадки)</p><p>Задача хороша тем, что несмотря на кажущуюся простоту, требует немного задуматься в более сложных вариантах, как при решении руками, так и при составлении алгоритма – простое построение дерева решения в лоб для одной из головоломок может занять очень много времени.</p><p>Предыдущие эксперименты:<br><a href="/blog/28461/" title="(2009) Python in imaginary world">(2009) Python in imaginary world</a> - первая попытка решить задачу на Python, скрины и решения всех 5 головоломок.<br><a href="/blog/3351183716/" title="(2015) Scala in imaginary world">(2015) Scala in imaginary world</a> - решение на Scala после прохождения <a href="https://www.coursera.org/learn/progfun1" target="_blank" rel="noopener">курса Мартина Одерски на Coursera</a>.</p><p>Отдельно исходники решения:<br><a href="https://gist.github.com/spiiin/aadd940534e03d84322b121aa9ac0041" target="_blank" rel="noopener">Python</a> (портировал со второй на третью версию)<br><a href="https://gist.github.com/spiiin/257ff552ed1c9de6ed6f" target="_blank" rel="noopener">Scala</a></p><p>В решениях оставлена только самая сложная версия головоломки:<br><img src="/blog/1808122922/bomb_4_small.png" alt="bomb4"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>, <span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">target = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>, <span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>, <span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>, <span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] <span class="comment">##4</span></span><br></pre></td></tr></table></figure></p><h2 id="Критерии-выбора-языка"><a href="#Критерии-выбора-языка" class="headerlink" title="Критерии выбора языка"></a>Критерии выбора языка</h2><p><code>Python</code> когда-то заинтересовал тем, что в нём можно было очень быстро сделать прототип того, что хочешь, причём на высоком уровне абстракции. При этом начинать писать на нём полезные вещи можно буквально через несколько дней после изучения, а с помощью большого набора готовых библиотек можно отыскать быстрый способ решить конкретную задачу минимальным количеством кода.</p><p>Но через несколько лет захотелось найти языки, которые были бы лучше по какому-либо из критериев:</p><p><strong><code>- со статической типизацией</code></strong><br>Иногда мешает, что ошибки типов находятся только в рантайме. Особенно если нужно модифицировать функцию, возвращающую различными способами список из 3-4 элементов сложных типов. Это можно вылечить культурой разработки (тесты, аннотации типов), но хочется подобрать язык, который защитит от таких ошибок совсем (ну или хотя бы чуть-чуть лучше).</p><p><strong><code>- с более выразительным синтаксисом</code></strong><br><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">Дзен питона</a> - <em>There should be one— and preferably only one —obvious way to do it</em>. При этом, на нём не очень удобно писать в функциональном стиле, лямбда-функции местами ограничены. <em>Изредка</em>, но хочется немного более свободного способа выражения мыслей.</p><p><strong><code>- с возможностью собирать нативный код</code></strong><br>Язык с виртуальной машиной типа Python можно запаковать в исполнимый файл без зависимостей только вместе с этой виртуальной машиной. Но случае распространения программ конечным пользователям не всегда удобно, что небольшая утилита или скрипт тянет за собой тонны кода интерпретатора и библиотек. Иногда хочется иметь возможность получить небольшой исполнимый файл, который только лишь делает необходимую работу.</p><p><strong><code>- более быстрый</code></strong><br><em>Изредка</em>, нужно чтобы небольшая утилита при этом была ещё и быстрой. При использовании скриптовых языков в этом случае принято переходить на C.</p><p><strong><code>- максимально кроссплатформенный</code></strong><br>Python хорош для работы в Windows/Unix/macOS, но использовать его на мобильных платформах (Android/iOS) сложно. Не то чтобы невозможно, но скорее нецелесообразно. В этом случае снова логично переходить на C - iOS поддерживает C/C++ в своих ObjectiveC/ObjecticeC++ вставках, Android имеет компилировать нативный код через NDK, также можно собрать его с помощью Emscripten для запуска в браузере.</p><p><strong><code>- кросс-языковое использование</code></strong><br>В идеале, должен быть способ использовать программу или утилиту из других языков различными способами. В этом случае снова самым удобным является код на C, собранный в библиотеку - почти все языки позволяют вызвать такой код. Если же вы хотите выполнить Python скрипт из своей программы, то не всегда понятно, что делать в этом случае - встроить ли в программу интерпретатор python и нужные для скрипты библиотеки? полагаться на то, что Python уже есть в окружении и вызвать его как системный процесс, прочитав его поток вывода? Или вообще завернуть всё окружение в docker?</p><p><code>Scala</code> обладает первыми двумя качествами (статически типизированная и выразительная), но при этом нацелена на экосистему Java, т.е. обладает проблемами там, где хочется связи с не Java-миром, а также компактности и скорости.</p><h2 id="Nim"><a href="#Nim" class="headerlink" title="Nim"></a>Nim</h2><p>Автор <code>Nim</code> декларирует то, что он соответствует всем требуемым критериям, в основном из-за того, что язык компилируется в C/C++-код, а значит - легко взаимодействует с ним, и компилируется там, где и эти языки (т.е. практически на любой платформе). Поэтому захотелось затестировать его и сравнить для себя с Python.</p><p>Первая попытка решения:<br><a href="https://gist.github.com/spiiin/44721f2e5a70294fa390218ad92385e4" target="_blank" rel="noopener">Nim</a><br><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/44721f2e5a70294fa390218ad92385e4.js?file=james_bond_nim.nim"></script>    </div></div></p><h2 id="Особенности-синтаксиса"><a href="#Особенности-синтаксиса" class="headerlink" title="Особенности синтаксиса"></a>Особенности синтаксиса</h2><p><strong><code>- Поддержка спецсимволов &quot;из коробки&quot;</code></strong><br>Можно вывести ответ в чуть более удобной форме<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">    <span class="type">Dir</span> = <span class="keyword">enum</span> →, ←, ↑, ↓, <span class="type">NOP</span></span><br><span class="line"></span><br><span class="line">(<span class="type">NOP</span>,<span class="number">0</span>): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">(→,<span class="number">2</span>): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">(←,<span class="number">0</span>): [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">(↓,<span class="number">3</span>): [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">0</span>): [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">2</span>): [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(↑,<span class="number">1</span>): [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">0</span>): [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">2</span>): [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(↑,<span class="number">2</span>): [<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p><strong><code>- Нельзя использовать итераторы вне for-цикла</code></strong><br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sort of magic - iterator can be used only with `for`, but it can be wrapped to var sequence, and after calculation</span></span><br><span class="line"><span class="keyword">proc</span> generateProduct[T,U] (aa:T, bb:U) : <span class="built_in">auto</span> = (<span class="keyword">var</span> x = newSeq[<span class="keyword">tuple</span>[a:<span class="keyword">type</span>(aa[<span class="number">0</span>]), b:<span class="keyword">type</span>(bb[<span class="number">0</span>])]](); <span class="keyword">for</span> pair <span class="keyword">in</span> product(aa, bb) : x.add(pair); x)</span><br></pre></td></tr></table></figure></p><p>Вся выглядящая магией функция <code>generateProduct</code> - это обёртка вокруг итератора <code>product</code>, чтобы можно было использовать его в произвольном коде, а не только внутри for. Скорее всего подобное можно завернуть в макрос, которым можно трансформировать любой итератор в функцию, но это уже за рамками первой программы.</p><p><strong><code>- В стандартной библиотеке нет нужных комбинаторных функций</code></strong></p><p>Функция <code>product</code> взята из библиотеки <a href="https://github.com/narimiran/itertools" target="_blank" rel="noopener">itertools</a>. Не очень страшно, скорее всего стандартная библиотека будет расширена в новых версиях языка.</p><p><strong><code>- Выразительность системы типов</code></strong><br>Ещё раз посмотрим  на код <code>generateProduct</code>. В ней есть интересный способ записи информации о типах. Тип переменной <code>x</code> тут можно прочитать как:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Последовательность из пар, </span><br><span class="line">в которых тип первого элемента пары: &quot;такой же, как первый элемент массива aa&quot;, </span><br><span class="line">а тип второго элемента пары: &quot;такой же, как первый элемент массива bb&quot;.</span><br></pre></td></tr></table></figure></p><p>Это неудобочитаемо, мы не описали явно, что <code>aa</code> и <code>bb</code> - массивы, но тем не менее компилятор проверит, что это так , когда будет выводить тип <code>x</code> (точнее даже - ему будет достаточно того, что для типов aa и bb можно обратиться к первому элементу и взять его тип).</p><p>Возможность потребовать от компилятора вывести тип в любом месте кода напоминает мне <code>Lisp</code>, хотя Goran Krampe в <a href="http://goran.krampe.se/nim/" target="_blank" rel="noopener">серии статей про Nim</a> утверждает, что это - наследие <code>Smalltalk</code>.</p><p>Более стандартный способ выражения типов, в котором явно сказано что <code>aa</code> и <code>bb</code> - это <em>массивы из элементов какого-то типа</em>:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sort of magic - iterator can be used only with `for`, but it can be wrapped to var sequence</span></span><br><span class="line"><span class="keyword">proc</span> generateProduct[T,U] (aa:openArray[T], bb:openArray[U]) : <span class="built_in">seq</span>[<span class="keyword">tuple</span>[a:T, b:U]] = </span><br><span class="line">    (<span class="keyword">var</span> x = newSeq[<span class="keyword">tuple</span>[a:T, b:U]](); <span class="keyword">for</span> pair <span class="keyword">in</span> product(aa, bb) : x.add(pair); x)</span><br></pre></td></tr></table></figure></p><p><strong><code>- Синтаксис стимулирует разбивать код на от отдельные файлы</code></strong><br>Одна из идиом языка - определить свои типы и “доопределить” стандартные функции, чтобы они работали с новыми типами:</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">     <span class="type">FieldPathInfo</span> = <span class="keyword">tuple</span>[rate: <span class="built_in">int</span>, v:<span class="type">Field</span>, prev:<span class="type">Field</span>, level:<span class="built_in">int</span>, operation: <span class="type">OperationCode</span>]</span><br><span class="line"><span class="keyword">proc</span> `&lt;`(a : <span class="type">FieldPathInfo</span>, b : <span class="type">FieldPathInfo</span>) : <span class="built_in">auto</span> = a.rate &gt; b.rate <span class="comment">#определяем какой из типов "больше"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#хоп, теперь можно позвать opened.sort() - сортировка будет использовать этот оператор</span></span><br><span class="line"><span class="keyword">var</span> opened = newSeq[<span class="type">FieldPathInfo</span>]()</span><br><span class="line">opened.sort()</span><br></pre></td></tr></table></figure><p>Раз уж типы и функции, работающие с этими типами, нельзя связать в класс, то любому нормальному программисту захочется отделить их в отдельный файл.</p><blockquote><p>Код по выразительности сопоставим с Python, система типов позволяет не только аннотировать тип, но и написать код зависимости между типами, который проверит компилятор. Удобно, что этот код - такой же код на Nim, как и остальная программа, а не отдельный язык (как в случае с C++).</p></blockquote><h2 id="Кроссплатформенность"><a href="#Кроссплатформенность" class="headerlink" title="Кроссплатформенность"></a>Кроссплатформенность</h2><p><a href="https://nim-lang.org/docs/nimc.html" target="_blank" rel="noopener">Руководство к компилятору</a> выдаёт все нужные ключи, чтобы траслировать код из Nim в C, C++, Objective C и JavaScript (<a href="https://github.com/def-/nimes" target="_blank" rel="noopener">тут</a>, правда, отмечают, что проще транслировать полученный C код в JavaScript с помощью Emscripten - это более надёжный вариант, чем nim-&gt;js).</p><p>Я протестировал сборку под macOS, но не смотрел сборку для ios/android - “скелет” программы требует намного больше усилий, чем просто компиляция из командной строки, так что тут Nim тоже находится примерно на уровне <code>Python</code>.</p><h2 id="Скорость"><a href="#Скорость" class="headerlink" title="Скорость"></a>Скорость</h2><p>Моя старая программа на Python находит решение на моём компьютере за ~2-3 секунды. Версия на Nim работает ~4 секунды.</p><p>В первую очередь, конечно, надо просто включить оптимизацию :)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nim -d:release --opt:speed c james_bond_nim.nim</span><br></pre></td></tr></table></figure></p><p>С такими ключами программа работает уже ~1-2 секунды, что, конечно, опережает Python-версию, но разница между компилируемым и интерпретируемым языком должна быть ощутимее.</p><p>Поэтому я всё-таки изучил Nim ещё немного, чтобы понять, что не так. Основная причина тормознутости в том, что базовый тип языка <code>seq</code> - неподходящая структура данных, так как, в отличие от базового <code>list</code> в Python, выполняет лишние копирования. Забавно, что даже с учётом этого, оптимизированная Nim версия выполняется быстрее. Более подходящая структура - <a href="https://nim-lang.org/docs/lists.html#DoublyLinkedList" target="_blank" rel="noopener">DoublyLinkedList</a>.</p><p><a href="https://gist.github.com/spiiin/1089716ab64e6056ed878c1508e87c86" target="_blank" rel="noopener">Nim - быстрая версия</a><br><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/1089716ab64e6056ed878c1508e87c86.js?file=james_bond_nim4.nim"></script>    </div></div></p><p>Также для красоты сделал тип для более удобной работы с открытым списком – объединил в структуру связанный список и хеш-таблицу для кеширования значений (хеш-таблица есть и в python-версии):<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">OpenList</span> = <span class="keyword">object</span></span><br><span class="line">       opened : <span class="type">DoublyLinkedList</span>[<span class="type">FieldPathInfo</span>]</span><br><span class="line">       openedLen : <span class="built_in">int</span></span><br><span class="line">       hashes : <span class="type">HashSet</span>[<span class="type">Field</span>]</span><br></pre></td></tr></table></figure></p><p>Убрал зависимость от библиотеки <code>itertools</code>:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="comment">#there is no product in standart library</span></span><br><span class="line"><span class="keyword">iterator</span> product[T, U](s1: openArray[T], s2: openArray[U]): <span class="keyword">tuple</span>[a: T, b: U] =</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> s1:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> s2:</span><br><span class="line">            <span class="keyword">yield</span> (a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span> generateProduct[T,U] (aa:openArray[T], bb:openArray[U]) : <span class="built_in">seq</span>[<span class="keyword">tuple</span>[a:T, b:U]] = </span><br><span class="line">    (<span class="keyword">var</span> x = newSeq[<span class="keyword">tuple</span>[a:T, b:U]](); <span class="keyword">for</span> pair <span class="keyword">in</span> product(aa, bb) : x.add(pair); x)</span><br></pre></td></tr></table></figure></p><p>Для теста “кросс-язычности” экспортировал функцию поиска в Python:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nimpy</span><br><span class="line"><span class="keyword">proc</span> main() : <span class="type">Field</span> <span class="meta">&#123;.exportpy.&#125;</span></span><br></pre></td></tr></table></figure></p><p>И определил свою функцию конвертации в строку для вывода на экран:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span> `$`(op: <span class="type">OperationCode</span>) : <span class="built_in">auto</span> = <span class="string">"("</span> &amp; $op.dir &amp; <span class="string">","</span> &amp; $op.line &amp; <span class="string">")"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>В результате замены seq на DoublyLinkedList программа начала выполняться за доли секунды - в десятки раз быстрее аналогичной Python-версии.</p></blockquote><p>Для выполнения точных замеров нужно конечно сгенерировать множество входных данных и исследовать скорость на них, но мне было достаточно того, чтобы добиться измеримых “на глаз” показателей скорости.</p><p>Ещё одна из возможностей Nim - перенос выполнения кода полностью на момент компиляции, но воспользоваться ей сходу не получилось, так что она тоже находится за рамками первой программы после изучения языка.</p><h2 id="Итоги"><a href="#Итоги" class="headerlink" title="Итоги"></a>Итоги</h2><p>Nim на удивление хорошо подходит по тем критериям, которые я искал изначально – статически типизируемый, выразительный, быстрый, кроссплатформенный и легко связываемый с другими языками.</p><p>Я пока не изучил его продвинутые возможности – систему макросов, возможности по подключению бекэндов, использования нативных библиотек на других языках, выполнение кода во время выполнения - каждая из них выглядит интересной.</p><p>Недостатки языка также очевидны – у него пока нет продвинутой экосистемы тулзов, за ним не стоит большая корпорация, и он достаточно молод (видны некоторые изменения синтаксиса в документации по сравнению с актуальной версией компилятора, в стандартной библиотеке как будто не хватает каких-то нужных для удобной работы функций).</p><p>Но <code>Nim</code> обладает одним из самых важных свойств для языка программирования - на нём приятно писать.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Когда я изучаю новый язык, то после базового изучения синтаксиса пробую решать на нём выдуманную задачку, взятую из игры &lt;code&gt;James Bond Jr&lt;/code&gt; для платформы NES. Попробовал решить её на &lt;a href=&quot;https://nim-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nim&lt;/a&gt; и сравнить с решениями на других языках.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="nim" scheme="http://spiiin.github.io/tags/nim/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Senior</title>
    <link href="http://spiiin.github.io/blog/258274191/"/>
    <id>http://spiiin.github.io/blog/258274191/</id>
    <published>2021-04-20T08:37:58.000Z</published>
    <updated>2021-04-20T09:58:35.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Как быть старшим программистом (в контексте “старшим разработчиком игр”) и чему учиться дальше.<br><a id="more"></a></p><p>Предыдущие заметки</p><p><a href="https://spiiin.github.io/blog/1048/" title="2011 – Как устроиться на работу программистом">2011 – Как устроиться на работу программистом</a></p><p><a href="https://spiiin.github.io/blog/15798/" title="2020 – Уровень программирования: Middle">2020 – Уровень программирования: Middle</a></p><p>Где-то с этого уровня (по моей оценке) основной целью становится умение прокачивать навыки, не касающиеся программирования.</p><p><code>Pre-requisites</code>:</p><ul><li>Умение хорошо писать на одном языке, хотя бы минимально - ещё на одном-двух.</li><li>Понимание, что хочешь развиваться в конкретной отрасли (текст про мобильный геймдев широкого профиля).</li></ul><p><img src="/blog/258274191/frontend.jpg" alt="fronted"></p><h2 id="Становится-бессмысленным-спрашивать-у-кого-то-что-учить"><a href="#Становится-бессмысленным-спрашивать-у-кого-то-что-учить" class="headerlink" title="Становится бессмысленным спрашивать у кого-то, что учить"></a>Становится бессмысленным спрашивать у кого-то, что учить</h2><p>Навыков на этом этапе развития достаточно, чтобы решать поставленные задачи, это может отбивать желание учиться и развиваться дальше. Достигнута простая цель “научиться писать на C++”, и эго подсказывает, “твой код хорош”, даже если это не так. Мозг сильно блокирует желание учиться чему-то абсолютно новому, это некомфортно.</p><p>Хорошо, если рядом есть скилловые коллеги, на которых можно ориентироваться, но если оказываешься самым умным, то можно превратиться в <em>“senior-программиста на заводе”</em>,  которого из-за низких хард-скиллов не возьмут в нормальную компанию.</p><p>Просто помни, что над тобой ещё есть несколько уровней, с высоты которых ты можешь казаться таким же “программистом на заводе”, который написал и поддерживает приложение из нескольких форм на каком-нибудь давно мёртвом языке типа Delphi 7 и страшно этим гордится как профессиональным достижением.</p><p>Не всегда очевидно, что если просидеть на поддержке продукта 5-10 лет (зарплата устраивает и повышается), то потом при смене работы с вас “спросят за стаж” - предлагать работу с понижением и обучением взрослому программисту менее перспективно для работодателя, чем взять молодого и быстрее обучающегося.<br><blockquote><p>Твой набор скиллов - это твоя ценность и стоимость, и только ты ответственен за то, чтобы его прокачивать. И спектр этих навыков определяешь ты сам.</p></blockquote></p><p>Хочешь- будешь только “Гуру языка XXX”, хочешь, научишься отлаживать, профилировать, писать крутые тулзы, эффекты и вести работу команды.</p><p>Цениться может любой вариант, важно лишь то, в чём у тебя будет конкурентное преимущество. На мой взгляд, намного ценнее специалист, который понимает, что его код решает какую-то конкретную проблему и разбирается в этой проблеме.</p><p><strong><code>Тебе навряд ли будут предлагать делать то, что ты не умеешь, если ты не учишься сам или делал плохо</code></strong>.</p><h2 id="Наличие-одиночества"><a href="#Наличие-одиночества" class="headerlink" title="Наличие одиночества"></a>Наличие одиночества</h2><p>Решение задач с определённого уровня чаще всего не “механическое”, а требует времени на обдумывание или исследование материала. </p><p>Когда ты доходишь до задач такого уровня, готовое решение не нагуглится просто потому, что именно такую задачу никто ещё не решал. Максимум, что можно сделать, это посмотреть на то, какие подобные задачи решались до вас, и с какими трудностями сталкивались те, кто решал их раньше. Это в перспективе эффективнее, чем делать своё решение сразу и пройти по всем граблям.</p><p>Соотвественно, если тебя всё время отвлекают (собраниями, неотложными срочными задачами), ты в принципе не сможешь начать решать такие задачи.</p><p>Этого состояния одиночества необходимо достичь, причём вместе с ним приходит и ответственность за то, что задача будет решена - такого рода отвественность не “размазывается” по команде, и от неё не улизнуть в отпуск или на больничный.</p><p>Хотя, если не удаётся достичь состояния в рабочее время (вполне бывают проекты с таким темпом, когда просто некогда остановиться и задуматься надолго), его можно добиться хобби проектами, в свободное время.</p><blockquote><p>Это состояние - не какое-либо “общение с пустотой”, не надо лишать себя общения с людьми, это быстро приведёт к выгоранию, скорее состояние активного “общения с информацией”.</p></blockquote><h2 id="Желание-работать-на-результат"><a href="#Желание-работать-на-результат" class="headerlink" title="Желание работать на результат"></a>Желание работать на результат</h2><p>Одна из важных целей в развитии - умение ориентироваться на результат и правильно его обозначать. Можно делать что угодно как хобби и тратить время на это, но в профессиональной деятельности по определению результатом будет повышение дохода. </p><p>А значит, долгосрочное планирование должно быть направлено на это.</p><p>Хорошая книга про ориентировании <em>компаний</em> на результат - <code>&quot;Великие по собственному выбору&quot;</code> Джима Коллинза. Хотя книга о компаниях, она сильно мотивирует и на личное развитие.<br>Основные тезисы книги:<br><strong><code>- Дисциплина+идея</code></strong>. Намного эффективнее двигаться вперёд постоянно небольшими запланированными шагами, чем большими рывками с выматывающими сверх-усилиями.<br><strong><code>- Здоровая паранойа</code></strong>. Строй свою жизнь/работу/отдых с учётом того, что что-то может пойти не так. В мире много неопределенностей, к которым можно подготовиться, это лучше, чем действовать вслепую.<br><strong><code>- Умение работать с эмпирическими данными</code></strong>. Для этого знай, где их брать, что они означают, и что можно сделать с этим знанием.</p><p>Более развернутая статья - <a href="https://vas3k.club/post/4919/" target="_blank" rel="noopener">Умение зарабатывать деньги</a> (Доступна только по подписке).</p><p>Важное дополнение оттуда - научись управлять своими эмоциями, они чаще всего бесполезны. Если есть проблемы с эмоциями, которые мешают быть эффективным, нужно учиться минимизироавать их влияние. Не забывай следить за здоровьем, учись диверсифицировать доходы.</p><h2 id="Разобраться-с-ценностями-своими-компании"><a href="#Разобраться-с-ценностями-своими-компании" class="headerlink" title="Разобраться с ценностями (своими/компании)"></a>Разобраться с ценностями (своими/компании)</h2><p>Логично вытекающее из предыдущего пункта дополнение - честный вопрос себе <strong><code>&quot;а нафига я вообще делаю, что делаю&quot;</code></strong>. В ходе ответа на него также возникает вопрос, соответствует ли твой ответ и мировоззрение тому, что декларирует и делает компания, в которой ты работаешь.</p><p>Примеры мотивации:</p><div class="table-container"><table><thead><tr><th>Ценность</th><th style="text-align:left">Личная</th><th style="text-align:left">Компании</th></tr></thead><tbody><tr><td>Власть</td><td style="text-align:left">Карьерный рост</td><td style="text-align:left">Победа над конкурентами</td></tr><tr><td>Заработок</td><td style="text-align:left">Накопление ресурсов</td><td style="text-align:left">Раcширение компании(экспансия)</td></tr><tr><td>Известность</td><td style="text-align:left">Развитие личного бренда</td><td style="text-align:left">Развитие бренда компании</td></tr><tr><td>Исследование</td><td style="text-align:left">Развитие навыков</td><td style="text-align:left">Исследование технологий</td></tr></tbody></table></div><p>Здорово, если личные ценности гармонируют и совпадают с целями компании, и если нет перегиба в желаниях с личной стороны, и отличий в декларируемых и реальных действиях со стороны компании.</p><p>“Личные перегибы” здесь означает желание достигнуть цели в ущерб коллегам, а не совместно с ними, “отличия в декларируемых намерениях компании” - пустые лозунги, отличающиеся от правил, которые применяются в компании в реальности.</p><blockquote><p>Соответствие внутренних целей тому, что делаешь, нужно, чтобы не выгореть в долгосрочной перспективе, и чтобы продолжать получать кайф от того, что делаешь, даже если сиюминутные задачи будут не самыми интересными.</p></blockquote><h2 id="Освоение-смежных-областей"><a href="#Освоение-смежных-областей" class="headerlink" title="Освоение смежных областей"></a>Освоение смежных областей</h2><p>Найди время, чтобы  изучить на базовом уровне что-то новое, чем никогда не занимался раньше. Это полезно для мозга, и часто помогает открыть для себя какие-то новые возможности. В каком-то смысле, <strong><code>вселенная откроет что-то новое для тебя</code></strong>.</p><p>Например, если программируешь игры - попытайся понять, тех, кто <em>создаёт</em> игры - в чём заключается работа геймдизайнера или продюссера.<br>Для понимания работы геймдизайнера отлично подходит книга <code>&quot;Искусство геймдизайна&quot; Джесси Шелла</code> (эта книга затрагивает не только о геймдизайн, но и вообще, устройство мира и психологию человека).</p><p>Для начального понимания работы продюсера игр есть хороший доклад - <a href="https://www.youtube.com/watch?v=a9wSZ9L_Jk8&amp;ab_channel=DevGAMM" target="_blank" rel="noopener">Три главных фокуса продюсера</a> Александра Штаченко.</p><p>Можно попытаться разобраться с тем, как устроены компании, попытаться научиться писать музыку или разобраться с принципами классической анимации. Мир полон интересных задач, которые решают люди различных профессий.</p><blockquote><p>В конечном итоге, освоение новых областей улучшит твою способность учиться и сделает тебя лучшим программистом.</p></blockquote><h2 id="Смотреть-на-rocket-science-решения"><a href="#Смотреть-на-rocket-science-решения" class="headerlink" title="Смотреть на rocket-science решения"></a>Смотреть на rocket-science решения</h2><p>Перед началом реализации решения любой задачи, хорошо бы вспомнить, что кто-то уже брался за похожую задачу до тебя. </p><p><strong><code>Может существовать готовое хорошее решение, которое можно использовать, не расходуя ресурсов на реализацию своего решения</code></strong>.</p><p>Даже если готовое решение не подходит, можно, чтобы сэкономить время и “мысленное топливо”:</p><ul><li>Изучить идеи, которыми руководствовались те, кто решал задачу до тебя, проблемы, с которыми они сталкивались, плюсы и минусы чужих решений.</li><li>Пропустить шаг с реализацией первого простого решения, а сразу улучшать или адаптировать готовое продвинутое.</li><li>Прикинуть, насколько своё решение будет лучше “среднего общедоступного”, насколько эффективнее ваше решение чем то, которое, возможно, будут использовать конкуренты.</li><li>Понять, что решения не существует или оно слишком дорогое в рамках текущего бюджета проекта.</li></ul><p><strong>Где искать эти готовые решения?</strong></p><p>Пару лет назад я наткнулся на достаточно продвинутого хакера (в смысле, исследователя безопасности веб-сайтов), который в интервью сказал, что достаточно просто мониторить твиттер ~100-200 продвинутых ребят в области, чтобы быть в курсе всех трендов своей области. Основные  публично доступные крутые решения делают и обсуждают относительно небольшая группа людей.<br>Естественно, есть “порог входа”, нужно уже обладать достаточным опытом и багажом знаний, чтобы хотя бы понимать обсуждаемые темы.</p><p>Тогда мне показалось странным, так как я читал только русскоязычный твиттер, в котором даже технические ребята постят нытьё, мемасы и политоту. Сейчас я понимаю, что англоязычный геймдев сегмент-твиттера - вполне себе место для коротких технических дискуссий, в которых участвуют лид-программисты ведущих компаний, авторы лучших open-source библиотек, ресёрчеры разных направлений, причём их твиты в большинстве именно на технические темы.</p><blockquote><p>Основные публичные площадки обсуждения технических решений сейчас, в порядке убывания - твиттер, реддит, гитхаб.</p></blockquote><p>Способ составления начального списка - авторы докладов с технических конференций (почти 100% оставляют в начале или конце доклада свои контакты), авторы технических статей или библиотек, которые находятся поиском информации в гугле. Дальше - следить за тем, кого читают они.</p><h2 id="Умение-анализировать-информацию"><a href="#Умение-анализировать-информацию" class="headerlink" title="Умение анализировать информацию"></a>Умение анализировать информацию</h2><blockquote><p>В первую очередь - научиться собирать информацию эмпирическим путём. Без проверенной и отфильтрованной входной информации невозможно получить никаких полезных выводов.</p></blockquote><p>Любая маркетинговая информация (“самый лучший игровой движок, самый быстрый язык для программирования игр”) - лишь входная для проверки и получения собственных результатов.</p><p><strong><code>Про это могут забыть те, на ком лежит ответственность за принятие решения по выбору инструментов</code></strong>, зачастую, потому что они слишком нагружены какой-либо другой ответственностью, чтобы отвлечься и проанализировать выбор технологии.</p><p><strong><code>Одним мощных способов получения эмпирических данных - reverse engeneering продуктов конкурентов</code></strong>. Часто не сложно посмотреть, какие ресурсы использует какая-либо игра, какой формат данных использует и насколько активно использует железо. Это не всегда легальный и иногда всё же трудный способ, однако вполне доступный для персонального использования.<br> (<em>кстати, особенно любят прятать и шифровать ресурсы игр китайские разработчики, непревзойдённые мастера копирования</em>)</p><p>Кроме анализа, полезно научиться правильно хранить информацию, с определенного уровня её объёмы не позволяют быстро найти нужную. Один из вариантов упорядочивания знаний - метод <code>Zettelkasten</code>. Лично мой вариант - <a href="https://obsidian.md/features" target="_blank" rel="noopener">Obsidian</a>, бесплатный, работает с md-файлами в папке (не vendor-lock), с удобным графом связей между заметками:</p><p><img src="/blog/258274191/zettel.png" alt="zettel"></p><p>Другие варианты - персональный блог, облачные системы хранения заметок, персональная вики.</p><p>Также умение собирать и анализировать информацию очень защищает от того, чтобы остаться “самоучкой” с сильными искажениями во взглядах и в подходах к решению проблем.</p><h2 id="Создавать-себе-инструменты"><a href="#Создавать-себе-инструменты" class="headerlink" title="Создавать себе инструменты"></a>Создавать себе инструменты</h2><p>Пару раз доводилось видеть на собеседовании программистов с несколькими годами опыта, которые никогда не программировали для себя. Мне кажется большим упущением не использовать свои профессиональные навыки для улучшения собственной продуктивности.</p><p>Существует множество задач, которые можно автоматизировать, причём зачастую просто соединив готовые компоненты. Такие техники в общем называются NoCode (<a href="https://vas3k.ru/blog/nocode/" target="_blank" rel="noopener">статья Вастрика</a>).</p><p>С некоторыми навыками программирования можно достичь ещё больше, не обязательно писать хороший код, часто бывает достаточно реализовать для себя одну-две функции, которых очень не хватает в окружающем софта. Многие хорошие программы можно настраивать, дописывать плагины, расширять скриптами (и просто дописывать в них фичи, если они open-source).</p><p><a href="https://habr.com/ru/post/435428/" target="_blank" rel="noopener">Удалённое управление эмулятором Fceux с помощью Python</a> - статья про создание инструментов, в ней примеры и дописывания нехватающих функций в исходники, и скриптования, и соединения разных инструментов вместе, ради получения нового функционала.</p><blockquote><p>С помощью выбора и создания правильных инструментов можно подняться намного выше “средне-рыночного” уровня.</p></blockquote><p>Ну и вообще, создание инcтрументов - одна из важных hacker-values (<strong><code>ни одна проблема не должна решаться вручную дважды</code></strong>), и путь к знанию.</p><p>Ссылки:<br><a href="http://www.paulgraham.com/avg.html" target="_blank" rel="noopener">Beating the average</a> (<a href="https://nestor.minsk.by/sr/2003/07/30710.html" target="_blank" rel="noopener">Перевод</a>)<br><a href="http://www.catb.org/~esr/faqs/hacker-howto.html" target="_blank" rel="noopener">How To Become A Hacker</a></p><h2 id="Навыки-управления-командой"><a href="#Навыки-управления-командой" class="headerlink" title="Навыки управления командой"></a>Навыки управления командой</h2><p>Даже если планируешь развиваться в техническом направлении, навыки управления командой помогут:<br><strong><code>- Научиться более точно оценивать сроки</code></strong><br><strong><code>- Делегировать часть задач коллегам, не всегда возможно успеть выполнить всё самому</code></strong><br><strong><code>- Организовывать и собирать команды</code></strong><br><strong><code>- Понимать, сколько и какого уровня людей нужно, чтобы решить конкретную большую задачу</code></strong><br><strong><code>- Как руководитель, быть более осведомлённым о целях и положении дел в проекте/компании - лучше понимать свою отрасль</code></strong></p><h2 id="Разобраться-в-железе-и-операционных-системах"><a href="#Разобраться-в-железе-и-операционных-системах" class="headerlink" title="Разобраться в железе и операционных системах"></a>Разобраться в железе и операционных системах</h2><p><a href="https://habr.com/ru/company/vdsina/blog/551302/" target="_blank" rel="noopener">Программирование это сложно</a>.<br>Оно <strong>доступно</strong> для того, что быстро начать, но <code>&quot;Easy to learn and difficult to master&quot;</code>.</p><blockquote><p>Сложности начинаются с того момента, когда в дело вступают ограничения железа.</p></blockquote><p>Об этих ограничениях имеют мало представления джуниоры и мидлы, они в основном <em>решают поставленные задачи</em>, в лучшем случае выбирают алгоритмы с подходящей асимптотикой.</p><blockquote><p>Вторая сложность - борьба с увеличением запутанности кода со временем.</p></blockquote><p>Основной метод борьбы с запутанностью в мощных языках - выбирать правильные ограничения и идеи, позволяющие <em>сохранить простоту</em>.</p><p>Программирование состоит из двух частей - представлении того, что нужно непосредственно <em>сделать компьютеру</em>, чтобы решить задачу, и обдумывание средств, как выразить это на языке программирования, так чтобы это работало эффективно и выразительно с точки зрения синтаксиса языка.</p><p><a href="https://caseymuratori.com/blog_0015" target="_blank" rel="noopener">Semantic compression</a> - статья про семантическое сжатие кода.</p><p>Про причины необходимости разбираться в железе писал в заметке <a href="https://spiiin.github.io/blog/3652741154/">десять лет в геймдеве</a>, разделы <strong><code>Гештальты геймдева</code></strong> и<br><strong><code>Инструменты</code></strong></p><h2 id="Научиться-работать-с-кодом"><a href="#Научиться-работать-с-кодом" class="headerlink" title="Научиться работать с кодом"></a>Научиться работать с кодом</h2><p><strong>Все</strong> умеют писать код. Кроме этого, необходимо уметь:<br><strong><code>- Переписывать (и переиспользовать) и документировать</code></strong><br><strong><code>- Тестировать</code></strong><br><strong><code>- Очищать и улучшать качество</code></strong><br><strong><code>- Профилировать</code></strong><br><strong><code>- Отлаживать</code></strong><br><strong><code>- Выявлять скрытые дефекты и ошибки</code></strong> (к примеру, статическим анализатором, инструментами поиска утечёк и обращений к освобождённой памяти)</p><p>Часто работу с кодом понимают только в контексте рефакторинга, но кроме в играх часто встречается необходимость улучшать производительность bottle-neck участков кода.</p><p>Примеры такой оптимизации (и создания инструментов оптимизации) в докладе <a href="https://www.gdcvault.com/play/1026635/-Witcher-3-on-the" target="_blank" rel="noopener">‘Witcher 3’ on the Nintendo Switch: CPU &amp; Memory Optimization</a>, на 14:42 Роман Лебедев рассказывает о создании инструмента, который показывает выравнивание структур в памяти и позволяет оптимизировать потребляемую память и скорость доступа к полям структур.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Как быть старшим программистом (в контексте “старшим разработчиком игр”) и чему учиться дальше.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>Скриншоты из PC-игр - 2</title>
    <link href="http://spiiin.github.io/blog/2486469456/"/>
    <id>http://spiiin.github.io/blog/2486469456/</id>
    <published>2021-02-15T11:21:04.000Z</published>
    <updated>2021-02-15T16:53:47.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ссылки на треды со скриншотами из PC игр с форума NeoGAF<br><a id="more"></a></p><p><a href="/blog/2347839193/" title="Старый пост">Старый пост</a> - со ссылками на периоды 2009-2016.<br>Несколько часов залипательного изучения красивейших скриншотов.</p><p><a href="https://www.neogaf.com/threads/2017-pc-screenshot-thread.1329720/" target="_blank" rel="noopener">2017</a><br><a href="https://www.neogaf.com/threads/2018-pc-screenshot-thread.1460776/" target="_blank" rel="noopener">2018</a><br><a href="https://www.neogaf.com/threads/2019-pc-screenshot-thread.1470464/" target="_blank" rel="noopener">2019</a><br><a href="https://www.neogaf.com/threads/2020-pc-screenshot-thread-of-no-compromises.1518478/" target="_blank" rel="noopener">2020</a><br><a href="https://www.neogaf.com/threads/2021-pc-screenshot-thread-of-no-compromises.1584774/" target="_blank" rel="noopener">2021</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ссылки на треды со скриншотами из PC игр с форума NeoGAF&lt;br&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
  </entry>
  
  <entry>
    <title>Шпаргалка по разработке MMO</title>
    <link href="http://spiiin.github.io/blog/1123790904/"/>
    <id>http://spiiin.github.io/blog/1123790904/</id>
    <published>2021-02-10T00:12:40.000Z</published>
    <updated>2021-02-10T01:17:22.497Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Набор ссылок и подсказки по терминологии для разработки многопользовательских и MMO-игр.</p><a id="more"></a><h2 id="Начальные-материалы"><a href="#Начальные-материалы" class="headerlink" title="Начальные материалы"></a>Начальные материалы</h2><p>Книга:<br>Многопользовательские игры. Разработка сетевых приложений Глейзер Д., Мадхав С. (<a href="https://www.piter.com/collection/programmirovanie-igr/product/mnogopolzovatelskie-igry-razrabotka-setevyh-prilozheniy" target="_blank" rel="noopener">ссылка</a>).<br>Описывает основные понятия, ориентирована больше на сессионные игры, иногда отсылает к изучению более продвинутых тем на другие материалы.</p><p>Статьи:<br><a href="https://habr.com/ru/post/467025/" target="_blank" rel="noopener">О сетевой модели в играх для начинающих</a> - описаны базовые понятия, много отсылок на другие статьи по разным темам.<br><a href="https://web.archive.org/web/20190519135537/http://trac.bookofhook.com/bookofhook/trac.cgi/wiki/IntroductionToMultiplayerGameProgramming" target="_blank" rel="noopener">Introduction to Multiplayer Game Programming</a> - хороший разбор вариантов выбора “нижнего уровня” игрового протокола, немного об игровой логике.<br><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a> - несколько статей о “верхнем уровне” игрового протокола.<br><a href="https://gafferongames.com/post/reading_and_writing_packets/" target="_blank" rel="noopener">Reading and Writing Packets</a> - методы сериализации.<br><a href="https://ruoyusun.com/2019/03/28/game-networking-1.html" target="_blank" rel="noopener">Game Networking Demystified, Part I: State vs. Input (series)</a> - серия статей с очень кратким обзором базовых понятий.<br><a href="http://t-machine.org/index.php/2013/06/22/mmo-scalability-is-finally-irrelevant-for-indie-mmos/" target="_blank" rel="noopener">MMO scalability is finally irrelevant for Indie MMOs</a> - небольшая статья о пропускной способности и мощности серверов.<br><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a> - о настройке сервера, поддерживающего 10000 TCP-соединений.</p><h2 id="Общая-архитектура-игры"><a href="#Общая-архитектура-игры" class="headerlink" title="Общая архитектура игры"></a>Общая архитектура игры</h2><p>Условно “Клиент-сервер-бекенд архитектура” (client/game server/web-server(with db), three-tiered server architecture), etc).<br>Конкретное устройство сильно зависит от потребностей игры. Примеры:</p><p><a href="https://www.ibm.com/developerworks/library/ar-powerup1/index.html" target="_blank" rel="noopener">Building a simple yet powerful MMO game architecture, Part 1</a> - обзор архитектуры от IBM.<br><a href="https://www.ibm.com/developerworks/library/ar-powerup2/" target="_blank" rel="noopener">Part 2</a> - вторая часть статьи (в самой статье кривые ссылки).<br><a href="https://www.ibm.com/developerworks/library/ar-powerup3/ar-powerup3.html" target="_blank" rel="noopener">Part 3</a> - третья часть.</p><p><a href="https://youtu.be/-AU_qlCu9ZI?t=361" target="_blank" rel="noopener">Бэкенд-разработка в геймдеве</a> – доклад Максима Барышников, Wargaming, тайминг на обзор архитектуры.</p><h2 id="Архитектура-игрового-сервера"><a href="#Архитектура-игрового-сервера" class="headerlink" title="Архитектура игрового сервера"></a>Архитектура игрового сервера</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/x_4Y2-B-THo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Очень хорошо и понятно описана архитектура всей игры, и возможное устройство сервера MMO (единственный найденный доклад с примером архитектуры реального проекта)</p><p><img src="/blog/1123790904/arch_server.png" alt="arch_server"></p><h2 id="Архитектура-клиента"><a href="#Архитектура-клиента" class="headerlink" title="Архитектура клиента"></a>Архитектура клиента</h2><p><code>Предсказание на клиенте</code></p><ul><li>чтобы не ждать ответа сервера, предсказывать информацию на основе предыдущих данных (если игрок двигается вправо - в следующем кадре скорее всего тоже будет). Если от сервера приходит другая информация, то плавно интерполировать реальные данные с предсказанными, чтобы избежать скачков.</li></ul><p><code>Разные техники сглаживания позиции</code></p><ul><li>интерполяция ставит клиента на полученное от сервера значение (минус - клиент видит позицию немного в прошлом)</li><li>экстраполяция - клиент пытается предугадать где будут другие игроки на основе данных с сервера (минус - если позиция резко изменится, будет большее расхождение)</li><li>(для fps) - компенсация лага - сервер “перематывает время назад”, и проверяет, что было на экране игрока в момент, когда тот выстрелил, чтобы не отказывать ему в попадании из-за задержки</li><li>Обязательно тестировать отладочным выводом и симуляцием лагающего клиента.<br><a href="https://www.youtube.com/watch?v=7jb0FOcImdg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=7jb0FOcImdg</a> - 8 Frames in 16ms: Rollback Networking in Mortal Kombat and Injustice 2<br><a href="https://www.youtube.com/watch?v=W3aieHjyNvw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=W3aieHjyNvw</a> - Overwatch Gameplay Architecture and Netcode (вторая половина)</li></ul><p><code>Переход игрока между зонами</code></p><ul><li>трансфер данных игрока между двумя шардами через бд.</li><li>можно сделать пересекающиеся зоны, когда игрок существует и видим одновременно из 2х соседних зон, или просто явным телепортом.</li></ul><p><code>Игровой цикл</code></p><ul><li><p>нужен апдейт с фиксированным шагом времени вместо обычного “update(dt)+render”<br><a href="https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-3/3.2-game-loop.html" target="_blank" rel="noopener">https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-3/3.2-game-loop.html</a></p></li><li><p>очередь событий<br>Не обрабатывать события напрямую, а ставить в очередь на отправку - можно оптимизировать, сделать батчинг, отбросить повторы, приоритезировать, . При приёмё - сортировать с другими событиями игровой очереди.<br><a href="https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-5/5.2-event-queue.html" target="_blank" rel="noopener">https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-5/5.2-event-queue.html</a></p></li></ul><h2 id="“Нижний-уровень”-протокола"><a href="#“Нижний-уровень”-протокола" class="headerlink" title="“Нижний уровень” протокола"></a>“Нижний уровень” протокола</h2><p>Понятия, относящиеся к уровню взаимодействия с ОС.</p><p><code>Оборачивать в заменяемые компоненты</code></p><p><code>Udp vs Tcp vs библиотека для смешанного решения</code></p><ul><li>чаще всего свой протокол - надстройка над udp</li><li>не надо писать свой, если не уверен в том, что надо :)</li><li>фичи транспортного протокола можно реализовать на прикладном уровне<ul><li>Варианты<br><a href="https://github.com/networkprotocol/yojimbo" target="_blank" rel="noopener">https://github.com/networkprotocol/yojimbo</a><br><a href="https://github.com/ValveSoftware/GameNetworkingSockets" target="_blank" rel="noopener">https://github.com/ValveSoftware/GameNetworkingSockets</a><br>использовать либу с обёртками</li></ul></li></ul><p><code>Порты для одного клиента - один vs несколько</code></p><ul><li>демультиплексинг данных не нужен - всё равно придётся инспектировать протокол</li><li>можно юзать, если много данных, чтобы получить больший буфер данных от операционной системы на пользователя</li><li>могут закончиться</li></ul><p><code>Опрос каждый кадр vs опрос в отдельном потоке</code></p><ul><li>способы опроса: iocp/epoll/kqueue</li><li>Проблема 10к соединений <a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></li><li>Библиотеки-обёртки для опроса портов и цикла событий:</li><li>libuv</li><li>libevent</li><li>boost asio<br><a href="https://libwebsockets.org/" target="_blank" rel="noopener">https://libwebsockets.org/</a><br><a href="https://stackoverflow.com/questions/118945/best-c-c-network-library" target="_blank" rel="noopener">https://stackoverflow.com/questions/118945/best-c-c-network-library</a></li></ul><p><code>NAT</code></p><ul><li>нужен id клиента кроме его адрес+порт (порт может внезапно измениться)</li></ul><h2 id="“Верхний”-уровень-протокола"><a href="#“Верхний”-уровень-протокола" class="headerlink" title="“Верхний” уровень протокола"></a>“Верхний” уровень протокола</h2><p>Прикладной уровень протокола</p><p><code>Разбиение пакетов</code></p><ul><li>если пришёл пакет с пропущенным номером - либо выбросить, либо положить в буфер, чтобы некоторое время подождать предыдущих</li><li>маленькие пакеты можно группировать в большие (и не забывать всё равно рассылать недозаполненные, чтобы избежать лага)</li><li>большие пакеты, не вмещающиеся по размеру, делить на подпакеты и слать отдельно, собирая на стороне получателя</li><li>пакеты с высоким приоритетом и с низким (передаются только когда нет высоких)</li><li>(возможны и решения на уровне библиотеки)</li></ul><p><code>Сжатие</code></p><ul><li>cначала убедиться, что клиенту отправляется ТОЛЬКО информация, которая ему необходима! </li><li>проверка, что видит игрок, и какие данные нужны его клиенту - pvs - potentionally visible set</li><li>урезать значения. float-&gt;16bit, int-&gt;8bit, битовые флаги -&gt;запаковать вместе</li><li>битовые потоки вместо байтовых</li><li>удобный трюк - 32 битовой число можно записать как литерал из 4х символов (“l34t” == 0x6C333474)</li><li>использовать для запаковки знание информации об игре</li><li>если изменяются не все поля объекта, можно использовать битовую маску, чтобы отметить какие из полей нужно прочитать.</li><li>отсекать многократно повторяющиеся команды на клиенте перед отправкой, также при обнаруженном сбое отправки отправлять не устаревшие данные, а последние (ещё один слой абстракции между игровым кодом и сетевыми пакетами)</li><li>слать клиенту не состояние, а дельту между состояниями (т.е. если не было изменения координаты какой-либо - не слать её повторно)</li><li>сжатие:<ul><li>rle</li><li>huffman</li><li>zlib<br><a href="https://github.com/r-lyeh-archived/quant" target="_blank" rel="noopener">https://github.com/r-lyeh-archived/quant</a> - библиотека для дискретизации</li></ul></li></ul><p><code>Сериализация данных</code></p><ul><li>библиотеки (много различий - требуют ли схемы, ending, поддержка rpc, etc)<ul><li>protocolBuffers, flatBuffers, cap’n’proto, thrift, msgpack, cereal, yas, boost::serialization, bitsery</li><li>своя схема на lex/yacc + кодогенерация</li></ul></li><li>Схему данных пакетов в теории можно не хранить на клиенте, а передавать на старте сессии - тогда не надо обновлять клиент (но лучше не надо)</li></ul><h2 id="Игровая-логика"><a href="#Игровая-логика" class="headerlink" title="Игровая логика"></a>Игровая логика</h2><p><code>Безопасность и читеры</code></p><ul><li>один читер может испортить игру 100-1000 игрокам</li><li>не слать клиенту информацию вроде “рядом с вами невидимый игрок”</li><li>проверять, не слишком ли много действий в секунду совершает игрок</li><li>не верить данным от клиента - авторитарный сервер</li><li>не изобретать своих шифрований и не хранить ключи симметричного шифрования на клиенте.</li><li>шифрование - у сервера есть приватный и публичный ключ. Клиент генерирует только симметричный ключ (уникальный для сессии) и передаёт серверу зашифровав публичным ключом сервера. Сервер шифрует данные симметричным ключом клиента.</li><li>libsodium</li></ul><p><code>Хинты для оптимизации игрового протокола</code></p><ul><li>Минимизировать или вообще избегать обязательных (reliable) рассылок апдейтов/rpc каждый такт от сервера клиентам.</li><li>Не реплицировать то, что можно не реплицировать (если какое-нибудь разрушаемое дерево вообще не влияет на геймплей - пусть клиенты считают его как хотят)</li><li>Если нужно реплицировать на клиент большой кусок данных (стартовое состояние мира при подключении) - передать не за один заход, а разбить на много мелких (иначе можно перегрузить сеть и другие клиенты будут лагать).</li><li>Возможная оптимизация клиента - удалять на клиенте всех акторов за пределами досягаемости камеры/гильдейских знаний игрока (не рендерить и не знать ничего о том, что он не может увидеть). Можно настроить время очистки.<br><a href="https://habr.com/ru/company/mailru/blog/352634/" target="_blank" rel="noopener">https://habr.com/ru/company/mailru/blog/352634/</a> Сетевая оптимизация для Unreal Engine 4</li></ul><h2 id="Отладка-сети"><a href="#Отладка-сети" class="headerlink" title="Отладка сети"></a>Отладка сети</h2><p><code>Замеры качества соеднинения</code></p><ul><li>проверка времени - ping</li><li>проверка потерь - либо считать пакеты, которые пришли с неверным порядковым номером, либо считать количество необходимых ретрансляций</li></ul><p><a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/Networking/NetworkProfiler/index.html" target="_blank" rel="noopener">https://docs.unrealengine.com/en-US/InteractiveExperiences/Networking/NetworkProfiler/index.html</a> - по ссылке - описание тулзы профайлинга данных по сети. Standalone тул. Клиент в отладочном режиме пишет в файл протокол, который можно загрузить в тулзу и исследовать.<br>(<a href="https://youtu.be/VusAHXoHF3Y?t=273" target="_blank" rel="noopener">https://youtu.be/VusAHXoHF3Y?t=273</a> - Replication Graph For Optimizing Real-Time Strategy Games | Unreal Fest Europe 2019 | Unreal Engine - пример использования)</p><ul><li>плейтесты на реальном сервере, тесты с сервером на машине разработчике нерепрезентативны</li><li>обязательно необходимо симулировать плохую сеть, чтобы понять, как будет вести себя клиент в экстремальных условиях</li><li>подсчёт трафика : поднимаете дедикейтед. устраиваете на нём плейтест. Смотрите траффик на отдельно взятом порту. Оцениваете, сколько в среднем траффика на вход и на выход.</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Набор ссылок и подсказки по терминологии для разработки многопользовательских и MMO-игр.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>10 лет в геймдеве</title>
    <link href="http://spiiin.github.io/blog/3652741154/"/>
    <id>http://spiiin.github.io/blog/3652741154/</id>
    <published>2021-02-05T15:31:25.000Z</published>
    <updated>2021-02-07T22:13:53.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Когда-то давно, когда я учился в университете на втором курсе, мой одногруппник скинул мне ссылку на раздел местного форума о поиске работы. <a href="https://www.gaijinent.com/" target="_blank" rel="noopener">“Гайдзины”</a> искали программистов в офис в Севастополе.<br>Я уже тогда решил для себя, что хочу делать игры, но не особо хотел бросать учёбу. Сходил на собеседование, после которого мне сказали, что подумают.</p><p>Подумали они около месяца, после чего в январе 2008 года пригласили в офис, чтобы начинать работать. Я отнёсся к этому как к стажировке (в универе всё равно были каникулы между семестрами), и согласился.<br>После каникул решил остаться там работать на полставки (работа, конечно, мешала учёбе, но зато можно было делать игры, и получать за это деньги).</p><p>В универе я успел покататься по олимпиадам по программированию, и заработать хорошую репутацию, так что на мои пропуски закрывали глаза, поэтому удавалось балансировать между работой и учёбой ещё 4 года (с учебными отпусками, временным самоувольнением поучиться семестр, и просто с забитием на универ к концу). Посчитал, что с учётом отпусков и перерывов, я профессионально занимаюсь разработкой игр уже около 10 лет.</p><p>У меня нет какой-то особенной мудрости, накопленной за эти годы, и поучающих советов другим (даже несмотря на то, что некоторые разделы поста выглядят как советы). Эти заметки написаны просто для себя.</p><a id="more"></a><h2 id="Зачем"><a href="#Зачем" class="headerlink" title="Зачем"></a>Зачем</h2><p>Когда давно работаешь в индустрии игр, в какой-то момент сталкиваешься с тем, что забываешь о своих изначальных желаниях и идеях - почему ты пришёл сюда и чего хотел. Каждый приходит в геймдев со своими собственными мечтами и намерениями.</p><p>Я пришёл с простой прагматичной целью – узнать, как делаются игры и эффекты в них, понять “магию”, которая создаёт картинки на экране. Я только открыл для себя <code>HoMM3</code> и <code>Warcraft3</code>, и в обеих играх мне дико нравилось заклинание “Цепь молний”. Моей локальной целью было сделать такую же.</p><p>И, о чудо, после выпуска пары казуалок, мы сделали экшн <a href="/blog/12483/" title="Braveheart">Braveheart</a>, с кучей визуальных эффектов, среди которых была и та заветная цепная молния!<br><img src="/blog/3652741154/braveheart-chain-lighting.png" alt="chain"></p><p>Однако, к тому моменту я уже понял, что моя цель - <code>делать крутые игры</code>, про которые я мог бы сказать это сам, и про которые так говорили бы игроки.</p><h2 id="Чем-вообще-занимаются-в-геймдеве"><a href="#Чем-вообще-занимаются-в-геймдеве" class="headerlink" title="Чем вообще занимаются в геймдеве?"></a>Чем вообще занимаются в геймдеве?</h2><p>Когда-то делал себе пометки, как это – <a href="https://spiiin.livejournal.com/82899.html" target="_blank" rel="noopener">работать программистом</a> в целом.<br>Недавно также отписывал в <a href="https://vas3k.club/question/7938/#comment-4f9155a7-8650-4551-a716-be5f576c5032" target="_blank" rel="noopener">закрытом сообществе</a> - в чем отличия разработки игр от других сфер:</p><p><strong><code>- В геймдеве встречаются очень разные задачи, от создания бекэнда и серверов для мультиплейерных игр до программирования графики, обычные гуи приложения (тулзы), скрипты автоматизации, оптимизации, архитектура движков.</code></strong></p><p> Несмотря на то, что есть специализации, за длительное время работы скорее всего окажется, что позанимаешься всеми. Это и плюс - расширяет кругозор, и не возникнет ощущения, что постоянно занимаешься чем-то одним, и минус - нельзя просто выучить что-то одно и пользоваться этим много лет, загребая деньги лопатой. Тем не менее, C++ из геймдева никуда не ушёл.</p><p>(тут должна быть картинка про зарплаты по отношению к другим сферам <code>&quot;Пишу на C++/Objective C/Java/Lua/Python/C#/GLSL/HLSL и ещё паре малоизвестных языков за еду&quot;</code>)</p><p><strong><code>- Тренды очень динамические, планка качества игр поднимается, и даже если делаешь клон очередной популярной игры, нужно сделать его чем-то лучше (иначе зачем в него играть).</code></strong></p><p>Кроме того, постоянно меняются способы монетизации, появляются новые платформы, то что было приемлемо пару лет назад, не сработает сейчас. Может оказаться, что игра, которую вы делали несколько лет, перестала быть актуальной. Игры делать дорого и долго, и всегда есть шанс, что игрокам просто не понравится то, что вы сделали.</p><p><strong><code>- Не стоит идти в геймдев, чтобы сделать игру мечты.</code></strong></p><p>Игры делают, чтобы зарабатывать деньги, поэтому делать вы будете то, что приносит деньги. Скорее всего, придётся писать очередную матч-3 или слоты для телефонов. Так что, если хотите длительно работать в геймдеве, вам должно нравиться делать вообще любые игры. Просто помните, что и <code>до разработки игры мечты тоже когда-нибудь доберётесь</code>.</p><p>Если просто хочется сделать свою крутую игру без опыта, <strong>НЕ НАДО</strong>: собирать команду друзей или участвовать в хакатонах (лучше вообще их не касаться, это как олимпиадное программирование). Лучше всего попробовать реализовать то, что хочется, в виде мода для уже существующей игры - так рождались <code>Counter-Strike</code>, <code>DotA</code>, <code>Team Fortress</code>.</p><p><strong><code>- В геймдеве чаще встречаются интересные люди, которые интересуются не только покупкой второй машины и куда вложить заработанные 300кк/сек$.</code></strong></p><p>Это мой опыт, кто-то отписывается, что видел геймдев-галеры.<br>Встречаются компании с интересной корпоративной культурой и необычной организацией, можно почитать про устройство <a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">Valve</a> или <a href="https://habr.com/ru/post/358882/" target="_blank" rel="noopener">Supercell</a>.</p><p><strong><code>- Делать игры компанией – всегда челлендж, сверх-усилие и рисковая ставка на вашу игру всей командой.</code></strong></p><p> Т.е. нужно быть немного азартным, и чувствовать себя <em>причастным</em> (как бы по сектантски это не звучало) к тому, что происходит.</p><p>Наверное, это меньше ощущается, если фрилансить (хотя написание кода в больших проектах аутсорсят намного реже, чем арт), или заниматься чем-то, что не связано с выпуском игры (например, писать игровой редактор или движок).</p><p><a href="https://kdicast.com/" target="_blank" rel="noopener">https://kdicast.com/</a> - можно послушать, чтобы вникнуть немного, чем живут разработчики игр.<br><a href="https://habr.com/ru/post/500320/" target="_blank" rel="noopener">https://habr.com/ru/post/500320/</a> - автор пытался провести исследование про кол-во людей в разных компаниях, можно представить себе разные по объёму и сложности игр компании.</p><h2 id="Периоды-разработки-игры"><a href="#Периоды-разработки-игры" class="headerlink" title="Периоды разработки игры"></a>Периоды разработки игры</h2><p>Одно из самых прикольных ощущений – понять, что участвовал в разработки игры с чистого листа и до релиза. Оценить, как труд десятков (или сейчас скорее даже сотен) людей воплощается в виде конечного продукта, в который будут играть миллионы пользователей.</p><p>Самые веселые периоды разработки: <code>придумывание концепта</code>, и стадия, когда становится понятно, <code>что представляет собой игра и какая она будет</code>.<br>Самые сложные: <code>полировка игры</code> (когда уже почти не добавляется ничего нового), и <code>кранчи перед релизом</code>.</p><p>Печально известные кранчи являются чуть ли не стандартом в разработке игр, их сейчас активно обсуждают повсюду (примеры <a href="https://habr.com/ru/post/489946/" target="_blank" rel="noopener">один</a>, <a href="https://dtf.ru/games/29454-kranchi-v-igrovoy-industrii-analiz-prichiny-posledstviya" target="_blank" rel="noopener">два</a>, <a href="https://dtf.ru/gamedev/14956-rabota-na-iznos-prichiny-i-posledstviya-kranchey-v-igrovoy-industrii" target="_blank" rel="noopener">три</a> ну или гуглите дальше самостоятельно). Интересно, изменится ли что-то от этих обсуждений :) . В результате люди устают и выгорают.</p><p>Последняя ночь перед выходом игры – это нервозное состояние, в котором ты находишься дни/недели/месяцы, и когда ты понимаешь, что от тебя и ещё нескольких человек зависит, получится ли что-то или не придётся ли чинить игру сразу же, как её попробуют игроки. Если поискать плюсы, то это лучший способ тимбилдинга (остальные – это по сути пьянки на деньги компании, что тоже конечно нужно), и проверка волевых качеств людей. В целом, ничего хорошего в этом, естественно, нет, особенно если ты старше 30, и понимаешь, что следующий апдейт/игра будут доделываться в точности так же.</p><p>Старая заметка из 2012 года, как вообще работать в таком режиме: <a href="/blog/19419/" title="Ускорение написания кода">Ускорение написания кода</a></p><h2 id="Как-развиваться"><a href="#Как-развиваться" class="headerlink" title="Как развиваться"></a>Как развиваться</h2><p>Старые заметки:<br><a href="/blog/1048/" title="2011 – Как устроиться на работу программистом">2011 – Как устроиться на работу программистом</a> – за короткий промежуток времени несколько одногруппников и один преподаватель задали этот вопрос, поэтому проще было давать им сразу ссылку :)<br><a href="/blog/15798/" title="2020 – Уровень программирования: Middle">2020 – Уровень программирования: Middle</a> – как быть, когда подрос немного.</p><p>В нормальных компаниях есть назначаемые менторы/товарищи, которые помогут влиться, и проследят за тем, чтобы не заваливали однообразными тасками, и была возможность делать что-то интересное. В целом, в геймдеве можно и нужно интересоваться всем, что происходит в команде. Тогда среди хаосы и суеты, можно начать видеть закономерности и процессы, и в них участвовать. Если этого нет, стоит хотя бы самому следить за тем, что вообще происходит в индустрии.</p><ul><li>Что происходит с рынком игр?</li><li>Какие тенденции у индустрии вообще?</li><li>Какие есть конкуренты у игры, которую вы делаете?</li><li>Какие игры вообще делает ваша компания, чем она особенная?</li><li>Что вы будете делать через год?</li><li>Новости: какие игры/платформы выходят, чем занимаются крупные студии?</li></ul><p>Если с ответами на эти вопросы всё ок (либо вас не особо волнуют), можно задуматься и о том, что изучать.</p><p>В первую очередь, конечно язык и движок, которыми пользуетесь, но с опытом вы поймёте, что программировать умеет много кто, а вот людей с пониманием всего процесса разработки намного меньше.</p><p>В маленьких командах вынужденно существует совмещение ролей - т.е. программист немного узнаёт о геймдизайне, маркетинге, издании игры, психологии игроков (понимании своей аудитории), и ещё о разных вещах по чуть-чуть. И если в большой команде какой-нибудь хитрец мог “выпустить игру”, просто гребя в одной лодке с теми, кто её действительно делал (или вообще, в сторонке кофе попивая на кухне), то в маленькой человек с большой долей вероятности знает в ней (в игре, да и в его команде) всё от начала до конца.</p><p>Преимуществом же работы в большой команде является то, что только в таких можно поучаствовать в создании действительно “большой” игры, на которую в маленькой просто не хватило бы ресурсов. Отдельный опыт – это вырасти с компанией от маленькой до большой, изучая, как меняется подход к разработке всё более продвинутых игр.</p><h2 id="Техническое-развитие"><a href="#Техническое-развитие" class="headerlink" title="Техническое развитие"></a>Техническое развитие</h2><p><em>“Что всё-таки почитать программисту игр?”</em><br>Найти какой-нибудь список литературы легко - <a href="https://github.com/miloyip/game-programmer" target="_blank" rel="noopener">https://github.com/miloyip/game-programmer</a><br>(По большей части там ненужные книги, но среди них есть все несколько хороших).</p><p>Вся литература делится на 4 категории:</p><p><strong><code>- Мануалы к инструменту.</code></strong><br>Нужны только в начале карьеры, с опытом проще просто документацией пользоваться, а не книгой</p><p><strong><code>- Набор суперполезных практик</code></strong><br>Здесь стоит читать всё, что получится достать и понять (некоторые целиком сразу не осилить).<br>Про такие книги стоит написать отдельно более детально, сейчас просто список:<br> <code>Стив Макконнел. &quot;Совершенный код&quot;</code><br> <code>Скотт Мейерс. &quot;Эффективное использование С++&quot;/&quot;Эффективный и современный С++&quot;/&quot;Наиболее эффективное использование С++&quot;</code> (все 3 хороши и покрывают разные темы)<br> <code>Банда четырёх. &quot;Приемы объектно-ориентированного проектирования. Паттерны проектирования&quot;</code><br> <code>Robert Nystrom &quot;Game programming patters&quot;</code> (<a href="https://gameprogrammingpatterns.com/" target="_blank" rel="noopener">ссылка</a>)</p><p><strong><code>- Фундаментальные книги.</code></strong><br>Нужны, но только когда появляется желание глубже разбираться в предмете. Обычно читать всё не нужно, достаточно выбрать только по своей специализации. Примеры:<br> <code>Нати Хофман, Томас Мёллер, и Эрик Хэйнс. &quot;Real-Time Rendering&quot;</code><br> <code>Джейсон Грегори. &quot;Архитектура игровых движков&quot;</code><br> <code>Глейзер Джошуа и Мадхав Санджай. &quot;Многопользовательские игры. Разработка сетевых приложений&quot; (единственная нормальная про сетевые игры)</code></p><p><strong><code>- Книги-справочники/сборники статей.</code></strong><br>Как все серии книг <code>Gems</code>. Не особо нужны, процентов 80% материала вам там никогда не понадобятся, а если и будет сходная с реальной задача, окажется, что информации для её решения там недостаточно, и всё равно нужно дальше копать.</p><p>Кроме книг, чтобы быть в курсе того, что происходит, нужно найти и следить за людьми из тех, кто занимается решением сложных проблем, и находится “на острие прогресса”:</p><p><code>Выступает с интересными техническими докладами (gdc, siggraph, тематические unity/unreal конференции)</code>.</p><p><code>Авторы интересных библиотек/движков/фреймворков</code>.  (для мониторинга: их гитхаб, блоги, твиттеры, reddit/hacker news-сообщества). Почти бесполезны митапы, бесполезные конфы, тусовочки, подкасты.</p><p><code>Изучить обновляемые подборки open-source библиотек</code>.<br><a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">Awesome c++</a>/<a href="https://github.com/Caerind/AwesomeCppGameDev" target="_blank" rel="noopener">Awesome C++ gamedev</a>/<a href="https://github.com/skywind3000/awesome-gamedev" target="_blank" rel="noopener">Awesowe gamedev tools</a>/подобные</p><p><code>&quot;Витрины&quot; тулзов и ассетов - Unity asset store, itch.io и подобные</code>.</p><p><code>Новые движки и подходы</code>.<br>Когда-то новыми были <strong>Unity</strong>, и открытый публике <strong>Unreal</strong>, из открытых можно было изучать <strong>Cocos-2d</strong>, <strong>Ogre3D</strong>, сейчас, к примеру, <strong>Godot</strong>, middleware инструменты вроде <strong>Bgfx</strong></p><h2 id="Гештальты-геймдева"><a href="#Гештальты-геймдева" class="headerlink" title="Гештальты геймдева"></a>Гештальты геймдева</h2><p>Объём того, что нужно знать программисту игр, вызывает лёгкую тоску. Это нормально. Вдобавок, знания приходится обновлять где-то раз в 5 лет (это нормально, наверное, для любой области CS). Но, кроме этого, после начала изучения некоторых областей встречаешься с ещё одним явлением, которое я называю “гештальтом”. Проще объяснить это на примере. </p><p><strong><code>Графическое программирование</code></strong><br>Начинающий программист заканчивает читать первую книгу или набор уроков по <code>OpenGL</code>/<code>DirectX</code>, пробует нарисовать что-либо, и обнаруживает, что кроме текстурированных кубиков и чайников, ничего не получается, вдобавок, они у него какие-то тусклые. Остаётся незакрытый гештальт - желание программировать графику и писать шейдеры, без понимания, как это сделать. Думаю, именно этим вызвано излишне романтизированное отношение начинающих программистов игр к шейдерам и программированию визуальных эффектов.</p><p>Почему же ничего не получается? API к видеокарте – это не всё, что нужно изучить. После этого необходимо разобраться с <code>математикой</code>,чтобы понять, как вообще устроена компьютерная графика. Это сложнее, чем просто разобраться с API, но зато после понимания основ уже почти не останется вопросов, почему конвейер видеокарты построен именно так. И, наконец, станет возможным реализовать задуманный эффект без того, чтобы слепо копировать его из учебников и статей. Можно попробовать заняться <a href="https://en.wikipedia.org/wiki/Creative_coding" target="_blank" rel="noopener">креативным программированием</a> или, наконец, написать шейдер сложнее, чем просто повторяющий стандартные модели освещения. Но и этого недостаточно, чтобы программировать графику для игр.</p><p>Есть и “третья сторона медали” – <code>изучение железа</code>, на котором будут выполняться программы. Игры обновляют изображение на экране 30-60 раз в секунду, и нужно научиться представлять себе, что можно успеть сделать за время отрисовки одного кадра на целевой платформе. Где-то на этом этапе по другому начинаешь смотреть на доступное API, и ощущать все его ограничения. Но зато – гештальт с желанием создавать графику наконец может быть закрыт.</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODY4IiBoZWlnaHQ9IjEyOCIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDg2OCAxMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTEwNC41IDQ0LjUgTDEwNC41IDY0LjUgTDI2Ni44IDg0LjUgTDI2Ni44IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI1Mi45IDg4LjIgTDI2MC4xIDgzLjcgTDI1NC4yIDc3LjYgTDI2Ni44IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zOTIuNSA0NC41IEwzOTIuNSA2NC41IEwzOTIuNSA4NC41IEwzOTIuNSA4NC41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zODcuMiA3MS4yIEwzOTIuNSA3Ny44IEwzOTcuOCA3MS4yIEwzOTIuNSA4NC41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNzIyLjUgNDQuNSBMNzIyLjUgNjQuNSBMNTM2LjYgODQuNSBMNTM2LjYgODQuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNTQ5LjMgNzcuOCBMNTQzLjIgODMuOCBMNTUwLjQgODguNCBMNTM2LjYgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTMuNSIgeT0iMTMuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE4MiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjIxLjUiIHk9IjM1IiBzdHlsZT0iIj7QmNC30YPRh9C10L3QuNC1IEFQSTwvdGV4dD4KPHJlY3QgeD0iMTk1LjUiIHk9Ijg0LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIzOTQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMDMuOCIgeT0iMTA2IiBzdHlsZT0iIj7Qn9GA0L7Qs9GA0LDQvNC80LjRgNC+0LLQsNC90LjQtSDQs9GA0LDRhNC40LrQuDwvdGV4dD4KPHJlY3QgeD0iMjM1LjUiIHk9IjEzLjUiIGhlaWdodD0iMzEiIHdpZHRoPSIzMTQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyNDMuOCIgeT0iMzUiIHN0eWxlPSIiPtCY0LfRg9GH0LXQvdC40LUg0LDQu9Cz0L7RgNC40YLQvNC+0LI8L3RleHQ+CjxyZWN0IHg9IjU4OS41IiB5PSIxMy41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjY2IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iNTk3LjgiIHk9IjM1IiBzdHlsZT0iIj7Qn9C+0L3QuNC80LDQvdC40LUg0LbQtdC70LXQt9CwPC90ZXh0Pjwvc3ZnPg==" /><p>Чаще всего эти три направления изучаются именно в таком порядке, из-за доступности материалов и сложности понимания, но они не базируются друг на друге. Т.е. изучить только железо, или только алгоритмы компьютерной графики можно, не это не даст инсайта <em>“ага, теперь я могу писать крутые шейдеры”</em>, необходимо разобраться в каждом из трёх.</p><p>Из-за того, что эти направления не связаны друг с другом, легко застрять на каком-то этапе на несколько лет с “незакрытым гештальтом”, без понимания, из-за чего же не получается выполнять практические задачи. Знаю по себе. Когда-то сам так застрял и смотрел на демосцену как на какое-то непостижимое чудо – <a href="/blog/10414/" title="2012 – inout">2012 – inout</a></p><p><strong><code>Сетевое программирование</code></strong><br>Второй обнаруженный мной гештальт – <code>программирование MMO</code>. Здесь тоже прежде чем начать что-то делать, необходимо понять сразу несколько идей, без которых перейти от базового повторения готовых идей и простых игр к серьёзным невозможно. Тут я не могу так чётко отделить “домены знаний” друг от друга, но попробую выделить такие направления изучения:</p><ul><li>Протоколы передачи данных</li><li>Создание игрового протокола</li><li>Общая архитектура игры</li><li>Архитектура клиента с авторитарным сервером</li><li>Архитектура масштабируемого сервера</li><li>Архитектура бекэнда и сервисов</li></ul><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzgwIiBoZWlnaHQ9IjUwNCIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDM4MCA1MDQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHJlY3QgeD0iMTMuNSIgeT0iMTMuNSIgaGVpZ2h0PSI0NzgiIHdpZHRoPSIzNTQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMS41IiB5PSIzNSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtCe0LHRidCw0Y8g0LDRgNGF0LjRgtC10LrRgtGD0YDQsDwvdGV4dD4KPHRleHQgeD0iMjMxLjIiIHk9IjEzOS41IiBzdHlsZT0iZm9udC13ZWlnaHQ6bm9ybWFsOyI+0J/RgNC+0YLQvtC60L7Qu9GLPC90ZXh0Pgo8cGF0aCBkPSJNMjIzLjIgMTE5LjUgTDIwOCAxMzkuNSBMMjA4IDE1OS41IEwyMDggMTU5LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTIwMi43IDE0Ni4yIEwyMDggMTUyLjggTDIxMy4zIDE0Ni4yIEwyMDggMTU5LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yMTkuNCAxMzMuMyBMMjE5LjIgMTI0LjggTDIxMC45IDEyNi45IEwyMjMuMiAxMTkuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMjE2IiB5PSIzNDIuNSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtCf0YDQvtGC0L7QutC+0LvRizwvdGV4dD4KPHBhdGggZD0iTTIwOCAzMjIuNSBMMjA4IDM0Mi41IEwyMjMuMiAzNjIuNSBMMjIzLjIgMzYyLjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTIxMC45IDM1NS4xIEwyMTkuMiAzNTcuMiBMMjE5LjQgMzQ4LjcgTDIyMy4yIDM2Mi41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNMjEzLjMgMzM1LjggTDIwOCAzMjkuMiBMMjAyLjcgMzM1LjggTDIwOCAzMjIuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5My44IDExOS41IEwzMDkgMTM5LjUgTDMwOSAzNDIuNSBMMzA5IDM0Mi41IEwyOTMuOCAzNjIuNSBMMjkzLjggMzYyLjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5Ny42IDM0OC43IEwyOTcuOCAzNTcuMiBMMzA2LjEgMzU1LjEgTDI5My44IDM2Mi41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNMzA2LjEgMTI2LjkgTDI5Ny44IDEyNC44IEwyOTcuNiAxMzMuMyBMMjkzLjggMTE5LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxyZWN0IHg9IjI2LjUiIHk9IjU3LjUiIGhlaWdodD0iMzEiIHdpZHRoPSI5NiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjM0LjUiIHk9Ijc5IiBzdHlsZT0iIj7QntCx0YnQtdC1PC90ZXh0Pgo8cmVjdCB4PSIxNjIuNSIgeT0iMjYuNSIgaGVpZ2h0PSI5MyIgd2lkdGg9IjE5MiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjIxMC41IiB5PSI0OCIgc3R5bGU9IiI+0JrQu9C40LXQvdGCPC90ZXh0Pgo8cGF0aCBkPSJNMTYyLjUgNTcuNSBMMzU0LjUgNTcuNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+Cjx0ZXh0IHg9IjE3MC41IiB5PSI3OSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtC70L7Qs9C40LrQsDwvdGV4dD4KPHBhdGggZD0iTTE2Mi41IDg4LjUgTDM1NC41IDg4LjUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8dGV4dCB4PSIxNzAuNSIgeT0iMTEwIiBzdHlsZT0iZm9udC13ZWlnaHQ6bm9ybWFsOyI+0LDRgNGF0LjRgtC10LrRgtGD0YDQsDwvdGV4dD4KPHJlY3QgeD0iMTQ3LjUiIHk9IjE1OS41IiBoZWlnaHQ9IjE2MyIgd2lkdGg9IjEyMiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjE2MC41IiB5PSIxODEiIHN0eWxlPSIiPtCh0LXRgNCy0LXRgDwvdGV4dD4KPHBhdGggZD0iTTE0Ny41IDE5MC41IEwyNjkuNSAxOTAuNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+Cjx0ZXh0IHg9IjE1NS41IiB5PSIyMTIiIHN0eWxlPSJmb250LXdlaWdodDpub3JtYWw7Ij7RgdC10YDQstC10YAxPC90ZXh0Pgo8cGF0aCBkPSJNMTQ3LjUgMjIxLjUgTDI2OS41IDIyMS41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMTU1LjUiIHk9IjI0MyIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtGB0LXRgNCy0LXRgDE8L3RleHQ+CjxwYXRoIGQ9Ik0xNDcuNSAyNTIuNSBMMjY5LjUgMjUyLjUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNMTQ3LjUgMjYwLjUgTDI2OS41IDI2MC41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMTU1LjUiIHk9IjI4MiIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtGB0LXRgNCy0LXRgDI8L3RleHQ+CjxwYXRoIGQ9Ik0xNDcuNSAyOTEuNSBMMjY5LjUgMjkxLjUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8dGV4dCB4PSIxNTUuNSIgeT0iMzEzIiBzdHlsZT0iZm9udC13ZWlnaHQ6bm9ybWFsOyI+0YHQtdGA0LLQtdGAMjwvdGV4dD4KPHJlY3QgeD0iMTk0LjUiIHk9IjM2Mi41IiBoZWlnaHQ9IjkzIiB3aWR0aD0iMTI4IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEwLjUiIHk9IjM4NCIgc3R5bGU9IiI+0JHQtdC60Y3QvdC0PC90ZXh0Pgo8cGF0aCBkPSJNMTk0LjUgMzkzLjUgTDMyMi41IDM5My41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMjAyLjUiIHk9IjQxNSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPkRCPC90ZXh0Pgo8cGF0aCBkPSJNMTk0LjUgNDI0LjUgTDMyMi41IDQyNC41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMjAyLjUiIHk9IjQ0NiIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtCh0LXRgNCy0LjRgdGLPC90ZXh0Pjwvc3ZnPg==" /><p><em>Примерная диаграмма игры, может отличаться в разных проектах.</em></p><p>Несмотря на то, что на диаграмме различные компоненты нарисованы отдельно, заниматься разработкой отдельной части без базового понимания архитектуры и устройства других компонент не получится (В целом, отделяется бекэнд, и связь между клиентом и сервером; но писать клиент без знания игрового и лежащего под ним протокола и существования авторитарного сервера не выйдет).</p><p>Кроме непосредственно архитектуры отдельных компонент, сами части тоже имеют определённые уровни понимания. Например, для игрового сервера:</p><ul><li>дизайн асинхронных систем</li><li>работа с ОС</li><li>знание о уровнях сетевых протоколов ниже прикладного</li><li>понимание причин задержек и умение их устранять</li><li>синхронизация данных</li><li>навыки написания надёжного кода</li></ul><p>Собрать нужную для освоения информацию и проверить её здесь немного сложнее, чем с графикой.</p><p><strong><code>Движки</code></strong></p><p>Движок выглядит как огромная монолитная система для игрового программиста, со своими правилами, подходами и идиомами.</p><p>Ему приходится смотреть на новый движок так:<br><img src="/blog/3652741154/game-engine.png" alt="game-engine"><br><em>(Схема из книги Джейсона Грегори. “Архитектура игровых движков”)</em></p><p>В комплекте с движком обязательно идут игровые тулзы и инструменты, для их описания можно было бы нарисовать ещё одну такую же по размерам схему.</p><p>Движки в целом, конечно, намного лучше разбиты на компоненты, которые не требуют понимания других частей системы, но показательно то, что существует очень мало отделяемых от движка компонент, которые могут быть использованными в других игровых движках. Например, на приведённой выше схеме отделяемым и переносимым компонентами отведена <strong>ОДНА</strong> строчка.</p><p>Из-за этого я с энтузиазмом на проекты с попытками вынести в отделяемые компоненты, то что ранее не отделялось, например <a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">Bgfx</a>.</p><p><strong><code>Не гештальты</code></strong><br>Сначала хотел попытаться выделить в гештальты ещё какие-либо подходы к <code>дизайну</code> систем, однако понял, что это совсем не так – проектировать программы можно без понимания “всей картины”. Навыки построения хорошей архитектуры, к счастью, прокачиваются (если их прокачивать) с каждой следующей попыткой.</p><p>Также не является гештальтом <code>навык программирования</code> в целом. Вполне можно писать программы, не понимая как-либо важных концепций computer science, например, без рекурсии, лямбда-исчисления, или даже указателей. Понимание новых идей расширит арсенал выбора решений и может (только может, не обязано) сделать код компактнее, надёжнее, быстрее, и главное, <strong>ПРОЩЕ</strong>, но не откроет доступ к чему-то принципиально недостижимому ранее.</p><p><a href="https://www.youtube.com/watch?v=SzJ46YA_RaA&amp;ab_channel=DoS-DomainofScience" target="_blank" rel="noopener">Карта информатики</a> занимательна для изучения, но необязательна, чтобы заниматься любой из областей компьютерных наук.</p><h2 id="Инструменты"><a href="#Инструменты" class="headerlink" title="Инструменты"></a>Инструменты</h2><p>Одним из свойств человека, возвышающим его над другими животными, является умение и желание создавать инструменты для решения задач. Уровень сложности и скорость решения задач, которые мы можем решить, ограничены тем, можем ли мы найти или создать необходмый инструмент. Сами программы являются нашими инструментами, но иногда, особенно, новичкам, кажется, что инструменты программиста – это ТОЛЬКО программы.</p><p><strong><code>Железо</code></strong></p><p><code>Исследуйте железо и платформу, на которой будет работать ваша игра</code><br>(актульально и для других типов программ, не только игр)</p><p>Большой обман индустрии - <em>“Software is a platform”</em>. Но карта не территория – <em>“Hardware is a platform”</em>.<br>Тут проще не пересказывать дальше, а просто взять доклад Майкла Эктона - <a href="https://www.gdcvault.com/play/1012200/Three-Big-Lies-Typical-Design" target="_blank" rel="noopener">Three Big Lies: Typical Design Failures in Game Programming</a> (Тайминг 18:52). Или этот вариант на youtube:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/rX0ItVEVjHc" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Что вам даст понимание железа?</p><p><code>Возможность получить больше от железа</code> - или даже подойти к тому, чтобы выжать максимум производительности.<br><code>Использовать особенности железа в свою пользу</code> - aka “Хакинг”. Можно выйти и за пределы максимума.<br><code>Закрытие гештальтов</code> - добраться наконец до понимания и начать делать крутые вещи.<br><code>Выкинуть клоунов из машины</code> - <a href="https://youtu.be/p65Yt20pw0g?t=112" target="_blank" rel="noopener">ссылка</a>. Железо телефонов и консолей чаще всего достаточно мощное, но вы не можете его использовать оптимально. Если ваша машина едет недостаточно быстро, то, возможно, проблема не в движке, а в том, что машина полна клоунов.<br><img src="/blog/3652741154/clowns.jpg" alt="clowns"><br><a href="https://tonsky.me/blog/disenchantment/ru/" target="_blank" rel="noopener">Разочаровние в софте</a> - статья Никиты Прокопова о деградации современного софта.</p><p><strong><code>Изучайте способы получения информации о вашей игре</code></strong><br>Даже понимая устройство железа, сложно предсказать поведение игры с учётом ВСЕХ его особенностей вместе. Оптимизация может не дать ожидаемого результата из-за чего-то неучтённого заранее. Поэтому не стоит забывать об измерениях на реальном железе, или на созданных синтетических тестах. </p><p>Естественно, базовые способы получения информации - это измерение скорости выполнения отдельных частей кода и количества потребляемой памяти.</p><p>Возможный выбор улучшаемых параметров игры:<br><code>Уменьшение времени запуска игры</code><br><code>Уменьшение потребления памяти в основных сценах</code><br><code>Уменьшение требований к мощности процессора и видеокарты игры</code><br><code>Уменьшение дистрибутива игры</code></p><p>Ну и в дополнение к железным параметрам, геймплейные и маркетинговые:<br><code>Уменьшение времени до получения игроков удовольствия от игры (игровая сессия или её часть)</code><br><code>Уменьшение необходимых усилий по трате игроков денег</code></p><p>С учётом времени сборки игры и выполнения самих тестов, стоит задуматься также:<br><code>Уменьшение времени сборки и доставки игры команде разработки, тестирования, поддержки (и остальным)</code><br><code>Уменьшение времени проведения проверок и тестов</code><br><code>Уменьшение времени реакции на ошибки и их исправления</code></p><p><strong><code>Старайтесь создавать и находить совместимые друг с другом компоненты</code></strong></p><p>  <a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a> - entity-component-system - подход к дизайну программ, одной из особенностей которого является проектирование компонент так, чтобы переиспользовать их.</p><p>  <a href="/blog/3291927125/" title="Модульность в дизайне уровней">Модульность в дизайне уровней</a> - не только в программировании.</p><p>Это сложнее, чем создавать или использовать готовые монолитные решения, и имеет смысл только в длительной перспективе, но даёт возможность переиспользования отдельных частей в других похожих проектах.</p><h2 id="Языки-программирования"><a href="#Языки-программирования" class="headerlink" title="Языки программирования"></a>Языки программирования</h2><p>Рассуждения о языках:<br><a href="https://floooh.github.io/2018/06/02/one-year-of-c.html" target="_blank" rel="noopener">One year of C</a> - Andre Weissflog о разных языках и их качествах<br><a href="https://habr.com/ru/post/259831/" target="_blank" rel="noopener">Как я нашёл лучший язык программирования</a> - Андрей Платов о поисках лучшего в мире языка</p><p>Знать один язык программирования в современном мире для разработчика катастрофически мало.</p><p>Во-первых, в многих областях в проектах используется по несколько языков изначально (веб, разделеный по языкам бекенд и фронтенд, системы сборки как недо-язык, скриптовый язык для гуи или логики программы).</p><p>Во-вторых, даже если есть “супер-подходящий” для какой-либо области язык, существует большой шанс остаться динозавром, когда ему на смену придёт что-то другое. Даже если кажется, что язык в своей нише будет использоваться много лет, с текущей скоростью обновления версий языков, разница между несколькими версиями одного языка выглядит значительной (программист, знающий только ранние версии C#, Java, C++, скорее всего вообще не поймёт код на современных версиях). “Новые” фичи из обновленных стандартов языков - на самом деле уже обкатаны в других менее известных языках, и значительно проще начинать пользоваться ими не с нуля.</p><p>В-третьих, рано или поздно наступает “смена эпох”, когда приходит новая парадигма, позволяющая решать задачи быстрее. Это одно из важнейших качеств языка - увеличивать производительность программиста, использующего его (точнее даже, речь не только о самом языке, правильнее наверное называть это сменой технологии). Раньше других обнаружить такое может быть полезно для получения преимуществ над конкурентами.</p><p>В-четвёртых, даже если языка хватает для работы, есть ещё программирование “для души”. Языки “для работы” могут быть эффективными в какой-либо предметной области (или просто являться де-факто стандартом, не имея каких-либо преимуществ), но быть совершенно неудобными для того, что использовать их для создания домашних проектов. Найти что-то принципиально отличающееся от используемого обычно языка позволяет “расширить сознание” - начать получать больше удовольствия от программирования, по новому взглянуть на старый хорошо известный язык.</p><p>Однако изучать все языки подряд не хватит ни времени, ни сил, поэтому удобно подобрать набор языков, из которых составится личный “швейцарский нож” для решения максимально широкого спектра задач.<br>Моя основная пара языков – С++ и Python.</p><p><strong><code>C++</code></strong><br>Основной годами используемый мной в работе язык - С++, естественно, в разработке игр выбор невелик. Очень хорошо подходит для:</p><p><code>Разработка движков игр</code>. Основная причина, по которой используется именно он - это один из немногих языков, которые позволяют писать как на максимально низком уровне, позволяя детально контролировать место и способы расположения данных в памяти, так и на достаточно высоком, не вдаваясь в эти детали там, где это не нужно (правда, и по скорости такой код будет “обычным”). Плата за это - сложность языка и необходимость понимания многих деталей его работы. Причём сложность возрастает с каждым новым обновлением стандарта, и чтобы разобрать все нюансы правил, необходима бригада трактовщиков стандарта, а также специалистов по всем компиляторам, которыми должна быть собрана программа. С++ - это единственный известный мне язык, в котором абсолютно необходимы запреты на использование различных его частей. Для разработки логики игр могут быть использованы и другие языки.<br><a href="https://floooh.github.io/2013/06/21/sane-c.html" target="_blank" rel="noopener">Sane C++</a> - небольшая статья про C++ в геймдеве</p><p>Для логики игр C++ в основном используют там, где по какой-то причине нельзя использовать другие языки. Или если сложно разделить движковый и игровой код, или нужно остаться в рамках одного языка по другой причине, чтобы не требовать знания двух языков от разработчика. Но идея с вынесением логики на lua или c# (как в Unity) здравая.</p><p><code>Кросс-языковые библиотеки</code>. Практически все языки имеют возможность взаимодействовать в библиотеками, написанными на языке C. Если планируется, что код может быть вызван из десятка других языков - лучше написать его на C (или на сильно ограниченном подмножестве языка C++).</p><p>Немного хуже для:<br><code>Низкоуровневый код</code>. Тут наверное даже лучше подходит C, как “обёртка над ассемблером”, если где-то это ещё нужно. Почти не сталкивался (для NES собирал бинарники с помощью CC65), возможно лучше подойдёт Go.</p><p><code>Достоинства</code> - С++98 платформонезависимый код, написанный десятки лет назад, вероятно скомпилируется и будет работать (минус - и он до сих пор может вам попасться). Код легко собрать под любую архитектуру (хотя с появлением компиляторов в LLVM байт-код, это стало проще и для других языков).<br><code>Минусы</code> - язык-франкенштейн, к которому продолжают пришивать куски. Надстройки над языком - шаблоны, которые не очень органично сочетаются с самим языком (сообщения об ошибках в шаблонах до сих пор могут взорвать мозг неподготовленному программисту), порождающие свой стиль программирования, тяжелый для изучения; макросы, никак не проверяющие корректность предложенной замены. Ошибки доступа к памяти - утечки, сегфолты, нулевые указатели. Легко упустить ситуацию, когда объекты классов могут выполнить очень много неочевидных действий, ускользнувших от внимания программиста. При работе в команде вам придётся отслеживать различные попытки использовать язык неправильно, или устанавливать запреты на использование “нехороших” (медленных, опасных, недоделанных) фич языка.</p><p>Возможные замены:</p><ul><li>D - попытка исправить недостатки С++, малопопулярный язык. </li><li>Objective C/Objective C++ - такая же <em>“франкенштейновость”</em>, vendor-привязка к Apple.</li><li>Rust - сырой (не production-ready для игр).</li></ul><p><strong><code>Python</code></strong></p><p>Зная только его, можно сделать очень многое!<br>Очень хорошо подходит для:</p><p><code>Автоматизации всего</code> - множество готовых модулей для всего, что только можно. Изначально я изучил его на работе и был впечатлён именно этим - можно было упростить большое количество рутинных задач, причём решения можно записать в несколько строк. Также на тот момент сильно порадовала простая работа с файлами и сетью (хотя, если разбираться глубже, с этим есть проблемы - то баги работы с протоколами в стандартной библиотеки, то ад с заданием кодировок, но это всё было во времена Python 2.4. Второй питон и медленный переход на третий вообще, имхо, был главной проблемой языка). Альтернативы в этом особо нет, возможно, Perl, который отпугивает синтаксисом.</p><p><code>Cкриптование своих и чужих программ</code>. Python относительно легко встроить в свои программы, чтобы получить возможность использовать их в качестве библиотеки, или дать возможность продвинутым пользователям выполнять их собственные задачи с помощью вашей программы. Также, он очень часто встроен в различные профессиональные программы, и навыки работы с ним помогут вам пользоваться ими в полной мере. Для скриптования встречается Lua в тех программах, где нужна легковесность взамен мощи, и JavaScript там, где, гмм, программа представляет собой страничку для отображения контента (шутка, на самом деле тоже очень интересный вариант для скриптования). </p><p><code>Научных рассчётов</code>. Много готовых библиотек - NumPy/SciPy - стандарт для “серьёзной науки”. При этом чаще всего код, критичный по производительности, пишется на С, и компилируется в динамическую библиотеку, после чего её можно импортировать как модуль в Python. Также очень круто выглядит Jupyter Notebook - в котором можно как писать код, так и оформлять статьи. Про него вообще лучше рассказать как про отдельный инструмент - это оболочка для интерактивной работы с любыми языками, для пользователя выглядящая как страничка в браузере. Альтернативы - Matlab и специализированные программы, или вообще оставаться в рамках си ради скорости.</p><p>Немного хуже подходит для:<br><code>Прототипирование</code>. Быстрая сборка на коленке сложных вещей – моя любимая часть в программировании. Вначале это очень впечатляет, однако именно из-за этой области хочется добавить в свой арсенал какой-нибудь язык, который при сопоставимой скорости разработки и доступности библиотек не имел бы недостатков Python - низкой скорости быстронаписанного кода, невозможности легко запаковать приложение в standalone исполняемый файл (фактически есть два пути - либо учить пользователей ставить интерпретатор и запускать скрипты, либо паковать весь Python и модули вместе с приложением). Также не особо радует динамическая типизация, не хочется отказываться от возможностей компилятора в проверке и оптимизации кода. В качестве замены мог бы подойти <a href="https://nim-lang.org/" target="_blank" rel="noopener">Nim</a></p><p><code>Недостатки</code> - не очень хорошо подходит для функционального стиля программирования (анонимные функции искусственно ограничены в синтаксисе, не всегда возможно красиво записать в “функциональный однострочник” то, что хочется); различия в версиях интерпретатора усложняют проверку кода и библиотек.<br>Достоинства - код очень идиоматичен, среди множества различных способов что-либо сделать можно найти “самый красивый”; приятный синтаксис; учится за несколько дней. Кроссплатформенный для десктопных ОС (если очень постараться, можно с ограничениями использовать для мобильных платформ, из-за ограничений все прелести теряются - ни для одной из перечисленных целей полноценно использовать не получится).</p><p>Вместо Python для прототипирования пробовал:</p><ul><li>Swift<br>Бегло, приятный python-inspired синтаксис, но за пределами операционных систем от Apple не ясно, как это будет жить.</li><li>C#/Scala/Kotlin<br>Внимательно. Выразительные языки, после некоторого шаманства можно добавить возможность интерактивной работы и скриптования, с большой базой готовых кроссплатформенных библиотек .Net/JVM и возможностью использовать в связке с другими языками (на самом деле, это не особо удобно именно в плане смешивания языков, чисто совместимость на уровне байткода и интерфейсы к классам), главный минус - раздутость виртуальных машин, для небольших pet-проектов тащить таких монстров грустно. У функциональных языков иногда слишком “математический” синтаксис, к которому нужно привыкнуть.</li></ul><p>Кроме C++/Python могут быть полезны, на мой взгляд:<br><code>C#</code> - быстро накидать формочки гуи и начать писать логику.<br><code>JavaScript</code> - расковырять что-нибудь в браузере, минимальный код в веб-страничке. Парсинг интернета<br>Что-нибудь из функциональных языков - просто практиковаться в изучении систем типов.</p><h2 id="Культура-разработки"><a href="#Культура-разработки" class="headerlink" title="Культура разработки"></a>Культура разработки</h2><p><code>Пускай код остаётся простым!</code><br><a href="https://www.youtube.com/watch?v=eWbPLSJZ5Zw" target="_blank" rel="noopener">Simple Made Easy</a> - доклад Рича Хикки о том, как сохранять простоту.<br>Основное занятие программистов – это борьба с возникающей сложностью, а в простом неспутанном коде сложности будет меньше. Вязанный замок переделать будет сложнее, чем замок, собранный из кубиков лего.<br><img src="/blog/3652741154/castles.png" alt="castles"></p><p><a href="/blog/503948690/" title="2016 - Строители и ломатели">2016 - Строители и ломатели</a> - моя заметка про строителей и ломателей замков.</p><p>Часто в ООП ищут способ дизайна программ, однако (как из названия понятно), его там нет. Так что, подходы к дизайну можно и нужно изучать отдельно.<br><a href="https://dataorienteddesign.com/dodbook/" target="_blank" rel="noopener">Data-Oriented Design</a> - книга Richard Fabian.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Когда-то давно, когда я учился в университете на втором курсе, мой одногруппник скинул мне ссылку на раздел местного форума о поиске работы. &lt;a href=&quot;https://www.gaijinent.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“Гайдзины”&lt;/a&gt; искали программистов в офис в Севастополе.&lt;br&gt;Я уже тогда решил для себя, что хочу делать игры, но не особо хотел бросать учёбу. Сходил на собеседование, после которого мне сказали, что подумают.&lt;/p&gt;
&lt;p&gt;Подумали они около месяца, после чего в январе 2008 года пригласили в офис, чтобы начинать работать. Я отнёсся к этому как к стажировке (в универе всё равно были каникулы между семестрами), и согласился.&lt;br&gt;После каникул решил остаться там работать на полставки (работа, конечно, мешала учёбе, но зато можно было делать игры, и получать за это деньги).&lt;/p&gt;
&lt;p&gt;В универе я успел покататься по олимпиадам по программированию, и заработать хорошую репутацию, так что на мои пропуски закрывали глаза, поэтому удавалось балансировать между работой и учёбой ещё 4 года (с учебными отпусками, временным самоувольнением поучиться семестр, и просто с забитием на универ к концу). Посчитал, что с учётом отпусков и перерывов, я профессионально занимаюсь разработкой игр уже около 10 лет.&lt;/p&gt;
&lt;p&gt;У меня нет какой-то особенной мудрости, накопленной за эти годы, и поучающих советов другим (даже несмотря на то, что некоторые разделы поста выглядят как советы). Эти заметки написаны просто для себя.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Итоги 2020</title>
    <link href="http://spiiin.github.io/blog/307513906/"/>
    <id>http://spiiin.github.io/blog/307513906/</id>
    <published>2021-01-17T14:36:47.000Z</published>
    <updated>2021-01-18T00:20:42.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Никогда не подводил итогов года, но почему бы не начать в этом.</p><a id="more"></a><p><strong><code>Дисклеймер</code></strong><br>Я, как и все остальные люди, склонен обращать больше внимания на успехи в своей жизни, чем на пиздецы и фейлы, поэтому перед позитивными итогами этого года, сначала немного негативные итоги предыдущих, но сжато.</p><p>Прошлый год стал для меня переломным в том плане, что прекратил попытки решить все накопленные проблемы одновременно. А накопились они по причине того, что загнал себя в замкнутый круг попыткой решать их не по одной, а все сразу - наладить личную жизнь, заняться обустройством дома и поменять работу одновременно.</p><p>Вместо полноценной работы выбрал несколько часов фриланса в день, чтобы хватало времени на ремонт старого дома, однако в таком режиме не хватало денег на отдых. Для того, чтобы найти нормальные отношения не хватало времени из-за ремонта и фриланса, а на полноценную работу не хватало времени из-за отношений и ремонта. Сейчас я понимаю, что стоило просто посоветоваться с кем-то, кто был опытнее и умнее, или просто мог посмотреть на мои проблемы со стороны (такие люди были, просто я их не замечал или не слушал). Но спасибо и тем, кто просто был рядом, без всяких советов.</p><p>В итоге, после того, как слёг на несколько недель с температурой, пришлось начинать с нуля ещё раз, на этот раз с упором на работу. Мир устроен так, что с помощью денег остальное тоже становится проще, главное не забывать, что это лишь средство, а не цель. Ну и то, что это средство решать не только ваши персональные проблемы, но ещё и тех, кому вы хотите помочь.</p><p>Попутно, к сожалению или к счастью, прекратил общение со многими старыми знакомыми – до сих пор плохо умею разрывать контакты. Кто-то перестал общаться со мной, часто обоснованно. Пришлось усвоить несколько неприятных уроков общения, и то, что люди могут быть опаснее для окружающих, чем показывают, и даже, чем думают сами. Самый опасный хищник – тот, кто считает себя праведником.</p><p>Тем не менее, я всё ещё уверен, что большинство людей в мире по-умолчанию стремятся к построению любых отношений с другими по принципу win-win, и это прекрасно.</p><p>Йоханга.</p><p><strong><code>Путешествия</code></strong><br>В конце прошлого года, перед рождеством, побывал в Сингапуре, в небольшой командировке. Яркий футуристический неоновый город с небоскрёбами, казино и красивейшими Botanic Gargdens.</p><p><img src="/blog/307513906/singapur_small.jpg" alt="foxy"></p><p>В этом съездил в Крым зимой и летом – увидеться с родственниками, и погулять с палатками по разным уголкам и устроить гастротур по местным малоизвестным ресторанчикам. Бахчисарай-Севастополь-Инжир-Айа-Коктебель. Хотелось ещё заскочить в западный Крым, но немного не хватило времени.</p><p><img src="/blog/307513906/ingir_small.jpg" alt="ingir"></p><p><strong><code>Работа</code></strong></p><p>За пару месяцев перед началом локдауна я стал лидом проекта, который скоро нужно было запускать на софт. Поэтому после закрытия офисов (учитывая, что работа вне офиса до этого не практиковалась), баланс между кодингом и решением всевозможных организационных вопросов сместился где-то на 15%/85%, что было очень сильно непривычно в начале. Софт, естественно, немного задержался, но явно меньше, чем мог бы. Хотя в итоге после выхода игры, ещё где-то неделю до отпуска было ощущение не то, что выгорания, а сгорания.</p><p>Сама игра – <a href="https://mytona.com/game/6" target="_blank" rel="noopener">Crooked Pines</a></p><p><img src="/blog/307513906/cp_small.jpg" alt="cp"></p><p>Одно из самых ярких впечатлений года - в апреле собрались попрощаться втроём в Парке 300-летия с ребятами, с которыми за время работы в офисе установилась какая-то безумная творческая атмосфера, когда понимаешь, что получаешь настоящий кайф от работы, восхищаешься тем, что делают другие и делаешь сам. Грустно понимать, что вчера было так, а через несколько дней разлетаемся на 6000 километров.</p><p><img src="/blog/307513906/park_small.jpg" alt="park"></p><p>Ещё разок удалось вспомнить, что такое тимбилдинг и командный дух во время одного из релизов апдейтов - когда к 4-5 утра исправляются последние ошибки, и нервные шутки от команды QA перед последней (или непоследней, как повезёт) проверкой игры. Это выматывает физически и психологически, зато объединяет, формирует ядро команды, и проявляет волевые качества людей. Все остальные формы корпоративного “тимбилдинга” - это просто пьянки на деньги компании (что, конечно, тоже здорово).</p><p>Дальше - обустройство домашнего рабочего места и попытки найти себя в новой реальности пандемии.</p><p><img src="/blog/307513906/home_small.jpg" alt="home"></p><p><strong><code>Личное</code></strong></p><p>Работая в it-компании, программисты (особо после релокейта) не особо заморачиваются с обустройством жилища, так как всё равно местом обитания является офис со всеми возможными плюшками, а дом является место ночлежки. Поэтому если приходится проводить дома почти всё время, вынужденно приходится привести рабочее место в порядок (отдельная приятная опция работы в хорошей компании - возмещение расходов на все минимально необходимые вещи).</p><p>Надежды, что пандемия закончится быстро, я не питал, поэтому просто принялся перестраивать быт с расчётом на то, что придётся отсиживаться долго. Т.е. просто изучил всё что, было рядом с домом. Я живу в Питере на Пискарёвке - кругом обнаружилось множество парков, старое Богословское кладбище и железнодорожная станция с электричками, на которых можно было начать изучать Ленобласть и окрестности. Особенно запомнились поездки на Хепоярви - там можно бродить пешком, кататься на великах, жарить шашлыки и заниматься активным отдыхом.</p><p><img src="/blog/307513906/hepoyarvi_small.jpg" alt="hepoyarvi"></p><p>Чтобы минимизировать риск заразиться, но не сойти с ума в изоляции, пытался общаться с небольшой замкнутой компанией друзей и коллег, также поддерживающих подобную стратегию изоляции.</p><p>Случайно встретил свою вторую половинку.<br>Просто наплевали на все правила, пили пиво на закрытой на карантин детской площадке (какая разница, если вокруг пост-апокалипсис?), гуляли по всё тому же Парку 300-летия ночью, смотрели на рассвет с какой-то крыши, и поняли, что нашли друг друга.</p><p><img src="/blog/307513906/foxy_small.jpg" alt="foxy"></p><p><strong><code>Музыка</code></strong><br>Мой гимн этой весны, в связи с коронавирусом, однозначно - <code>AnnenMayKantereit &amp; K.I.Z. - Hurra die Welt geht unter</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/0nouhZQqtx4" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Также моим личным открытием стал электро-свинг - музыка и танцы. Мечтаю разучить несколько движений и научиться совмещаться их с жонглёрскими движениями.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/S_874GjbUII" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Ну, и знатный стёб от Гудкова - <code>Cream Soda - Никаких больше вечеринок</code>. В одном из клипов нашёл прикольное место, которое хочется посетить в 2021 году – <a href="https://www.google.com/search?q=%D0%BA%D0%BE%D0%BD%D0%B4%D1%83%D0%BA%D0%B8&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=2ahUKEwiknfXktKPuAhUomYsKHfKoCUwQ_AUoAXoECBMQAw&amp;biw=1920&amp;bih=947" target="_blank" rel="noopener">Кондуки</a><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/M95iEQx20Ag" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><strong><code>Приобретения</code></strong></p><p>Ещё вначале года я был уверен, что никогда не решусь завести собаку в квартире, и вообще, с собаками так грустно прощаться, что хочется завести её лет за 15-20 до собственной смерти, не раньше. Но к середине года я решил, что мне нужен друг и товарищ, с которым можно бродить по паркам и дрессировать его. Всё детство я жил в частном доме, в котором были дворняги, но при заведения собственного собакена решил попробовать породистого.</p><p>С трудом удержался от охотничьего по натуре джека-рассела, переключившись на генетических пастухов – корги. После поездки за город в питомник, у меня дома появился двухмесячный разноглазый кардиган-мерль Халк (потому что цветом как камень <code>Халцедон</code>).</p><p><img src="/blog/307513906/corgi_small.jpg" alt="corgi"></p><p>Чтобы играть в свободное время, купил себе <code>Nintendo Switch</code>, играл в основном в хиты от самой нинтендо, ну и ещё в пару игр. Больше всего зашли:</p><p><code>- Witcher 3</code><br>Люблю всю серию, во всех проявлениях, особенно приятно попробовать ещё раз на мобильной платформе в дороге.<br><code>- Legend of Zelda: Breath of the Wild</code><br>Интересная песочница, сильно погружает в простой сказочный мир<br><code>- Spiritfarer</code><br>Ферма с несколькими историями про прощание перед смертью, трогательная и в начале, но с запоротой концовкой.</p><p><strong><code>Развитие</code></strong></p><p>Этот год в основном прошёл в работе (причём, в работе с головой), больше в прокачке софт-скиллов.</p><p>Тем не менее, немного занимался более внимательным изучением новых стандартов C++ (11-17), минималистичного подхода в дизайне библиотек для C/C++ (<code>fmt</code>, <code>sokol</code>, <code>imgui</code>, <code>bgfx</code>, etc), а также паттерна <code>ECS</code>.</p><p>Раньше для любого пет-проджекта хотелось взять что-нибудь отличное от C++, из-за очарования battery-included философии Python и C# - проще было взять готовый монструозный пакет со всем сразу, и быстрее начинать писать код. Сейчас стало интереснее научиться решать задачу минимально необходимыми средствами, без виртуальных машин ради простого скрипта. Одно из неочевидных отличий в подходах заключается в том, что в первом случае для решения берётся первый попавшийся инструмент, с помощью которого точно знаешь, что сможешь решить задачу, а во-втором – пытаешься выбрать самый лучший подходящий для задачи инструмент среди всех доступных.</p><p>Также к концу года, за время отпуска, нашёл таки время практически закончить экспорт <code>блога</code> из <a href="https://spiiin.livejournal.com/" target="_blank" rel="noopener">ЖЖ</a> на <a href="https://spiiin.github.io/">гитхаб</a>. Долго выбирал <a href="/blog/47121/" title="статический генератор">статический генератор</a>, тему к нему, и изучал языки разметки и описания стилей. Быстро нашёл и пофиксил <a href="https://github.com/spiiin/stuff/tree/master/export_lj" target="_blank" rel="noopener">скрипт экспорта постов из жж</a> в формат markdown. Затем долго чистил совсем бессмысленные посты и экспортировал оставшиеся (часто, с ручными фиксами разметки). В конце думал, оставлять ли что-то в жж, или нет, и решал, что чем меньше там останется контента (как полезного, так и личного), тем лучше.</p><p><img src="/blog/307513906/fox.png" alt="fox"></p><p>За год повзрослел эмоционально, нашёл себя, и снова стал счастливым</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Никогда не подводил итогов года, но почему бы не начать в этом.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Райан Гордон</title>
    <link href="http://spiiin.github.io/blog/413676133/"/>
    <id>http://spiiin.github.io/blog/413676133/</id>
    <published>2021-01-13T21:09:08.000Z</published>
    <updated>2021-01-17T14:37:13.697Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/MeMPCSqQ-34" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><a href="https://en.wikipedia.org/wiki/Ryan_C._Gordon" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ryan_C._Gordon</a></p><p>Хакер, инди-разработчик, фрилансер.</p><p>Портирует “стафф” на линукс и макось. Среди “стаффа” - игры из серий:</p><ul><li>Unreal Tournament</li><li>Serious Sam</li><li>Civilization</li><li>Spider-Man</li><li>Quake</li><li>Left 4 Dead<br>и многие другие, а также приложения Second Life и Google Earth.<br>Проще перечислить, что он не портировал.</li></ul><p><a href="http://icculus.org/" target="_blank" rel="noopener">http://icculus.org/</a> - его сайт с open-source версиями нескольких из старых крупных проектов.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;style&gt;.embed
      
    
    </summary>
    
    
    
      <category term="люди" scheme="http://spiiin.github.io/tags/%D0%BB%D1%8E%D0%B4%D0%B8/"/>
    
  </entry>
  
  <entry>
    <title>ECS для казуальных игр</title>
    <link href="http://spiiin.github.io/blog/1488389622/"/>
    <id>http://spiiin.github.io/blog/1488389622/</id>
    <published>2021-01-07T20:11:49.000Z</published>
    <updated>2021-01-08T16:14:15.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Чем может быть полезно применение паттерна <strong><code>Entity Component System</code></strong> в казуальных играх.</p><p>TL,DR:</p><ul><li>Уменьшается связность между классами</li><li>DOD упрощает управление параметрами из нескольких мест</li><li>Упрощается написание читов</li><li>Возможно, игра будет работать быстрее</li></ul><a id="more"></a><h2 id="Уменьшается-связность-между-классами"><a href="#Уменьшается-связность-между-классами" class="headerlink" title="Уменьшается связность между классами"></a>Уменьшается связность между классами</h2><p>Это первое и самое важное, одного этого пункта хватило бы.</p><p>Геймдев не особо богат на архитектурные паттерны. Часто, высший уровень абстракции игровой логики (описание сцены и геймплея) - это классы <strong><code>&quot;поле&quot;</code></strong> (<em>уровень/сцена/зона/whatever</em>), и наследники <strong><code>&quot;игровых объектов&quot;</code></strong>. Часто встречаются ещё какие-нибудь <strong><code>&quot;фабрики эффектов&quot;</code></strong>, содержащиеся методы для запуска всего, чего только можно.</p><p>Первая освещаемая в <a href="/blog/381238762/" title="презентациях по ECS">презентациях по ECS</a>  проблема - это то, что игровых объектов очень много, разных типов, со взаимно-пересекающейся функциональностью.</p><p>К примеру, в <code>RTS</code> это могут быть юниты, герои, здания, ландшафт, снаряды. В <code>match-3</code> - множество отдельных типов клеток, фишек, существующих вне игровых клеток и между клетками механик, бустеры и бонусные фишки. В простом <code>скролл-шутере</code> – игрок, враги, стены и снаряды. В <a href="https://www.gamedevs.org/uploads/data-driven-game-object-system.pdf" target="_blank" rel="noopener">докладе о разработке Dungeon Siege</a> упоминается о &gt;7300 уникальных типов объектов. </p><p>Выстроить такое количество объектов в иерархию наследования практически невозможно, выделить несколько простых базовых классов, от которых наследуются все объекты – тоже. Возможное решение проблемы – выделять не базовые классы, а компоненты, из которых как из кирпичиков будут составлены объекты.</p><p>При таком подходе, судя по различным докладам, в зависимости от игры, может получиться 50-150 компонентов, которыми возможно описать все типы игровых объектов.</p><hr><p>Вторая проблема, более серьёзная с точки зрения архитектуры игры - <strong>куда писать код логики игры?</strong>.<br>Паттерн ECS обещает, что ответ будет чуть более простым, чем при использовании ООП - в системы, отвечающие за необходимый функционал.</p><p>Несколько примеров из одной match-3 игры, в которой используются компоненты для описания игровых фишек, но нет систем.</p><p>Реалзиция механика спецфишки “самолёт” (типа <a href="https://youtu.be/PqF3uKDgLsA?t=412" target="_blank" rel="noopener">такого</a>) в ней выглядит как показано ниже.</p><p>Самолёт запускается методом:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createAirplaneExplosion</span><span class="params">(airplaneBlock* plane, match3cell* parentCell, <span class="keyword">const</span> explosionSpineSettings&amp; settings)</span></span>;</span><br></pre></td></tr></table></figure></p><p>Сам самолёт состоит из компонентов:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">airplaneBlock</span> :</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithVisualFeedback, <span class="comment">//имеет анимацию</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithCombination,    <span class="comment">//может участвовать в комбинациях</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceDestructive,        <span class="comment">//может быть разрушен</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithObjective,      <span class="comment">//может быть целью уровня</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithDynamicLayer    <span class="comment">//может динамически менять слой</span></span><br><span class="line">    ...                                           <span class="comment">//и т.д.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//но так же имеет и методы, которые кто-то должен вызывать :(</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playDestroyAnimation</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Event*)&gt; callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHighestLayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restoreLayer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Соответственно, без использования ECS встаёт вопрос о том, куда дописывать код и где искать проблемы, когда они появляются.</p><p>Один из случаев в этом проекте:</p><p><strong>Иногда самолёты запускаются при старте игры</strong><br>В качестве бонуса игроку на старте. При этом другие бонусы от различных событий или покупок игрока расставляются по полю динамически. Программисту приходит баг от QA, что иногда поле от этого нестабильно (самолеты бьют в те клетки, куда не должны - логика самолётов подразумевает, что они умеют кружить по полю до того момента, пока одна из клеток не станет стабильной, т.е. в ней до момента удара гарантировано не будет происходить других событий). </p><p>Механика игры подразумевает, что можно заблокировать клетку от удара самолёта через метод <code>match3cell-&gt;lock</code>, но куда вставить его вызов?</p><ul><li>в коде <code>createAirplaneExplosion</code>?</li><li>в коде самого <code>airplaneBlock</code>? (тогда он будет знать о существовании всего поля и клеток на нём)</li><li>в коде событий, добавляющих на поле бустеры?</li><li>добавить компонент особой блокировки в класс клетку match3cell?</li><li>Программист, которому прилетел баг, пошёл ещё дальше, и добавил блокировку в код туториала на старте уровня %).</li></ul><p>В подходе с ECS, код, по идее, должен был бы выглядеть понятнее:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSystems</span><span class="params">(<span class="keyword">float</span> dt)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">createPreboosterAirplaneSystem(dt);  <span class="comment">//выставить компонент блокировки клеток поля на старте полёта самолётов</span></span><br><span class="line">createOtherPreboostersSystem(dt);  <span class="comment">//обновить логику всех бонусов игрока, отработки которых нужно дождаться</span></span><br><span class="line">normalGamePlayLogic(dt);         <span class="comment">//обычная геймплейная логика, </span></span><br><span class="line">         <span class="comment">//включает в себя обновление самолётов:</span></span><br><span class="line">         <span class="comment">//"если нет блокировки, ударить по клетке, иначе  - продолжать летать над полем"</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Т.е. на вопрос <strong><code>&quot;куда дописать логику блокировки клеток от удара самолётами-пребустерами&quot;</code></strong> следует очевидный ответ <strong><code>&quot;в систему создания блокировки от удара самолётами-пребустерами&quot;</code></strong>, вместо распутывания ада взаимных вызовов и колбеков между полем, клеткой, самолётом, суперклассом запуска всех событий или ещё какими-нибудь объектами, и медитации на тему, какой из объектов более отвечает за это.</p><p>Поиск по коду суперкласса запуска всех событий даёт 25 мест, в которых клетка может быть заблокирована или разблокирована обратно %). Гораздо лучше было бы иметь 4-5 систем, которые выбирают все сущности с компонентами блокировки и удаляют эти компоненты или создают их.</p><hr><p>Одна из фишек архитектуры ECS - возможность отследить связи между системами и компонентами - <a href="https://youtu.be/W3aieHjyNvw?t=324" target="_blank" rel="noopener">пример в докладе Тимоти Форда по Overwatch</a>. Я попробовал перевести на ECS (с использованием библиотеки EnTT) готовую игру - сделанный за день для хакатона <a href="https://apps.apple.com/ru/app/comatosis/id1537791573#?platform=ipad" target="_blank" rel="noopener">небольшой shoot-them-up</a> на закрытом движке, использующем Component Systems. Заменил часть, отвечающую за апдейт на системы, и оставил без изменений систему рендера (она использует Scene Graph).</p><p>На мой взгляд, небольшие игры с хакатонов хорошо подходят для подобных тестов - бардак в коде, вызванный нехваткой времени сделать “как правильно”, реалистично симулирует состояние кода игры после длительного периода разработки, а небольшой объём кода позволяет довести задуманное до конца.</p><p>Для визуализации связей сделал такой скрипт на питоне:<br><a href="https://gist.github.com/spiiin/c70c3bf0711fd952d48e505ead7bffe5" target="_blank" rel="noopener">https://gist.github.com/spiiin/c70c3bf0711fd952d48e505ead7bffe5</a><br><img src="/blog/1488389622/diagram1.png" alt="ecs-doc"></p><p>Кашу из зависимостей между игровыми классами удалось превратить в 24 системы и 30 компонентов. При этом большинство систем использует 2-4 компонента, большинство компонентов используется 1-2-3 системами. Большая часть систем может быть без особых усилий переделана на <code>реактивные</code> (чтобы вызывать их не каждый кадр, а по колбекам на изменение каких-либо компонент на любой из сущностей) или на <code>владеющие компонентами</code> (для оптимизации по скорости обходов, <a href="https://skypjack.github.io/2019-04-12-entt-tips-and-tricks-part-1/" target="_blank" rel="noopener">статья с объяснением</a>).</p><p>Компоненты по способы использования разделяются на <code>логические</code> (для композиции из них сущностей - в основном, игровых объектов), <code>события</code> (для передачи информации между системами и выделения сущностей, с которыми произошло действие), <code>синглтоны</code> (существующие в единственном экземпляре для всего пула сущностей), и <code>прокси-компоненты</code> (для передачи данных в подсистемы движка/игры, написанные без ecs, и получения данных из этих подсистем).</p><h2 id="DOD-упрощает-управление-параметрами-из-нескольких-мест"><a href="#DOD-упрощает-управление-параметрами-из-нескольких-мест" class="headerlink" title="DOD упрощает управление параметрами из нескольких мест"></a>DOD упрощает управление параметрами из нескольких мест</h2><p>Простейший пример -<strong> <code>возможность удаления игрового объекта из нескольких разных мест</code></strong>.<br>Игровой снаряд может быть уничтожен через 5 секунд по окончании времени жизни, либо при столкновениях во стеной или врагом, то удаление в ООП парадигме может выглядеть так:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bullet = createBullet();</span><br><span class="line"><span class="keyword">auto</span> waitAction = createWaitAction(<span class="number">5.0f</span>); <span class="comment">//создаём объект действия ожидания</span></span><br><span class="line"><span class="comment">//в конце действия уничтожаем объект</span></span><br><span class="line">waitAction.onEnd = [bullet]() &#123;</span><br><span class="line">    <span class="comment">//тут не забыть проверить, что за 5 секунд объект может быть уничтожен кем-либо ещё</span></span><br><span class="line">    bullet-&gt;destroySelf();</span><br><span class="line">&#125;;</span><br><span class="line">bullet-&gt;addAction(waitAction); <span class="comment">//добавляем действие на объект пули</span></span><br></pre></td></tr></table></figure><p>Как проверить, что пуля не была уничтожена?<br>Один из способ из стандартной библиотеки с++ – использование слабого указателя на объект. Такие проверки необходимо добавлять в каждое асинхронное действие.</p><p>Другой подход - перепроверять, жив ли объект в текущий момент, через глобальный менеджер объектов. Более детально про организацию этого в игровых движках - <a href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html" target="_blank" rel="noopener">статья Andre Weissflog</a>. В этом случае хендлер объекта часто представлен в виде пары <strong><code>(индекс объекта в массиве, номер поколения)</code></strong>. Использование номера поколения позволяет избежать случайного обращения к уже удалённому объекту при размещении на месте удалённого объекта следующего созданного.</p><p>Если решать проблему с использованием ECS-подхода, решение может быть таким: система обновления жизни пули (и других объектов с компонентом <code>lifetimeComponent</code>) читает компонент таймера жизни и уменьшают его. В случае если таймер дошёл до нуля - система просто добавляет на сущность компонент-событие <code>removeNodeComponent</code> - маркер, что в конце кадра сущность должна быть уничтожена.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLifetimeSystem</span><span class="params">(<span class="keyword">float</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//read components </span></span><br><span class="line">    <span class="comment">// &lt;------------------------------------------------(0)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lifetimeView = ECS().view&lt;nodeComponent, lifetimeComponent&gt;(entt::exclude&lt;removeNodeComponent&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//logic</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [entity, nodeComponent, lifetimeComp] : lifetimeView.each()) &#123;</span><br><span class="line">        lifetimeComp.lifetime -= delta;</span><br><span class="line">        <span class="keyword">if</span> (lifetimeComp.lifetime &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> action = MEActionFactory::changeAlphaAction(<span class="number">0.0f</span>, lifetimeComp.fadeinTime);</span><br><span class="line">            action-&gt;onEnd = [entity=entity](MENode* node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ECS().valid(entity)) &#123;  <span class="comment">//&lt;-------  (1)</span></span><br><span class="line">                    ECS().emplace_or_replace&lt;removeNodeComponent&gt;(entity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (!nodeComponent.dead) &#123;      <span class="comment">//&lt;-------- (2)</span></span><br><span class="line">                nodeComponent.node-&gt;addAction(action);</span><br><span class="line">                ECS().<span class="built_in">remove</span>&lt;lifetimeComponent&gt;(entity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(0) - выборка всех сущностей, у которых есть компоненты <code>nodeComponent</code> (визуальное отображение), <code>lifetimeComponent</code> (время жизни), но нет компонента <code>removeNodeComponent</code> (умирает)<br>(1) - так как используется отложенное действие - нужно проверить, что сущность ещё жива и не была уничтожена (проверка через менеджер) - <code>ECS().valid</code><br>(2) - компонент для хранения не владеющего указателя, имеет кроме указателя флаг <code>nodeComponent.dead</code> , показывающий не был ли уничтожен объект, вместо использования weak_ptr/intrusive_ptr. Вместо флага может быть использован счётчик, если нужно shared-владение.</p><hr><p>Другой пример - есть стратегия с игровым полем с персонажами на нём, и по желаниям гейм-дизайнеров, персонажи на этом поле должны плавно исчезать при открытии окна режима редактирования зданий или появления немодального игрового окна (и соответственно, плавно появляться обратно при закрытии этих режимов). Появление персонажей не мгновенно, и игроки могут успеть за это время запустить исчезновение обратно. <strong><code>Как добиться того, чтобы появление/исчезновение персонажей работало корректно в этом случае?</code></strong></p><p>В <code>ООП-подходе</code> каждое из действие появления напрямую должно попытаться влезть в другие действия, навешенные на персонажа, и узнать, нет ли на нём действий исчезновения и как-то обработать ситуацию, если персонажи одновременно появляются и исчезают.</p><p>С <code>ECS-подходом</code> - можно выделить два различных компонента исчезновения и появления персонажа, и различные системы для работы с ними. Одной из идиом работы совместной работы таких систем является непосредственное применение сайд-эффектов в одном месте (сайд-эффект в этом случае - это непосредственное изменение альфа-компонента цвета для рендер-системы). <a href="https://youtu.be/W3aieHjyNvw?t=1062" target="_blank" rel="noopener">Объяснение причин в докладе по Overwatch</a> - если системы A, B, C как-либо меняют логическое состояние компонента, то лучше собрать их действие в отдельном компоненте для системы D, которые непосредственно применит все собранные изменения в одном месте.</p><p>Так формула рассчёта альфа компонента персонажа будет находиться в одном месте и её можно будет изменить по желанию гейм-дизайнеров. Например, можно будет настроить поведение в таком случае одновременного появления и исчезновения персонажа - выстроить ли эти действия в цепочку, мгновенно завершить действие, которое было начато раньше, или же настроить таймеры действия так, чтобы они доигрались быстрее.</p><h2 id="Упрощается-написание-читов"><a href="#Упрощается-написание-читов" class="headerlink" title="Упрощается написание читов"></a>Упрощается написание читов</h2><p>Не секрет, что при разработке игр редко заморачиваются с покрытием кода тестами, поэтому часто читы - это средство создания сложных сценариев проверки игры, так что они становятся настолько важными, насколько важно вообще провести QA-проверку игры.</p><p>ECS подход должен помочь:</p><p><strong><code>- Легко включать и отключать каждую отдельную систему через читы</code></strong><br>Лучше даже, группу систем, отвечающую за определённую логику.</p><p>Отключение системы может само по себе быть удобным готовым читом, который при ООП подходе необходимо создавать дополнительно к основной логике (отключение системы получения урона, отключение системы коллизий, отключение ИИ).</p><p>При проектировании объектов редко задумываются о том, чтобы частично отключать функционал класса. С системами, вызов которых сгруппирован в одном месте, это может быть сильно проще.</p><p><strong><code>- Проще сделать загрузку/сохранение сцены, проигрывание повторов</code></strong><br>Сохранение - это просто сериализация всех сущностей со всеми компонентами. Если после этого запустить все системы - логика игры должна начать работать также, как если бы состояние сущностей/компонент было получено любым другим образом.</p><p><strong><code>- Проще составить сценарии тестирования</code></strong><br>Включение/отключение систем может быть сериализовано или включено в запись повтора, результаты работы после нескольких циклов могут быть сериализованы и сверены с эталонным результатом.</p><h2 id="Возможно-игра-будет-работать-быстрее"><a href="#Возможно-игра-будет-работать-быстрее" class="headerlink" title="Возможно, игра будет работать быстрее"></a>Возможно, игра будет работать быстрее</h2><p>(не проверял, пересказ чужих докладов)</p><p><strong><code>- Проще запустить системы, несвязанные с другими, в отдельном потоке</code></strong><br>Если отслеживать граф зависимостей компонентов, с которыми работают системы, то можно найти системы, которые могут работать параллельно с другими. С обычным ООП подходом сложно перенести часть логики в отдельный поток.</p><p><strong><code>- Прирост скорости за счёт более быстрого обхода и чтения из кеша</code></strong><br>Компоненты хранятся в памяти отдельными массивами, однако можно добиться того, чтобы ECS хранила контейнер для каждой группы сущностей с определённой группой компонент в памяти последовательно.</p><p>Для ECS на архетипах это делается по умолчанию (при создании или удалении компонента для сущности, они будет перенесена в другой контейнер).</p><p>Для ECS на разреженных множествах также существуют способы организовать хранение сущностей с одинаковыми компонентами в памяти последовательно. Для EnTT - это группы (<code>group</code>) - <a href="https://github.com/abeimler/ecs_benchmark" target="_blank" rel="noopener">синтетические бенчмарки</a> показывают, что это наиболее быстрый способ работы.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Чем может быть полезно применение паттерна &lt;strong&gt;&lt;code&gt;Entity Component System&lt;/code&gt;&lt;/strong&gt; в казуальных играх.&lt;/p&gt;
&lt;p&gt;TL,DR:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Уменьшается связность между классами&lt;/li&gt;
&lt;li&gt;DOD упрощает управление параметрами из нескольких мест&lt;/li&gt;
&lt;li&gt;Упрощается написание читов&lt;/li&gt;
&lt;li&gt;Возможно, игра будет работать быстрее&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>ECS. Ссылки</title>
    <link href="http://spiiin.github.io/blog/381238762/"/>
    <id>http://spiiin.github.io/blog/381238762/</id>
    <published>2021-01-04T22:09:45.000Z</published>
    <updated>2021-02-24T21:45:54.772Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>ECS - паттерн программирования, используемый в геймдеве. Основная идея - есть пул сущностей (<code>entities</code>), на которые можно добавлять компоненты (данные без логики - <code>components</code>). Сущности и компоненты читаются, модифицируются, создаются и удаляются только с помощью систем(<code>systems</code>). Подход немного отличен от традционного ООП, и от ECs (сущности разбиваются на  компоненты - логика хранится как в классах-сущностях, так и в компонентах), так что требует ознакомления и практики перед использованием<br><a id="more"></a></p><h2 id="История-и-примеры-практического-применения-в-больших-играх"><a href="#История-и-примеры-практического-применения-в-больших-играх" class="headerlink" title="История и примеры практического применения в больших играх"></a>История и примеры практического применения в больших играх</h2><p><code>Dungeon Siege</code> - <a href="https://www.gamedevs.org/uploads/data-driven-game-object-system.pdf" target="_blank" rel="noopener">A Data-Driven Game Object System</a><br><code>Operation Flashpoint 2</code><br><code>GrexEngine</code> (движок для mmo-rpg) - <a href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/" target="_blank" rel="noopener">Cерия статей</a>, и ссылка ещё на одну презу из dungeon siege<br><code>World of Tanks Blitz</code> - <a href="https://habr.com/ru/company/wargaming/blog/245321/" target="_blank" rel="noopener">Создание World of Tanks Blitz на базе собственного движка DAVA</a><br><code>Wooga</code> (немецкая студия, разрабатывает казуалки) - для матч-3 и стратегии. Ссылки на видео в следующем разделе.<br><code>Overwatch</code> - Ссылка на видео в следующем разделе (в комментариях к ютуб лекции ещё несколько разработчиков игр отписывались, например <code>Mercenaries 2</code>)<br><code>Minecraft</code> - Использует библиотеку <a href="https://minecraft.net/en-us/attribution/" target="_blank" rel="noopener">entt</a>.</p><h2 id="Видео-презентации"><a href="#Видео-презентации" class="headerlink" title="Видео презентации"></a>Видео презентации</h2><p><code>Entitas - Entity System Architecture with Unity - Unite Europe 2015.</code><br>Доклад от Макса Закса и Саймона Шмидта о библиотеке Entitas для Unity - идеи, и как совмещать объектами Unity.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/1wvMXur19M4" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Unite Europe 2016 - ECS architecture with Unity by example</code><br>От них же, практическое применение библиотеки Entitas для решения конкретной задачи, создания интерфейса в стиле Clash Royale.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/lNTaC-JWmdI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Кирилл Надеждин (Kumo Kairo) - ECS в разработке игр — хорошая архитектура приложений для всех</code><br>Обзор entitas и ссылки на другие примеры использования ECS в играх, на русском. Примеры проблем, которые приводят к тому, чтобы перейти на ECS.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/pp5sYybOidg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Wargaming.net: Архитектура современных 3D движков (DevGAMM Minsk 2014)</code><br>Архитектура современных 3D движков, Виталий Бородовский, Technical Director WoT Blitz<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/1zLqgQ_-F84" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Overwatch Gameplay Architecture and Netcode</code><br>Разбирается внутренняя ECS близзрад. Cамая объёмная и сложная для понимания презентация, тут на 0.75 лучше смотреть. Почему пришли к применению ECS, с какими проблемами сталкивались и как их решали. Обзор после 3х лет использования такой архитектуры на практике.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/W3aieHjyNvw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>itCppCon19 - ECS back and forth (Michele Caini)</code><br>Обзор внутреннего устройства ECS на C++ - разбор двух типов архитектур - на основе “архетипов” и “разреженных множеств”. Можно также почитать в ECS-FAQ (ссылка в следующем разделе)<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/WB5bRKKGRUk" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><h2 id="Обзоры-библиотек"><a href="#Обзоры-библиотек" class="headerlink" title="Обзоры библиотек"></a>Обзоры библиотек</h2><p><a href="https://github.com/SanderMertens/ecs-faq" target="_blank" rel="noopener">Entity Component System FAQ</a> - общий обзор подхода, терминология, список библиотек, примеры применения в продакшене.<br><a href="https://github.com/abeimler/ecs_benchmark" target="_blank" rel="noopener">Entity-Component-Systems Benchmark</a> - бенчмарк различных библиотек<br><a href="https://github.com/skypjack/entt" target="_blank" rel="noopener">EnTT</a> - production-ready c++ библиотека, с примерами использования (самый простой - <a href="https://github.com/Kerndog73/EnTT-Pacman" target="_blank" rel="noopener">pacman</a>, <a href="https://github.com/skypjack/entt/wiki/EnTT-in-Action" target="_blank" rel="noopener">документацией</a> и <a href="https://skypjack.github.io/tags/#entt" target="_blank" rel="noopener">блогом</a><br><a href="https://github.com/SanderMertens/flecs" target="_blank" rel="noopener">flecs</a> - c/c++ библиотека с большим количеством <a href="https://github.com/SanderMertens/flecs/tree/master/examples" target="_blank" rel="noopener">примеров</a> и функционала (есть модули для сериализации, рефлексии, продвинутое api для обращения с сущностями). <a href="https://github.com/SanderMertens/flecs/blob/master/docs/Manual.md" target="_blank" rel="noopener">Мануал</a><br><a href="https://github.com/sschmid/Entitas-CSharp" target="_blank" rel="noopener">Entitas</a> - библиотека на C# для использования с Unity (порты на другие языки можно не смотреть. Возможно, стоит смотреть сразу штатный ECS для Unity - Unity DOTS.</p><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p><a href="https://gamedev.ru/code/forum/?id=198194&amp;m=3785006#m8" target="_blank" rel="noopener">Обсуждение на gamedev.ru</a> - пост с большой коллекцией ссылок<br><a href="http://entity-systems.wikidot.com/" target="_blank" rel="noopener">Entity Systems Wiki</a> - вики с терминологией, ссылками, список библиотек для разных языков.<br><a href="http://gamadu.com/artemis/" target="_blank" rel="noopener">Artemis</a> - академическая реализация ECS на Java, посмотреть как задумано.</p><h2 id="Data-oriented-Design-DoD"><a href="#Data-oriented-Design-DoD" class="headerlink" title="Data-oriented Design (DoD)"></a>Data-oriented Design (DoD)</h2><p>Теория, если сходу не очень понятны идеи ECS.<br><a href="https://www.dataorienteddesign.com/dodbook/" target="_blank" rel="noopener">Data-Oriented Design</a> - фундаментальная книжка по DoD от Richard Fabian<br><a href="https://github.com/dbartolini/data-oriented-design" target="_blank" rel="noopener">Data Oriented Design Resources</a> - список материалов по DOD<br><a href="https://habr.com/ru/post/472052/" target="_blank" rel="noopener">Data-Oriented Design (или почему, используя ООП, вы, возможно, стреляете себе в ногу)</a> - перевод статьи Noel Llopis<br><a href="https://asawicki.info/news_1422_data-oriented_design_-_links_and_thoughts.html" target="_blank" rel="noopener">Data-Oriented Design - Links and Thoughts</a> - коллекция ссылок на статьи, многие gamedev-related.<br><a href="https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/introduction-to-data-oriented-design.pdf" target="_blank" rel="noopener">DOD в Battlefield</a> - исследование прироста скорости от правильного расположения структур в памяти, полезные ссылки в конце доклада<br><a href="https://www.youtube.com/watch?v=yy8jQgmhbAU" target="_blank" rel="noopener">Stoyan Nikolov “OOP Is Dead, Long Live Data-oriented Design”</a> - видео доклада Стояна Николова с примером разницы подходов к решению практической задачи - OOP vs DoD.</p><p>Примеры проектов, используещие подход:<br><a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">Dear ImGui</a><br><a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">bgfx</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECS - паттерн программирования, используемый в геймдеве. Основная идея - есть пул сущностей (&lt;code&gt;entities&lt;/code&gt;), на которые можно добавлять компоненты (данные без логики - &lt;code&gt;components&lt;/code&gt;). Сущности и компоненты читаются, модифицируются, создаются и удаляются только с помощью систем(&lt;code&gt;systems&lt;/code&gt;). Подход немного отличен от традционного ООП, и от ECs (сущности разбиваются на  компоненты - логика хранится как в классах-сущностях, так и в компонентах), так что требует ознакомления и практики перед использованием&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://spiiin.github.io/tags/c/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="c#" scheme="http://spiiin.github.io/tags/c/"/>
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Middle</title>
    <link href="http://spiiin.github.io/blog/15798/"/>
    <id>http://spiiin.github.io/blog/15798/</id>
    <published>2020-08-12T08:58:00.000Z</published>
    <updated>2021-01-02T22:01:36.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Часто встречающиеся у программистов-новичков ошибки и часто встречающие у опытных программистов ошибки. С позиции “среднего” разработчика.<br><a id="more"></a></p><p>…</p><hr><h2 id="Ошибки-новичков"><a href="#Ошибки-новичков" class="headerlink" title="Ошибки новичков"></a>Ошибки новичков</h2><p><code>1. Использование примитивов вместо высокоуровневых абстракций</code></p><p>Новички часто пишут код “с нуля”, забывая о возможностях используемых фреймворков или библиотек. Фактически это просто неумение работать со сложными типами и игнорирование возможностей системы типов используемого языка (точнее даже - возможностей выражать через типы ограничения и связи сущностей).</p><blockquote><p>Каждый раз, когда необходимо завести переменную типа <code>int</code> - подумайте, действительно ли нужен просто целочисленный тип, или же с помощью типа можно сказать ещё что-то полезное о переменной</p></blockquote><p><code>2. Реализация всей логики в одной функции</code></p><p>Если какой-то кусок кода можно вынести в именованную функцию (даже если она не будет использоваться повторно), стоит так сделать. Функции проще объединять в классы или модули, чем “голый” код и разрастающиеся безымянные функции. Это нужно, чтобы уменьшить вероятность копи-пасты кода (точнее даже, уменьшения количества необходимых для изменения логики мест в коде).</p><blockquote><p>Можно ли описать одним небольшим предложением, что делает функция? Что делает класс? Что описано в файле/namespace/модуле?</p></blockquote><p><code>3. Игнорирование инкапсуляции</code></p><p>Инкапсуляция часто ошибочно трактуется новичками как необходимость делать все данные класса закрытыми. На практике лучше понимать и использовать её как средство сделать объект не ломаемым пользователем. Т.е. если изменение переменных не может привести к тому, что класс будет находиться в невалидном состоянии - то и не надо их прятать. Если же для корректной работы с объектом у него нужно вызвать 5 разных методов в строго определенном порядке (а в других случаях программа падает), значит, нет у него никакой инкапсуляции. Пользователь объекта не должен помнить о том, что нельзя делать с объектов, чтобы не сломать его внутреннюю логику - сам объект должен быть не ломаемым для пользователя.</p><blockquote><p>Таким образом в некоторых языках отказываются “ломающихся” абстракций и возможностей (<code>goto</code>, отказ от указателей, отказ от ручного освобождения памяти, отказ от мутабельности).</p></blockquote><p><code>4. Персональный стиль</code></p><p>По большей части, все программы пишутся несколькими людьми, так что вместо того, что писать в строго выработанном правильном стиле, стоит учиться подстраиваться под стиль уже написанного кода. Код на некоторых языках имеет стандартные правила написания, но даже с учётом этого необходимо помнить, что программа могла писаться, когда в ходу были другие правила, или же по каким-либо другим причинам использовать другой подход. Стоит писать так, чтобы стиль всей программы был одинаковый - так у читающего код будет меньше вопросов, почему в разных местах программы используются разные варианты (и какой стиль выбрать при изменении кода).</p><blockquote><p>Прежде чем писать код, прочитайте уже написанный</p></blockquote><p><code>5. Неправильные вопросы опытным программистам</code></p><p><em>“Какой язык учить?”</em> - неверно, опытные скорее могут рассказать, что уже учить не стоит. Новые знания можно копать самим, в больших количествах.<br><em>“Как быстро получить прибавку к зарплате”</em> - неверно. Самый быстрый способ прокачки - менять работу каждые полгода-год, с повышением рангов. Но с определенного уровня начинают ценить лояльность, прыгающий между проектами профессионал стоит только того, чтобы выжать из него максимум и отпустить дальше. В компаниях с грамотным управлениям вашу работу и так отметят (если отметка соответствует ожиданиям - всё отлично, если нет - лучше уточнять, что не так). К счастью, обычно с определённого уровня программистам достаточно денег для того, чтобы хватало на жизнь (дойти до этого уровня можно за год-два-три - как повезёт).</p><p>Стоит максимально вникать в предметную область, опасно зависать на несколько лет в очень узкой нише.</p><blockquote><p>Полезно раз в месяц-два изучать как минимум одну статью профессиональной тематики, раз в полгода-год читать книгу, раз в 2-3 месяца изучать библиотеки/фреймворки/движки, похожие на те, что используются в работе.</p></blockquote><h2 id="Ошибки-опытных"><a href="#Ошибки-опытных" class="headerlink" title="Ошибки опытных"></a>Ошибки опытных</h2><p><code>1. Нежелание трогать плохой код</code></p><p>“Это надо разбираться с половиной программы” - нормальная с точки зрения опытного программиста отмазка, чтобы не выполнять рефакторинг кода. В запущенных случаях это даже перерастает в нежелание трогать свой плохой код.</p><blockquote><p>Иногда таки надо разобраться с половиной программы, чтобы сделать код лучше. На костылях далеко не уёдешь, рано или поздно предстоит выбросить их и сделать нормальные колёса.</p></blockquote><p><code>2. Нежелание отказываться от своих подходов</code></p><p>Иногда (редко но бывает), нужно сделать свой код хуже, чтобы он вписывался в проект. Иногда нужно выучить новую парадигму - очень сильно неприятно, когда ты 15-20 лет писал код и решал проблемы в одном стиле, а теперь их в проекте решают по другому, так как ты ещё не умеешь. Иногда нужно выучить новый язык, когда уже очень хорошо знаешь старый.</p><p>Грустно, но во многих компаниях уровни роста программиста - это скорее стаж, чем реальный опыт, а с учётом того, что в IT практически никогда не понижают при переходе между компаниями, оказывается также, что умение писать хороший код приходит (если вообще приходит)  где-то на уровне “senior+”.</p><blockquote><p>Время движется вперёд, и любые идеи могут устареть, даже те, которые ты считаешь основополагающими. Нужно не забывать их переоценивать</p></blockquote><p><code>3. Игнорирование soft-skills</code></p><p>Рано или поздно в ходе роста программиста необходимо научиться нормально взаимодействовать с командой. На начальных этапах всё взаимодействие - это передача по конвейеру: получение задач от лидов/тм, передача выполненного к QA. </p><p>Но на более поздних необходимо взаимодействие со всеми вокруг - уточнение формулировки задач (и умение исправить или даже переделать постановку исходной задачи), корректировки сроков. Ещё позднее - формирование команды и умение улаживать конфликты в команде. Даже если ты собираешься расти в “техническую”, а не “управленческую” сторону, всё равно не избежать растущего количества взаимодействия, а умение взаимодействовать тоже нужно прокачивать.</p><p>В некоторых компаниях отрицательный отзыв по софт-скиллам блокирует твой карьерный рост.</p><blockquote><p>В любой сфере достаточно людей, которые умеют программировать, но не хватает тех, которые умеют программировать, и при этом разбираются в предметной области.</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Часто встречающиеся у программистов-новичков ошибки и часто встречающие у опытных программистов ошибки. С позиции “среднего” разработчика.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Карта прохождения игр</title>
    <link href="http://spiiin.github.io/blog/1563/"/>
    <id>http://spiiin.github.io/blog/1563/</id>
    <published>2020-08-04T19:11:37.000Z</published>
    <updated>2020-09-01T18:10:28.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Список игр на прохождение<br><a id="more"></a></p><h2 id="Current-list"><a href="#Current-list" class="headerlink" title="Current list"></a>Current list</h2><p><code>Captain Toad</code> - 90%<br><code>Age of Mythologies</code> - 50%<br><code>Gta 5</code> - 30%<br><code>The Witcher 2</code> - 5%</p><h2 id="Coop"><a href="#Coop" class="headerlink" title="Coop"></a>Coop</h2><p><code>The Stratchers</code> - 33%<br><code>Trine 4</code> - 30%<br><code>Minecraft</code> - 5%</p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><p><code>Yoshi&#39;s Crafted World</code><br><code>The Forest</code></p><h2 id="Completed"><a href="#Completed" class="headerlink" title="Completed"></a>Completed</h2><p><code>Mario+Rabbids</code><br><code>Witcher</code><br><code>Legend of Zelda: BotW</code><br><code>Warhammer 40k: Mechanicus</code></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Список игр на прохождение&lt;br&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>Привет, Hexo</title>
    <link href="http://spiiin.github.io/blog/47121/"/>
    <id>http://spiiin.github.io/blog/47121/</id>
    <published>2020-07-18T14:14:53.000Z</published>
    <updated>2020-09-15T15:24:43.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>После нескольких дней возни в очередной попытке собрать на <code>jekyll</code> статический блог, решил забить на него и попробовать использовать для блога <a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>. Получилось сильно проще и приятнее.</p><p>Во-первых, <code>hexo</code> запускается легче, и темы работают сходу. И, что удобно для блога программисту, подсветка синтаксиса кода интегрирована в движок лучше, из чего следует, что темы скорее всего будут совместимы с ней (у <code>jekyll</code> подобрать работающую пару “тема+плагин подсветки синтаксиса” оказалось очень непросто, то съезжала нумерация длинных строк, то весь блок с кодом выглядел коряво, то были проблемы с корректным отображения цвета строк или фона)</p><a id="more"></a><p>Единственное, для корректной работы тем, иногда опытным путём, необходимо выяснить, какие плагины необходимо доустановить из <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">списка</a>.</p><h2 id="Темы"><a href="#Темы" class="headerlink" title="Темы"></a>Темы</h2><p>Далее, выбор <a href="https://hexo.io/themes/" target="_blank" rel="noopener">тем</a>. Достаточно много качественных и приятных глазу, из тёмных и минималистичных интересными показались:</p><ul><li><a href="https://github.com/howardliu-cn/hexo-theme-clean-dark" target="_blank" rel="noopener">clean-dark</a><ul><li><a href="https://www.howardliu.cn/" target="_blank" rel="noopener">Пример</a></li><li>Оригинальная <a href="http://pavelmakhov.com/jekyll-clean-dark" target="_blank" rel="noopener">тема для jekyll</a>, которая была взята в качестве основы для этой темы</li></ul></li><li><a href="https://github.com/maochunguang/black-blue" target="_blank" rel="noopener">black-blue</a><ul><li><a href="http://maochunguang.github.io/" target="_blank" rel="noopener">Пример</a></li></ul></li><li><a href="https://github.com/tzvetkov75/solar-theme-hexo/" target="_blank" rel="noopener">solar</a><ul><li><a href="https://tzvetkov75.github.io/demo_blog/public/" target="_blank" rel="noopener">Пример</a>.</li><li>Тема на основе <a href="https://probberechts.github.io/hexo-theme-cactus/cactus-dark/public/" target="_blank" rel="noopener">cactus</a></li></ul></li><li><a href="https://github.com/lyndonoc/hexo-theme-pandollo" target="_blank" rel="noopener">pandollo</a><ul><li><a href="https://lyndonoc.github.io/" target="_blank" rel="noopener">Пример</a></li></ul></li></ul><h2 id="Настройка-темы"><a href="#Настройка-темы" class="headerlink" title="Настройка темы"></a>Настройка темы</h2><p>Минимальная настройка темы включает правку файла <code>config.yml</code>, какие именно настройки поддерживаются, обычно написано на сайте темы.</p><p>Дополнительно, на примере темы <code>pandolo</code> - можно донастроить стиль, разобравшись с правкой файлов в папке <code>themes/pandollo/source/scss</code>.</p><p>Дальше нужно выполнить команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sass --style&#x3D;compressed .&#x2F;main.scss ..&#x2F;css&#x2F;main.css</span><br></pre></td></tr></table></figure></p><p>Для того, чтобы сгенерировать упакованную версию файла стилей, которую будет использовать блог.</p><p>После небольших правок получилась примерно такая “лисья” тема:<br><img src="/blog/47121/hexo-fox.png" alt="hexo-fox"></p><h2 id="Настройка-плагинов"><a href="#Настройка-плагинов" class="headerlink" title="Настройка плагинов"></a>Настройка плагинов</h2><p>Для выбранной темы пригодятся следующие плагины:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  ...</span><br><span class="line">  "hexo-asset-link": "^2.0.1",</span><br><span class="line">  "hexo-generator-fragments": "^1.0.0",</span><br><span class="line">  "hexo-renderer-kramed": "^0.1.4",</span><br><span class="line">  "hexo-renderer-jade": "^0.5.0",</span><br><span class="line">  "hexo-abbrlink": "^2.2.1",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/liolok/hexo-asset-link" target="_blank" rel="noopener">hexo-asset-link</a> - позволяет использовать в постах ссылку на ассет в виде относительного пути: <code>POST_NAME/asset_name.png</code> (также нужно включить в <code>config.yml</code> опцию: <code>post_asset_folder: true</code>, чтобы hexo создавал отдельную папку для ассетов к каждому посту).</p><p><a href="https://github.com/mamboer/hexo-generator-fragments" target="_blank" rel="noopener">hexo-generator-fragments</a> - необходим для темы - генерирует preview для постов для главной страницы, позволяет использоватьв в постах тег <code>&lt;!-- more --&gt;</code> чтобы отмечать краткую короткую preview-версию поста.</p><p><a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> - плагины, содержащие в названии renderer, позволяют hexo генерировать посты из разных форматов файла. Данный плагин используется для рендера из файлов <code>*.md</code> в формате <code>github flavored markdown</code>, который используется на серверах <code>github</code>.<br>В комплекте с <code>hexo</code> уже идёт плагин, который рендерит markdown-файлы, поэтому чтобы использовать альтернативный, предварительно нужно его удалить:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/hexojs/hexo-renderer-jade" target="_blank" rel="noopener">hexo-renderer-jade</a> - необходимый для темы плагин, позволяющий рендерить pug-файлы (собственно, сама тема описана в этом формате).</p><p><a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> - генерирует для каждого поста идентификатор. Для генерации имён постов необходимо в <code>config.yml</code> добавить строку:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br></pre></td></tr></table></figure><br>Для того, чтобы указать ссылку на пост, нужно использовать тег:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Написание-постов"><a href="#Написание-постов" class="headerlink" title="Написание постов"></a>Написание постов</h2><p>После установки и настройки темы можно попробовать добавить пост:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post hello-hexo.md</span><br></pre></td></tr></table></figure><br>Вместо md можно попробовать использовать другие форматы, для которых установлены render-плагины. В качестве редактора постов я бы посоветовал использовать (Visual Studio Code)[<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a>], вместе с плагином <a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/" target="_blank" rel="noopener">Markdown Enchanced Preview</a>.</p><p>Чтобы проверить, как выглядит пост, нужно запустить команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure><br>и открыть в браузере страницу <code>http://127.0.0.1:4000/</code> (hexo отслеживает изменения исходников и сразу обновляет открытую страницу).</p><p>Сгенерировать статический сайт можно так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p><p>Весь сгенерированный сайт будет содержаться в папке <code>public</code>, её можно заливать на хостинг руками или воспользоваться плагинами для автоматизации этих процессов.</p><h2 id="Итог"><a href="#Итог" class="headerlink" title="Итог"></a>Итог</h2><p>В кажущейся простой задаче “отрендерить markdown-статью в html”, cкрыт выбор целого стека способов решения (генераторы сайтов со своими языками, рендеры разных форматов и диалектов разметки, языки описания стилей и шаблонов сайта, темы, плагины, подсветка кода, системы развёртывания сайта).</p><p>В <code>hexo</code> эти вещи более-менее целостно сшиты вместе в единую систему, которой можно начать пользоваться достаточно быстро.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;После нескольких дней возни в очередной попытке собрать на &lt;code&gt;jekyll&lt;/code&gt; статический блог, решил забить на него и попробовать использовать для блога &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;. Получилось сильно проще и приятнее.&lt;/p&gt;
&lt;p&gt;Во-первых, &lt;code&gt;hexo&lt;/code&gt; запускается легче, и темы работают сходу. И, что удобно для блога программисту, подсветка синтаксиса кода интегрирована в движок лучше, из чего следует, что темы скорее всего будут совместимы с ней (у &lt;code&gt;jekyll&lt;/code&gt; подобрать работающую пару “тема+плагин подсветки синтаксиса” оказалось очень непросто, то съезжала нумерация длинных строк, то весь блок с кодом выглядел коряво, то были проблемы с корректным отображения цвета строк или фона)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://spiiin.github.io/blog/16107/"/>
    <id>http://spiiin.github.io/blog/16107/</id>
    <published>2020-07-01T12:45:28.000Z</published>
    <updated>2021-03-14T21:31:41.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><strong>Hello, world!</strong><br>Немного тестов разметки<br><a id="more"></a></p><hr><p>Заголовки</p><h1 id="Заголовок1"><a href="#Заголовок1" class="headerlink" title="Заголовок1"></a>Заголовок1</h1><h2 id="Заголовок2"><a href="#Заголовок2" class="headerlink" title="Заголовок2"></a>Заголовок2</h2><hr><p>Код:</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">echo <span class="string">"code without line numbers"</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Code"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"with"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"line"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"numbers"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; end;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;0,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="built_in">std</span>::string_view; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;1,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="built_in">std</span>::<span class="keyword">size_t</span>; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;2,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Цитаты:</p><blockquote><p>“Citate from me”</p><footer><strong>spiiin</strong></footer></blockquote><hr><p>Списки:</p><ul><li>список1</li><li>список2<ul><li>список21</li><li>список22<ul><li><em>список221</em></li></ul></li></ul></li><li>список3</li></ul><p>Тест 2</p><ul><li><strong>Языки</strong><ul><li><a href="https://c++" target="_blank" rel="noopener">C++</a></li><li>C#</li><li>Python</li></ul></li><li><strong>Движки</strong><ul><li>Unity</li><li>Cocos2d</li><li>Godot</li></ul></li></ul><hr><p>Большой список с уточнениями:</p><p><strong><code>- Один</code></strong><br>Объяснение на много<br>много<br>много строк.</p><p><strong><code>- Два</code></strong><br>Длинное объяснение</p><p><strong><code>- Три</code></strong><br>Ещё одно объснение, в несколько предложений.<br>Или абзацев.</p><hr><p>Текст</p><p>болд - <strong>text</strong><br>курсив - <em>text</em><br>болд+курсив - <strong><em>text</em></strong><br>код - <code>code</code><br>код-болд - <strong><code>code-bold</code></strong></p><hr><p>Ссылки</p><p>Глобальная - <a href="https://google.com/" target="_blank" rel="noopener">Google</a><br>На пост в блоге - <a href="/blog/47121/" title="Hello, hexo">Hello, hexo</a></p><hr><p>Спойлер:</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/44721f2e5a70294fa390218ad92385e4.js?file=james_bond_nim.nim"></script>    </div></div><hr><details><summary>Развернуть</summary><p>Текст</p></details><hr><p>Хинт</p><p>Не работает в начале строки - <span class="hint--info hint--rounded hint--top" data-hint="Multilinehint" ontouchstart>Test</span></p><hr><p>Таблицы</p><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center"><em>right-aligned</em></td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><code>Table Header 1</code></th><th><code>Table Header 2</code></th><th><code>Table Header 3</code></th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr></tbody></table></div><p>Backticks escape: `are` these!</p><hr><p>Картинки</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/blog/16107/fox.png" alt="fox"></h2><hr><p>Плагин для youtube:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/GR18emXxAi0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><hr><p>Плагин valkyr-url:</p><div class="vkr-url-wrapper"><style>.vkr-url-wrapper {    padding: 10px;    border-radius: 5px;    border: 1px solid;    border-color: #eee #ddd #bbb;    box-shadow: rgba(0,0,0,.14) 0 1px 3px;    margin-bottom: 10px;    display: flex;}.vkr-url-wrapper .desc-wrapper > hr {    margin: 10px 0;    height: 1px;}.vkr-url-wrapper .avatar {    width: 100px;    height: 100px;    border: solid 1px #eee;    box-shadow: none!important;    margin: 0;    margin-right: 10px;}.vkr-url-wrapper h2 {    border: none;    margin: 0;    padding: 0;}.vkr-url-wrapper .desc-wrapper {    flex: 1;}.vkr-url-wrapper .desc-wrapper a {    font-size: 22px;    font-weight: 700;}</style>            <a href="https://github.com/spiiin/CadEditor" target="_blank" rel="noopener"><img class="avatar" src="https://raw.githubusercontent.com/spiiin/CadEditor/master/CadEditor/cadIco.png" ></a>        <div class="desc-wrapper">        <a href="https://github.com/spiiin/CadEditor" target="_blank" rel="noopener">Cad Editor</a>        <hr />        <div class="desc">CadEditor is level editor for many classic console games</div>    </div></div><hr><p>Nomnoml diagram</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIyIiBoZWlnaHQ9IjE5OSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDIyMiAxOTkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTE3Ny41IDQ0LjUgTDE3Ny41IDY0LjUgTDE3Ny41IDg0LjUgTDE3Ny41IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTE3Mi4yIDcxLjIgTDE3Ny41IDc3LjggTDE4Mi44IDcxLjIgTDE3Ny41IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik00Ni41IDQzIEwyNi41IDY0LjUgTDI2LjUgODQuNSBMMjYuNSA4NC41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yMS4yIDcxLjIgTDI2LjUgNzcuOCBMMzEuOCA3MS4yIEwyNi41IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik03Mi41IDQzIEw5Mi41IDY0LjUgTDkyLjUgODQuNSBMOTIuNSA4NC41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik04Ny4yIDcxLjIgTDkyLjUgNzcuOCBMOTcuOCA3MS4yIEw5Mi41IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yNi41IDExNS41IEwyNi41IDEzNS41IEwyNi41IDE1NS41IEwyNi41IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yMS4yIDE0Mi4yIEwyNi41IDE0OC44IEwzMS44IDE0Mi4yIEwyNi41IDE1NS41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cmVjdCB4PSI0Ni41IiB5PSIxMy41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjYiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSI1NC44IiB5PSIzNSIgc3R5bGU9IiI+MTwvdGV4dD4KPHJlY3QgeD0iMTMuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjI2IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEuOCIgeT0iMTA2IiBzdHlsZT0iIj4yPC90ZXh0Pgo8cmVjdCB4PSI3OS41IiB5PSI4NC41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjYiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSI4Ny44IiB5PSIxMDYiIHN0eWxlPSIiPjM8L3RleHQ+CjxyZWN0IHg9IjEzLjUiIHk9IjE1NS41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjYiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMS44IiB5PSIxNzciIHN0eWxlPSIiPjQ8L3RleHQ+CjxyZWN0IHg9IjE0NS41IiB5PSIxMy41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iNjQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIxNTMuOCIgeT0iMzUiIHN0eWxlPSIiPmhlbGxvPC90ZXh0Pgo8cmVjdCB4PSIxNDUuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjY0IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMTUzLjgiIHk9IjEwNiIgc3R5bGU9IiI+d29ybGQ8L3RleHQ+PC9zdmc+" /><hr><p>Плагин для qrcode </p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAAAAAAc6VLmAAAA6klEQVR42u3ZwQ6EIAxFUf7/p3GniaHlVZlMi7crDbHHBaEFWptHP+N6vY22NYGURepWmKlHo34WpHLSaJaYqU3JzIK0o6TOQqQPSKPUv5l7SFkkvz75AysrIVICSeg7hadF3TLSf6UejqefIdWQ1NmlrkGTVgapmuQ3rcLG1uxskIpIyo9E2ly5zCElldQWJXR2KmyAkbJKai5h1ZosU0iFJLkFFdcvuwgipZce3qnFz0mRKkmvz8LkSohUSApVpdB1C9KOUuiixH5F2kYSSpNymo5USApdncUv25AqSeo+129IhZNVpPTSAVWCHQugeNVrAAAAAElFTkSuQmCC" alt="hello, world" title="hello, world" class="hello world"></h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Hello, world!&lt;/strong&gt;&lt;br&gt;Немного тестов разметки&lt;br&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>CadEditor v5.0 Changelog</title>
    <link href="http://spiiin.github.io/blog/1634/"/>
    <id>http://spiiin.github.io/blog/1634/</id>
    <published>2018-05-09T07:54:00.000Z</published>
    <updated>2021-01-02T16:38:46.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обновления редактора <a href="https://github.com/spiiin/cadeditor" target="_blank" rel="noopener">CadEditor</a> за год с <a href="https://spiiin.livejournal.com/108403.html" target="_blank" rel="noopener">версии 4.1</a>  </p><p>Почти для всех игр описан способ построения блоков из данных ROM-файла вместо картинок. Фактически, реализована наконец идея создания универсального редактора блоков, когда новые форматы могут быть добавлены с помощью файлов настроек, без изменения кода редактора.  </p><p>Почти для всех поддерживаемых игр добавлены конфиги блоков для всех основных уровней. Большая часть работы сделана другими пользователями. Хотя для добавления новых игр нет документации, большое количество примеров позволило пользователям добавлять подобные игры комбинированием готовых примеров.  </p><p>Написано несколько <a href="https://spiiin.github.io/CadEditor/">статей</a>, описывающих примеры работы с редактором, большинство - с видеопримерами. Создана <a href="https://spiiin.github.io/CadEditor/cadeditor-supported-games.html">нотация</a> для документирования того, как описаны уровни во всех поддерживаемых играх. Добавлено большое исследование устройства <a href="https://spiiin.livejournal.com/124652.html" target="_blank" rel="noopener">спецэффектов в NES-играх</a>.  </p><p>Добавлено редактирование игры со сжатием для NES (Felix the Cat), пока с примером ручного пережатия отредактированных данных с помощью <a href="https://github.com/spiiin/JupyterCadEditor/blob/master/CadEditor-Felix-decompress.ipynb" target="_blank" rel="noopener">скрипта на Python</a>.  </p><p>Проект <a href="https://github.com/spiiin/JupyterCadEditor" target="_blank" rel="noopener">JupyterCadEditor</a> (использование CadEditord в качестве библиотеки для Python в ноутбуках Jupyter) вынесен в отдельный репозиторий. Добавлены скрипты, позволяющие по конфигу игры для одного региона находить такие же данные для версии игры другого региона, что позволяет легко добавлять поддержку игр для разных регионов.  </p><p>Упрощён и улучшен рендер панелей и редакторов, убраны лишние масштабирования и “замыливание” при отрисовке.  </p><p>Добавлен плагин <a href="https://www.patreon.com/posts/september-2-2017-14324437" target="_blank" rel="noopener">экспорта карты в формат TMX</a>, для последующего использования её в редакторе <a href="https://www.mapeditor.org/" target="_blank" rel="noopener">Tiled</a>. Улучшены плагины экпорта блоков и экранов в картинки и бинарные файлы.  </p><p>Добавлено множество lua-скриптов для упрощения исследования игр и добавления их в редактор. Переписаны с Python на Lua скрипты автоматического поиска блоков различных форматов в видеопамяти - теперь они позволяют находить блоки прямо во время прохождения игры, без необходимости делать дампы памяти вручную.   </p><p>Добавлены lua-скрипты для эмулятора Mesen, позволяющие исследовать <a href="https://spiiin.livejournal.com/121112.html" target="_blank" rel="noopener">спецэффекты</a> в NES-играх, а также расширяющие возможности эмулятора в отладке.  </p><p>Добавлены утилиты для проверки целостности конфигов при обновлении версии редактора и исследования функций конфига без запуска самого редактора.  </p><p>Добавлен плагин, позволяющий пережимать данные и запаковывать их в ROM - <a href="https://www.youtube.com/watch?v=NfIWeDwu68w" target="_blank" rel="noopener">компрессор</a> для игры Contra Hard Corps.  </p><p>Плагин для запуска пользовательских скриптов из редактора и примеры его использования (экспорт скриншотов, экспорт блоков из игры для использования в <a href="https://www.youtube.com/watch?v=GR18emXxAi0" target="_blank" rel="noopener">демо-проектах</a>)  </p><p>Проект перешагнул первую <a href="https://github.com/spiiin/CadEditor/commit/f29ebd2437ae2f44950b1f5fb43a74b1230fc5fc" target="_blank" rel="noopener">тысячу</a> коммитов, а также переведён на .NET Framework 4.0. Редактор содержит более 1500 конфигов блоков и экранов различных уровней для 128 игр. Большая часть этих конфигов добавлена пользователями редактора, так что проект частично стал продуктом сообщества ромхакеров.  </p><p>Возможно, в следующих итерациях в редактор будут добавлены возможности универсального описания редактора объектов для уже добавленных игр, это такая же большая задача, как и создание универсального редактора блоков, но и её возможно решить.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Обновления
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Castlevania HD Pack</title>
    <link href="http://spiiin.github.io/blog/45580/"/>
    <id>http://spiiin.github.io/blog/45580/</id>
    <published>2018-05-04T19:27:00.000Z</published>
    <updated>2021-01-02T16:40:23.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Очень здоровская затея в современных эмуляторах - вытащить всю графику, улучшить её качество, и включить в эмуляторе использование этой улучшенной графики.  </p><p><a href="http://www.romhacking.net/forum/index.php?topic=26114" target="_blank" rel="noopener">Улучшенный пак</a> графики и музыки для первой Castlevania под эмулятор Mesen.  </p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/D9SQei4eIqY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Записал прохождение, с помощью самописного скрипта для <a href="https://github.com/spiiin/CadEditor/tree/master/Stuff/nes_lua/mesen_savemovies" target="_blank" rel="noopener">перезаписи прохождений</a>, надеюсь автор эмулятора наконец добавит нормальную реализацию перезаписи в ближайших обновлениях.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Очень здор
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Шейдеры для NES игр</title>
    <link href="http://spiiin.github.io/blog/16778/"/>
    <id>http://spiiin.github.io/blog/16778/</id>
    <published>2018-04-21T11:57:00.000Z</published>
    <updated>2021-01-02T16:42:40.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Продолжаю изучать возможности lua-скриптов в эмуляторе Mesen. </p><p>Функции <a href="https://www.mesen.ca/docs/apireference/drawing.html#getscreenbuffer" target="_blank" rel="noopener">getScreenBuffer/setScreenBuffer</a> позволяют каждый кадр (или чаще) модифицировать содержимое экранного буфера. Так можно добавлять простые шейдеры постэффектов (да и сложные тоже). </p><p><a href="https://github.com/spiiin/CadEditor/blob/master/Stuff/nes_lua/mesen_modifyScreen.lua" target="_blank" rel="noopener">Скрипт</a> с эффектами красного экрана, мерцания, черезстрочного вывода и построчного “двоения экрана”. </p><p>Возможны также и более сложные эффекты (размытие движения, дождик, выделение контуров и т.п.), правда, не сильно удобно писать такое на Lua.</p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/04KOJmRYwko" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Продолжаю 
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Ещё о криптокартинах</title>
    <link href="http://spiiin.github.io/blog/34124/"/>
    <id>http://spiiin.github.io/blog/34124/</id>
    <published>2018-03-27T19:45:00.000Z</published>
    <updated>2021-01-02T16:44:14.783Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Несколько месяцев назад я <a href="https://spiiin.dreamwidth.org/113215.html" target="_blank" rel="noopener">писал</a> о художнице, шифрующей в картинках приватные ключи от кошельков с биткоинами. Она делала многоуровневые загадки, обсуждение которых в итоге перенесла на закрытый форум, чтобы не решившие первые этапы задачи не могли пользоваться результатами других. А вот <a href="https://andybauch.com/" target="_blank" rel="noopener">Andy Bauch</a> поступил проще - сделал несколько картин с отдельными задачками и <a href="https://newmoney.andybauch.com/" target="_blank" rel="noopener">призами</a>. Картинки выложено из кубиков Лего.  </p><p>На хабре уже разобрали несколько решений (<a href="https://habrahabr.ru/post/352014/" target="_blank" rel="noopener">раз</a>, <a href="https://habrahabr.ru/post/351950/" target="_blank" rel="noopener">два</a>), кто-то даже успел решить пару задач. До меня, к сожалению, поздновато, дошло, так бы с удовольствием поучаствовал в решении.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Несколько 
      
    
    </summary>
    
    
    
      <category term="крипто" scheme="http://spiiin.github.io/tags/%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE/"/>
    
      <category term="картинки" scheme="http://spiiin.github.io/tags/%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Into the breach</title>
    <link href="http://spiiin.github.io/blog/65303/"/>
    <id>http://spiiin.github.io/blog/65303/</id>
    <published>2018-03-20T19:44:00.000Z</published>
    <updated>2021-01-02T16:45:11.786Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Очень, очень интересная тактика. Давненько не встречал такого, чтобы над каждым ходом необходимо было думать, иногда одного неправильного действия достаточно для проигрыша всей глобальной партии.</p><p>Разработчики добились этого за счёт того, что всегда огневой мощи отряда игрока не хватает для обезвреживания всех врагов, поэтому их чаще надо не уничтожать, а переставлять по полю так, чтобы они промахивались, а ещё лучше били друг друга. При этом враги угрожают не юнитам игрока, а беззащитным зданиям, которые приходится прикрывать юнитами, так как потеря нескольких зданий сразу ведёт к поражению не только в битве, но и во всей игре.</p><p>Интересно, что помимо основных 2 уровней планирования - тактического в битвах и стратегического на глобальной карте, присутствует ещё уровень метапланирования действий между играми - возможно пожертвовать целой игрой, ради того, чтобы получить достижение за игру и за очки достижений открыть более мощный отряд юнитов для следующей партии. Подобный ход, в совокупности с генерируемыми островами добавляет игре реиграбельности на десяток прохождений.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Очень, оче
      
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>TMNT - Tournament Fighters [NES] Lua-скрипт для выполнения суперударов</title>
    <link href="http://spiiin.github.io/blog/29889/"/>
    <id>http://spiiin.github.io/blog/29889/</id>
    <published>2018-03-16T18:58:00.000Z</published>
    <updated>2021-01-02T16:46:34.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://github.com/spiiin/CadEditor/blob/master/Stuff/nes_lua/tmnt4_moves.lua" target="_blank" rel="noopener">Скрипт</a>, позволяющий выполнять суперудары нажатием одной кнопки в лучшем файтинге на NES - TMNT: Tournament Fighters.</p><p>Упрощает игру с клавиатуры. Кроме обычных суперударов можно записывать и более сложные комбинации, доступные только профессиональным игрокам, например, обманный трюк Рафаэлем - активиция (но не выполнение) “сверла” зажатием кнопки назад, затем быстрый разбег, прыжок с ударом ногой, и выполнение сверла в прыжке с разбега.</p><p>Сложность движения в том, что разбег и прыжок должны быть выполнены очень быстро, пока игра всё ещё считает суперудар активированным. <a href="http://pscd.ru/codes/nescodes/tnescodes/6568-teenage-mutant-ninja-turtles-tournament-fighters-prohozhdenie-faq.html" target="_blank" rel="noopener">Детальное объяснение</a> игровой механики.</p><p>Видео:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/t6A4h_GfsYI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Супер Марио в супер сломо</title>
    <link href="http://spiiin.github.io/blog/17738/"/>
    <id>http://spiiin.github.io/blog/17738/</id>
    <published>2018-03-11T13:51:00.000Z</published>
    <updated>2021-01-02T16:47:28.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/3BJU2drrtCM" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;style&gt;.embed
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
</feed>
