<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2020-09-01T18:13:25.949Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Уровень программирования: Middle</title>
    <link href="http://spiiin.github.io/blog/15798/"/>
    <id>http://spiiin.github.io/blog/15798/</id>
    <published>2020-08-12T08:58:08.000Z</published>
    <updated>2020-09-01T18:13:25.949Z</updated>
    
    <content type="html"><![CDATA[<p>Несколько очень часто встречающих у программистов-новичков ошибок<br><a id="more"></a></p><p>…</p><p><strong>1. Использование примитивов вместо высокоуровневых абстракций</strong></p><p>Новички часто пишут код “с нуля”, забывая о возможностях используемых фреймворков или библиотек. Фактически это просто неумение работать со сложными типами и игнорирование возможностей системы типов используемого языка.</p><blockquote><p>Каждый раз, когда необходимо завести переменную типа <code>int</code> - подумайте, действительно ли нужен просто целочисленный тип, или же с помощью типа можно сказать ещё что-то полезное о переменной</p></blockquote><p><strong>2. Реализация всей логики в одной функции</strong></p><p>Если какой-то кусок кода можно вынести в именованную функцию (даже если она не будет переиспользоваться), стоит так сделать. Функции проще объединять в классы или модули, чем “голый” код и разрастающиеся безымянные функции. Это нужно, чтобы уменьшить вероятность копи-пасты кода (точнее даже, умеьшения количества необходимых для изменения логики мест в коде).</p><blockquote><p>Можно ли описать одним небольшим предложением, что делает функция? Что делает класс? Что описано в файле/namespace/модуле?</p></blockquote><p><strong>3. Игнорирование инкапсуляции</strong></p><p>Инкапсуляция часто ошибочно трактуется новичками как необходимость делать все данные класса закрытыми. На практике лучше понимать и использовать её как средство сделать объект неломаемым пользователем. Т.е. если изменение переменных не может привести к тому, что класс будет находиться в невалидном состоянии - то и не надо их прятать. Если же для корректной работы с объектом у него нужно вызвать 5 разных методов в строго определенном порядке (а в других случаях программа падает), значит, нет у него никакой инкапсуляции. Пользователь объекта не должен помнить о том, что нельзя делать с объектов, чтобы не сломать его внутреннюю логику - сам объект должен быть неломаемым для пользователя.</p><blockquote><p>Таким образом в некоторых языках отказываются “ломающихся” абстракций и возможностей (<code>goto</code>, отказ от указателей, отказ от ручного освобождения памяти, отказ от мутабельности).</p></blockquote><p><strong>4. Персональный стиль</strong></p><p>По большей части, все программы пишутся несколькими людьми, так что вместо того, что писать в строго выработанном правильном стиле, стоит учиться подстраиваться под стиль уже написанного кода. Код на некоторых языках имеет стандартные правила написания, но даже с учётом этого необходимо помнить, что программа могла писаться, когда в ходу были другие правила, или же по каким-либо другим причинам использовать другой подход. Стоит писать так, чтобы стиль всей программы был одинаковый - так у читающего код будет меньше вопросов, почему в разных местах программы используются разные варианты (и какой стиль выбрать при изменении кода).</p><blockquote><p>Прежде чем писать код, прочитайте уже написанный</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Несколько очень часто встречающих у программистов-новичков ошибок&lt;br&gt;
    
    </summary>
    
    
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Карта прохождения игр</title>
    <link href="http://spiiin.github.io/blog/1563/"/>
    <id>http://spiiin.github.io/blog/1563/</id>
    <published>2020-08-04T19:11:37.000Z</published>
    <updated>2020-09-01T18:10:28.493Z</updated>
    
    <content type="html"><![CDATA[<p>Список игр на прохождение<br><a id="more"></a></p><h2 id="Current-list"><a href="#Current-list" class="headerlink" title="Current list"></a>Current list</h2><p><code>Captain Toad</code> - 90%<br><code>Age of Mythologies</code> - 50%<br><code>Gta 5</code> - 30%<br><code>The Witcher 2</code> - 5%</p><h2 id="Coop"><a href="#Coop" class="headerlink" title="Coop"></a>Coop</h2><p><code>The Stratchers</code> - 33%<br><code>Trine 4</code> - 30%<br><code>Minecraft</code> - 5%</p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><p><code>Yoshi&#39;s Crafted World</code><br><code>The Forest</code></p><h2 id="Completed"><a href="#Completed" class="headerlink" title="Completed"></a>Completed</h2><p><code>Mario+Rabbids</code><br><code>Witcher</code><br><code>Legend of Zelda: BotW</code><br><code>Warhammer 40k: Mechanicus</code></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Список игр на прохождение&lt;br&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>Привет, Hexo</title>
    <link href="http://spiiin.github.io/blog/47121/"/>
    <id>http://spiiin.github.io/blog/47121/</id>
    <published>2020-07-18T14:14:53.000Z</published>
    <updated>2020-09-15T15:24:43.416Z</updated>
    
    <content type="html"><![CDATA[<p>После нескольких дней возни в очередной попытке собрать на <code>jekyll</code> статический блог, решил забить на него и попробовать использовать для блога <a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>. Получилось сильно проще и приятнее.</p><p>Во-первых, <code>hexo</code> запускается легче, и темы работают сходу. И, что удобно для блога программисту, подсветка синтаксиса кода интегрирована в движок лучше, из чего следует, что темы скорее всего будут совместимы с ней (у <code>jekyll</code> подобрать работающую пару “тема+плагин подсветки синтаксиса” оказалось очень непросто, то съезжала нумерация длинных строк, то весь блок с кодом выглядел коряво, то были проблемы с корректным отображения цвета строк или фона)</p><a id="more"></a><p>Единственное, для корректной работы тем, иногда опытным путём, необходимо выяснить, какие плагины необходимо доустановить из <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">списка</a>.</p><h2 id="Темы"><a href="#Темы" class="headerlink" title="Темы"></a>Темы</h2><p>Далее, выбор <a href="https://hexo.io/themes/" target="_blank" rel="noopener">тем</a>. Достаточно много качественных и приятных глазу, из тёмных и минималистичных интересными показались:</p><ul><li><a href="https://github.com/howardliu-cn/hexo-theme-clean-dark" target="_blank" rel="noopener">clean-dark</a><ul><li><a href="https://www.howardliu.cn/" target="_blank" rel="noopener">Пример</a></li><li>Оригинальная <a href="http://pavelmakhov.com/jekyll-clean-dark" target="_blank" rel="noopener">тема для jekyll</a>, которая была взята в качестве основы для этой темы</li></ul></li><li><a href="https://github.com/maochunguang/black-blue" target="_blank" rel="noopener">black-blue</a><ul><li><a href="http://maochunguang.github.io/" target="_blank" rel="noopener">Пример</a></li></ul></li><li><a href="https://github.com/tzvetkov75/solar-theme-hexo/" target="_blank" rel="noopener">solar</a><ul><li><a href="https://tzvetkov75.github.io/demo_blog/public/" target="_blank" rel="noopener">Пример</a>.</li><li>Тема на основе <a href="https://probberechts.github.io/hexo-theme-cactus/cactus-dark/public/" target="_blank" rel="noopener">cactus</a></li></ul></li><li><a href="https://github.com/lyndonoc/hexo-theme-pandollo" target="_blank" rel="noopener">pandollo</a><ul><li><a href="https://lyndonoc.github.io/" target="_blank" rel="noopener">Пример</a></li></ul></li></ul><h2 id="Настройка-темы"><a href="#Настройка-темы" class="headerlink" title="Настройка темы"></a>Настройка темы</h2><p>Минимальная настройка темы включает правку файла <code>config.yml</code>, какие именно настройки поддерживаются, обычно написано на сайте темы.</p><p>Дополнительно, на примере темы <code>pandolo</code> - можно донастроить стиль, разобравшись с правкой файлов в папке <code>themes/pandollo/source/scss</code>.</p><p>Дальше нужно выполнить команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sass --style&#x3D;compressed .&#x2F;main.scss ..&#x2F;css&#x2F;main.css</span><br></pre></td></tr></table></figure></p><p>Для того, чтобы сгенерировать упакованную версию файла стилей, которую будет использовать блог.</p><p>После небольших правок получилась примерно такая “лисья” тема:<br><img src="/blog/47121/hexo-fox.png" alt="hexo-fox"></p><h2 id="Настройка-плагинов"><a href="#Настройка-плагинов" class="headerlink" title="Настройка плагинов"></a>Настройка плагинов</h2><p>Для выбранной темы пригодятся следующие плагины:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  ...</span><br><span class="line">  "hexo-asset-link": "^2.0.1",</span><br><span class="line">  "hexo-generator-fragments": "^1.0.0",</span><br><span class="line">  "hexo-renderer-kramed": "^0.1.4",</span><br><span class="line">  "hexo-renderer-jade": "^0.5.0",</span><br><span class="line">  "hexo-abbrlink": "^2.2.1",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/liolok/hexo-asset-link" target="_blank" rel="noopener">hexo-asset-link</a> - позволяет использовать в постах ссылку на ассет в виде относительного пути: <code>POST_NAME/asset_name.png</code> (также нужно включить в <code>config.yml</code> опцию: <code>post_asset_folder: true</code>, чтобы hexo создавал отдельную папку для ассетов к каждому посту).</p><p><a href="https://github.com/mamboer/hexo-generator-fragments" target="_blank" rel="noopener">hexo-generator-fragments</a> - необходим для темы - генерирует preview для постов для главной страницы, позволяет использоватьв в постах тег <code>&lt;!-- more --&gt;</code> чтобы отмечать краткую короткую preview-версию поста.</p><p><a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> - плагины, содержащие в названии renderer, позволяют hexo генерировать посты из разных форматов файла. Данный плагин используется для рендера из файлов <code>*.md</code> в формате <code>github flavored markdown</code>, который используется на серверах <code>github</code>.<br>В комплекте с <code>hexo</code> уже идёт плагин, который рендерит markdown-файлы, поэтому чтобы использовать альтернативный, предварительно нужно его удалить:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/hexojs/hexo-renderer-jade" target="_blank" rel="noopener">hexo-renderer-jade</a> - необходимый для темы плагин, позволяющий рендерить pug-файлы (собственно, сама тема описана в этом формате).</p><p><a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> - генерирует для каждого поста идентификатор. Для генерации имён постов необходимо в <code>config.yml</code> добавить строку:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br></pre></td></tr></table></figure><br>Для того, чтобы указать ссылку на пост, нужно использовать тег:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Написание-постов"><a href="#Написание-постов" class="headerlink" title="Написание постов"></a>Написание постов</h2><p>После установки и настройки темы можно попробовать добавить пост:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post hello-hexo.md</span><br></pre></td></tr></table></figure><br>Вместо md можно попробовать использовать другие форматы, для которых установлены render-плагины. В качестве редактора постов я бы посоветовал использовать (Visual Studio Code)[<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a>], вместе с плагином <a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/" target="_blank" rel="noopener">Markdown Enchanced Preview</a>.</p><p>Чтобы проверить, как выглядит пост, нужно запустить команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure><br>и открыть в браузере страницу <code>http://127.0.0.1:4000/</code> (hexo отслеживает изменения исходников и сразу обновляет открытую страницу).</p><p>Сгенерировать статический сайт можно так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p><p>Весь сгенерированный сайт будет содержаться в папке <code>public</code>, её можно заливать на хостинг руками или воспользоваться плагинами для автоматизации этих процессов.</p><h2 id="Итог"><a href="#Итог" class="headerlink" title="Итог"></a>Итог</h2><p>В кажущейся простой задаче “отрендерить markdown-статью в html”, cкрыт выбор целого стека способов решения (генераторы сайтов со своими языками, рендеры разных форматов и диалектов разметки, языки описания стилей и шаблонов сайта, темы, плагины, подсветка кода, системы развёртывания сайта).</p><p>В <code>hexo</code> эти вещи более-менее целостно сшиты вместе в единую систему, которой можно начать пользоваться достаточно быстро.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;После нескольких дней возни в очередной попытке собрать на &lt;code&gt;jekyll&lt;/code&gt; статический блог, решил забить на него и попробовать использовать для блога &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;. Получилось сильно проще и приятнее.&lt;/p&gt;
&lt;p&gt;Во-первых, &lt;code&gt;hexo&lt;/code&gt; запускается легче, и темы работают сходу. И, что удобно для блога программисту, подсветка синтаксиса кода интегрирована в движок лучше, из чего следует, что темы скорее всего будут совместимы с ней (у &lt;code&gt;jekyll&lt;/code&gt; подобрать работающую пару “тема+плагин подсветки синтаксиса” оказалось очень непросто, то съезжала нумерация длинных строк, то весь блок с кодом выглядел коряво, то были проблемы с корректным отображения цвета строк или фона)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Коллекция постов в ЖЖ</title>
    <link href="http://spiiin.github.io/blog/35153/"/>
    <id>http://spiiin.github.io/blog/35153/</id>
    <published>2020-07-10T12:45:28.000Z</published>
    <updated>2020-08-04T19:27:29.052Z</updated>
    
    <content type="html"><![CDATA[<p>Коллекция ссылок на посты в ЖЖ<br><a id="more"></a></p><ul><li><a href="https://spiiin.livejournal.com/104515.html" target="_blank" rel="noopener">Устройство уровней NES-игр с блоками 16 тайлов + 1 байт палитры</a></li><li><a href="https://spiiin.livejournal.com/104049.html" target="_blank" rel="noopener">Duck Tales 2 lua script showing hidden diamonds</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Коллекция ссылок на посты в ЖЖ&lt;br&gt;
    
    </summary>
    
    
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://spiiin.github.io/blog/16107/"/>
    <id>http://spiiin.github.io/blog/16107/</id>
    <published>2020-07-01T12:45:28.000Z</published>
    <updated>2020-09-15T16:28:46.711Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Hello, world!</strong><br>Немного тестов разметки<br><a id="more"></a></p><h1 id="Заголовок"><a href="#Заголовок" class="headerlink" title="Заголовок"></a>Заголовок</h1><h2 id="Подраздел"><a href="#Подраздел" class="headerlink" title="Подраздел"></a>Подраздел</h2><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">echo <span class="string">"code without line numbers"</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Code"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"with"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"line"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"numbers"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; end;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;0,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="built_in">std</span>::string_view; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;1,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="built_in">std</span>::<span class="keyword">size_t</span>; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;2,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/44721f2e5a70294fa390218ad92385e4.js?file=james_bond_nim.nim"></script>    </div></div><blockquote><p>“Citate from me”</p><footer><strong>spiiin</strong></footer></blockquote><ul><li>список1</li><li>список2<ul><li>список21</li><li>список22<ul><li><em>список221</em></li></ul></li></ul></li><li>список3</li></ul><p><strong><code>code-bold</code></strong> <code>code</code></p><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center"><em>right-aligned</em></td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><p>Backticks escape: `are` these!</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Hello, world!&lt;/strong&gt;&lt;br&gt;Немного тестов разметки&lt;br&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Игра в сегу по сети.</title>
    <link href="http://spiiin.github.io/blog/8741/"/>
    <id>http://spiiin.github.io/blog/8741/</id>
    <published>2014-12-22T04:49:00.000Z</published>
    <updated>2020-09-15T16:55:44.924Z</updated>
    
    <content type="html"><![CDATA[<style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/m6OeJYWAJ6c" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
  }

      
    
    </summary>
    
    
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="sega" scheme="http://spiiin.github.io/tags/sega/"/>
    
      <category term="hardware" scheme="http://spiiin.github.io/tags/hardware/"/>
    
  </entry>
  
  <entry>
    <title>Battletoads heavy glitches</title>
    <link href="http://spiiin.github.io/blog/57614/"/>
    <id>http://spiiin.github.io/blog/57614/</id>
    <published>2013-01-08T15:21:00.000Z</published>
    <updated>2020-09-15T17:02:24.441Z</updated>
    
    <content type="html"><![CDATA[<style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/bOweqz4cDlA" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Ну и весь канал у них там такой</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;.embed-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    max-width: 100%;
  }

      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>Monster Debugger</title>
    <link href="http://spiiin.github.io/blog/56282/"/>
    <id>http://spiiin.github.io/blog/56282/</id>
    <published>2011-12-30T18:46:00.000Z</published>
    <updated>2020-09-15T21:05:22.868Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.monsterdebugger.com/game" target="_blank" rel="noopener">http://www.monsterdebugger.com/game</a><br>Игра, которую надо проходить с помощью отладчика.<br><a href="http://www.monsterdebugger.com/game" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0002abk7/s640x480" alt=""></a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.monsterdebugger.com/game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.monsterdebugger.com/game&lt;/a&gt;&lt;br&gt;Игра, которую над
      
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>Исследование Addams Family(E) [NES]</title>
    <link href="http://spiiin.github.io/blog/4383/"/>
    <id>http://spiiin.github.io/blog/4383/</id>
    <published>2011-12-23T11:41:00.000Z</published>
    <updated>2020-09-15T21:49:56.767Z</updated>
    
    <content type="html"><![CDATA[<p><code>&quot;Семья Аддамсов&quot;</code> - одна из самых запутанных игр на NES. </p><p>Практически все зоны доступны сразу, но чтобы пройти их, надо знать правильный порядок. Но даже после полного прохождения у каждого из игроков остаётся несколько вопросов. Никому неизвестно, куда ведёт закрытая дверь в холле и зачем нужны третьи ноты в библиотеке. Но вооружившись дизассемблером и монитором памяти, можно это узнать. </p><p>Сначала с помощью поиска читов необходимо отсеять ячейки памяти, которые изменяются вместе с игровой зоной. Чтобы это сделать в эмуляторе fceuxd sp надо много раз, меняя комнату, в меню Tools-&gt;Cheats просеивать ячейки кнопками Equal и Not Equal. Когда останется примерно тридцать ячеек можно с помощью монитора памяти (Tools-&gt;Hex editor), следить за ними в реальном времени. При этом опытному ромхакеру в глаза сразу должна броситься ячейка $613, которая со всех сторон окружена нулями, а сама меняется с номером комнаты или при сборе предметов. В игре есть только один параметр, который меняется при таких условиях - подсказка с названием комнаты внизу экрана.  </p><p>Сюда ставится точка остановки на запись и при следующей смене комнаты находится код, который пишет в эту ячейку.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lda x, $71 ;переносим в x значение из ячейки $71  </span><br><span class="line">lda c7d2,x ;загружаем номер строки с названием  </span><br><span class="line">sta $613 ;записываем номер строки в ячейку $613</span><br></pre></td></tr></table></figure><p>Проверка подтверждает, что номер комнаты сохраняется в ячейке $71. Теперь можно создать мобильный телепорт - переставить точку остановки на запись на ячейку $71, и после срабатывания, вручную подменять её на любое число, чтобы получить таблицу игровых комнат.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ROOMПОЯСНЕНИЕ</span><br><span class="line">00THE GARDENСад</span><br><span class="line">01THE TREEДерево в саду</span><br><span class="line">02THE CRYPTСклеп в саду</span><br><span class="line">03THE HALLWAYХолл</span><br><span class="line">04THE DINING ROOMСтоловая снизу справа от входа</span><br><span class="line">05THE GALLERYГалерея снизу слева от холла</span><br><span class="line">06THE LANDINGКоридок сверху слева, в сторону чердака</span><br><span class="line">07THE LANDINGКоридор сверху справа, в сторону балкона</span><br><span class="line">08THE FESTER&#39;S ROOMКомната Фестера</span><br><span class="line">09THE PUGSLEY&#39;S ROOMКомната Пагсли</span><br><span class="line">0ATHE TOY ROOMКомната игрушек</span><br><span class="line">0BTHE WEDNESDAY&#39;S ROOMКомната Венсдей</span><br><span class="line">0CTHE ATTICЧердак</span><br><span class="line">0DTHE ROOFКрыша</span><br><span class="line">0ETHE PONDПруд в лесу</span><br><span class="line">0FTHE SECRET ROOMТайник в комнате MASTER&#39;S BEDROOM</span><br><span class="line">10THE SECRET ROOMТайник в шкафу на чердаке</span><br><span class="line">11THE SECRET ROOMТайник справа в пруду</span><br><span class="line">12THE CHIMNEYКамин. Вход в трубе на крыше</span><br><span class="line">13THE BATHROOMВанная</span><br><span class="line">14THE BALLROOMЗал с привидениями, центральная дверь в холле</span><br><span class="line">15THE WOODЛес за залом</span><br><span class="line">16THE KITCHENКухня, дверь справа в холле</span><br><span class="line">17THE LIBRARYБиблиотека</span><br><span class="line">18THE CHAIN ROOMКомната с цепями. Выходы в комнаты 19,02,16,23,09</span><br><span class="line">19THE SECRET RIVERСекретная река</span><br><span class="line">1ATHE TREASURYСокровищница</span><br><span class="line">1BTHE SECRET ROOMТайник в камине с огнем в столовой</span><br><span class="line">1CTHE PITЯма-ловушка с шипами. Тупик снизу-справа в склепе</span><br><span class="line">1DTHE BONE ROOMДверь сверху-слева в склепе</span><br><span class="line">1ETHE BONE ROOMДверь снизу-слева в склепе</span><br><span class="line">1FTHE BONE ROOMДверь сверху-слева в склепе</span><br><span class="line">20THE GOMEZ&#39;S ROOMПоследняя комната</span><br><span class="line">21THE FREEZERХолодильник в кухне</span><br><span class="line">22THE FURNACEПечка, вход справа в кухне</span><br><span class="line">23THE PITЯма-ловушка в комнате с ценями</span><br><span class="line">24THE STUDYВход в библиотеку</span><br></pre></td></tr></table></figure><p>Аналогичным отсевом можно найти в памяти место хранения полученных предметов. Если в ячейке по адресу записан 0 - предмет отсутствует, если 1 - предмет уже найден. Другие числа означают разновидность предмета. Таблица предметов (собрана для проверки существования тайного ключа от двери в холле):  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADDRESSITEMПОЯСНЕНИЕ</span><br><span class="line">630SNORRELМаска для плавания в пруду</span><br><span class="line">631UMBRELLAЗонт для спуска в вертикальных комнатах</span><br><span class="line">632BUCKETВедро. 1 - пустое ведро, 2 - с водой</span><br><span class="line">633HOUSEКлюч от входа в дом</span><br><span class="line">634TREEКлюч от двери в дереве</span><br><span class="line">635ATTICКлюч от чердака</span><br><span class="line">636MUSIC SCOREНоты. 1,2,3 - тип нот</span><br><span class="line">637FOGТуман из трубы</span><br><span class="line">638BONEТуман из трубы</span><br><span class="line">639BLUE EGGТуман из трубы</span><br><span class="line">63AMORTICIAСпасенные члены семьи</span><br><span class="line">63BPUGSLEY~</span><br><span class="line">63CGRANNY~</span><br><span class="line">63DWEDNESDAY~</span><br><span class="line">63ELURCH~</span><br><span class="line">63FTHING~</span><br><span class="line">640SPANNERГаечный ключ</span><br></pre></td></tr></table></figure><p>Никаких секретов =\</p><p>Еще для надежности можно провести исследование кода вывода надписи <code>Locked Door</code>, которая появляется, если нету при попытке зайти в закрытую дверь. Для этого точка остановки снова перемещается на ячейку $613, игра стопится на попытке зайти в любую закрытую дверь, память дампится в файл и загружается в дизассемблер. Анализ процедуры, на которой остановилось выполнение, показывает 5 переходов на вывод сообщения о закрытой двери. По таблице номеров комнат и предметов легко расшифровываются условия.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADDRESSУсловие</span><br><span class="line">E76DСекретная река. Закрыто, если не спасен PUGSLEY</span><br><span class="line">E78EКомната в холле. Код ниже</span><br><span class="line">E781Нужен ключ от входа на чердак</span><br><span class="line">E7A2Нужен ключ от двери в дереве</span><br><span class="line">xxxxНужен ключ от входа в дом</span><br></pre></td></tr></table></figure><p>Проверка условия на двери в холле</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E74C: LDA byte\_71 ;загрузка номера текущей комнаты  </span><br><span class="line">...  </span><br><span class="line">E784: CMP #3 ; если в холле  </span><br><span class="line">E786: BNE loc\_E793  </span><br><span class="line">E788: LDY #0  </span><br><span class="line">E78A: LDA ($A),Y  </span><br><span class="line">E78C: CMP #7 ; если вход в дверь номер 7 (та самая загадочная дверь)  </span><br><span class="line">E78E: BEQ $E7AC  </span><br><span class="line">E7AC: LDA #$32 ; показать строку номер 32 &quot;locked door&quot;  </span><br><span class="line">E7AE: STA byte\_613 ; дверь закрыта всегда &#x3D;\</span><br></pre></td></tr></table></figure><p>С нотами такая же штука. В момент, когда Гомез передаёт дворецкому манускрипт, единственное, что происходит в коде - выставляется значение номера мелодии в ячейку $623. Если записать в эту ячейку другие числа, можно послушать все 5 музыкальных тем игры или заставить дворецкого играть нойз из кода игры. Ячейка с номером мелодии постоянно считывается только в комнатах Library(открывается секретный проход в комнату цепей нотами 1) и Ballroom (призраки начинают танцевать и открывается вход в лес, если были выбраны ноты 3). Ноты номер 2 не используются нигде =\  </p><p>Секретов нет, но теперь это хотя бы проверено.  </p><p><strong>update</strong> Ненужная нота в библиотеке - это отсылка к старому черному белому сериалу</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;&amp;quot;Семья Аддамсов&amp;quot;&lt;/code&gt; - одна из самых запутанных игр на NES. &lt;/p&gt;
&lt;p&gt;Практически все зоны доступны сразу, но чтобы прой
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>Уровни Jungle Book [NES]. Часть 2</title>
    <link href="http://spiiin.github.io/blog/21742/"/>
    <id>http://spiiin.github.io/blog/21742/</id>
    <published>2011-10-19T21:14:00.000Z</published>
    <updated>2020-09-15T21:46:50.271Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Шаг 0x0A.</strong> </p><p>Остается последний шаг, чтобы связать результаты анализа снизу (от экрана к набору) и сверху (от набора к экрану) - понять, как адреса из предэкрана + смещение попадают в экран . Так как для этого копирования используется адресация через нулевую страницу, точку остановки поставить нельзя, поэтому можно только поставить ее на запись в экран и просто искать в окрестностях чтение из предэкрана .</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROM:840F JSR sub_856B ; Копирование 4х адресов в зону предэкран-вторичные индексы</span><br><span class="line">ROM:840F ; х циклически проходит диапазон (00-03)</span><br><span class="line">ROM:8412 LDA byte_A5</span><br><span class="line">ROM:8414 EOR #3</span><br><span class="line">ROM:8416 TAX</span><br><span class="line">ROM:8417 LSR A</span><br><span class="line">ROM:8418 STA byte_A9</span><br><span class="line">ROM:841A</span><br><span class="line">ROM:841A LDY #0</span><br><span class="line">ROM:841C LDA ($A3),Y ; индекс относительно базового адреса из предэкрана</span><br><span class="line">ROM:841E TAY</span><br><span class="line">ROM:841F PHA</span><br><span class="line">ROM:8420 BMI loc_8427</span><br><span class="line">ROM:8422 LDA ($83),Y ; отсюда мы считываем индекс начала цепочки</span><br><span class="line">ROM:8424 JMP loc_8429</span><br><span class="line">ROM:8427 ; ---------------------------------------------------------------------------</span><br><span class="line">ROM:8427</span><br><span class="line">ROM:8427 LDA ($85),Y</span><br><span class="line">ROM:8429</span><br><span class="line">ROM:8429 TAY</span><br><span class="line">ROM:842A BPL loc_843B</span><br><span class="line">ROM:842C LDA ($95),Y ; используем считанный индекс, чтобы взять тайл из набора</span><br><span class="line">ROM:842E STA $40B,X</span><br><span class="line">ROM:8431 LDA ($99),Y</span><br><span class="line">ROM:8433 STA $40C,X</span><br><span class="line">ROM:8436 LDA ($71),Y</span><br><span class="line">ROM:8438 JMP loc_8447</span><br><span class="line">ROM:843B ; ---------------------------------------------------------------------------</span><br><span class="line">ROM:843B</span><br><span class="line">ROM:843B LDA ($93),Y</span><br><span class="line">ROM:843D STA $40B,X</span><br><span class="line">ROM:8440 LDA ($97),Y</span><br><span class="line">ROM:8442 STA $40C,X</span><br><span class="line">ROM:8445 LDA ($6F),Y</span><br><span class="line">ROM:8447</span><br><span class="line">ROM:8447 AND #3</span><br><span class="line">ROM:8449 TAY</span><br><span class="line">ROM:844A LDA $8B16,Y</span><br><span class="line">ROM:844D LDY byte_A9</span><br><span class="line">ROM:844F STA $455,Y</span><br><span class="line">ROM:8452 INC byte_A9</span><br><span class="line">ROM:8454 PLA</span><br><span class="line">ROM:8455 TAY</span><br><span class="line">ROM:8456 BMI loc_845D</span><br><span class="line">ROM:8458 LDA ($87),Y</span><br><span class="line">ROM:845A JMP loc_845F</span><br><span class="line">ROM:845D ; ---------------------------------------------------------------------------</span><br><span class="line">ROM:845D</span><br><span class="line">ROM:845D LDA ($89),Y</span><br><span class="line">ROM:845F</span><br><span class="line">ROM:845F TAY</span><br><span class="line">ROM:8460 BPL loc_8471 ; что-то типа записи в столбик, из которого будет перенос в видеопамять</span><br><span class="line">ROM:8462 LDA ($95),Y</span><br><span class="line">ROM:8464 STA $40D,X</span><br><span class="line">ROM:8467 LDA ($99),Y</span><br><span class="line">ROM:8469 STA $40E,X</span><br><span class="line">ROM:846C LDA ($71),Y</span><br><span class="line">ROM:846E JMP loc_847D</span><br><span class="line">ROM:8471 ; ---------------------------------------------------------------------------</span><br><span class="line">ROM:8471</span><br><span class="line">ROM:8471 LDA ($93),Y ; что-то типа записи в столбик, из которого будет перенос в видеопамять</span><br><span class="line">ROM:8473 STA $40D,X</span><br><span class="line">ROM:8476 LDA ($97),Y</span><br><span class="line">ROM:8478 STA $40E,X</span><br><span class="line">ROM:847B LDA ($6F),Y</span><br><span class="line">ROM:847D</span><br><span class="line">ROM:847D AND #3</span><br><span class="line">ROM:847F TAY</span><br><span class="line">ROM:8480 LDA $8B16,Y</span><br><span class="line">ROM:8483 LDY byte_A9</span><br><span class="line">ROM:8485 STA $455,Y</span><br><span class="line">ROM:8488 INC byte_A9</span><br><span class="line">ROM:848A INX</span><br><span class="line">ROM:848B INX</span><br><span class="line">ROM:848C INX</span><br><span class="line">ROM:848D INX</span><br><span class="line">ROM:848E DEC byte_3F0 ; кол-во повторов считывания</span><br><span class="line">ROM:8491 BMI loc_84BE ; выход из копирования столбца</span><br><span class="line">ROM:8493 LDA xcoord ; x-координата столбца</span><br><span class="line">ROM:8496 INC xcoord</span><br><span class="line">ROM:8499 CMP #2</span><br><span class="line">ROM:849B BCS loc_84A1</span><br><span class="line">ROM:849D LDA #0</span><br><span class="line">ROM:849F BEQ loc_84B0</span><br><span class="line">ROM:84A1</span><br><span class="line">ROM:84A1 BIT byte_12</span><br><span class="line">ROM:84A3 BPL loc_84AD</span><br><span class="line">ROM:84A5 LDA xcoord</span><br><span class="line">ROM:84A8 CMP byte_36F</span><br><span class="line">ROM:84AB BCS loc_84C1</span><br><span class="line">ROM:84AD</span><br><span class="line">ROM:84AD LDA xshift_cycle60</span><br><span class="line">ROM:84B0</span><br><span class="line">ROM:84B0 CLC</span><br><span class="line">ROM:84B1 ADC byte_A3</span><br><span class="line">ROM:84B3 STA byte_A3</span><br><span class="line">ROM:84B5 LDA byte_A4</span><br><span class="line">ROM:84B7 ADC #0</span><br><span class="line">ROM:84B9 STA byte_A4</span><br><span class="line">ROM:84BB JMP loc_841A ; повтор загрузки</span><br></pre></td></tr></table></figure><p>Этот кусок кода и есть функция- комбинатор . Она показывает связь между предэкраном и экраном . Новые важные переменные здесь <code>$366 (x_shift_cycle)</code> - насколько сдвигаться за один шаг цикла считывания, похоже на разницу между строками, то есть ширину всего уровня;<br><code>xcoord</code> - число повторов выборки, постоянно равно 5, от есть считывается по 4 тайла 5 раз = 20 раз - один столбец на экране. <code>$A2-$A3</code> - пара ячеек, в которых написан изначальный индекс, от которого проводится измерение. </p><p>Разбираться откуда он берется пока не обязательно, можно посмотреть первый попавшийся и начать написание функции-комбинатора, которая будет делать то же самое, что и приведенный выше кусок кода на ассемблере.</p><p><strong>Шаг 0x0B.</strong></p><p>Реализация комбинатора на питоне:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">get4Lines</span><span class="params">(begin,end, levelSet, a3a4, step, vertCount)</span>:</span></span><br><span class="line">  cycleBegin = begin</span><br><span class="line">  cycleEnd   = end</span><br><span class="line">  a3a4ind = begin/<span class="number">4</span></span><br><span class="line">  line4 = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xrange(cycleBegin,cycleEnd):</span><br><span class="line">    <span class="keyword">if</span> x%<span class="number">4</span>==<span class="number">0</span>:</span><br><span class="line">      a3a4ind += <span class="number">1</span></span><br><span class="line">    b83,b85,b87,b89 = getLevelSetForCycle(levelSet, b8x_inds,(x+<span class="number">2</span>)%<span class="number">4</span>)</span><br><span class="line">    b93,b95,b97,b99 = getLevelSetForCycle(levelSet, b9x_inds,(x+<span class="number">2</span>)%<span class="number">4</span>)</span><br><span class="line">    line4.extend(makeLine(a3a4, a3a4ind, b83,b85,b87,b89, b93,b95,b97,b99, step, vertCount))</span><br><span class="line">  <span class="keyword">return</span> line4</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeLine</span><span class="params">(a3a4, a3a4BaseInd, b83,b85,b87,b89, b93,b95,b97,b99, step, vertCount)</span>:</span></span><br><span class="line">  a3a4ind = a3a4BaseInd</span><br><span class="line">  lines = []</span><br><span class="line">  <span class="keyword">for</span> globalRepeat <span class="keyword">in</span> xrange(vertCount): <span class="comment">##5(screen size)</span></span><br><span class="line">    predInd = a3a4[a3a4ind]</span><br><span class="line">    ind2a,ind2b = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> predInd&lt;<span class="number">128</span>:</span><br><span class="line">      ind2a = b83[predInd]</span><br><span class="line">      ind2b = b87[predInd]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      ind2a = b85[predInd]</span><br><span class="line">      ind2b = b89[predInd]</span><br><span class="line"> </span><br><span class="line">    res = [<span class="number">-1</span>]*<span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> ind2a&lt;<span class="number">128</span>:</span><br><span class="line">      res[<span class="number">0</span>],res[<span class="number">1</span>] = b93[ind2a], b97[ind2a]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      res[<span class="number">0</span>],res[<span class="number">1</span>] = b95[ind2a], b99[ind2a]</span><br><span class="line">    <span class="keyword">if</span> ind2b&lt;<span class="number">128</span>:</span><br><span class="line">      res[<span class="number">2</span>],res[<span class="number">3</span>] = b93[ind2b], b97[ind2b]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      res[<span class="number">2</span>],res[<span class="number">3</span>] = b95[ind2b], b99[ind2b]</span><br><span class="line">    lines.extend(res)</span><br><span class="line">    a3a4ind+=step</span><br><span class="line">  <span class="keyword">return</span> lines</span><br><span class="line"> </span><br><span class="line">b8x_inds = [[<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>], [<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">6</span>], [<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>], [<span class="number">11</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>]]</span><br><span class="line">b9x_inds = [[<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">13</span>], [<span class="number">14</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">15</span>], [<span class="number">16</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">17</span>], [<span class="number">18</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">19</span>]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLevelSetForCycle</span><span class="params">(levelSet,indsConst,loop)</span>:</span></span><br><span class="line">  inds = map (<span class="keyword">lambda</span> v: v[loop], indsConst)</span><br><span class="line">  <span class="keyword">return</span> map (<span class="keyword">lambda</span> i: levelSet[i], inds)</span><br></pre></td></tr></table></figure></p><p>Набор данных можно выхватить прямо из дампа памяти: </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepareBinary</span><span class="params">(binaryDump, addrBegin, addrLen, outName)</span>:</span></span><br><span class="line">f = open(binaryDump,<span class="string">"rb"</span>)</span><br><span class="line">byt = f.read()</span><br><span class="line">f.close()</span><br><span class="line">bb = byt[addrBegin:addrBegin+addrLen]</span><br><span class="line">f =open(outName,<span class="string">"wb"</span>)</span><br><span class="line">f.write(bb)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>Дальше можно проверить отрисовку и убедиться, нарисовалась полоса уровня высотой в 20 клеток.</p><p><strong>Шаг 0x0C.</strong></p><p>Экспериментируя с параметрами <code>A2A3</code> и значением <code>vertCount</code> можно получать разные срезы уровня, например, такой:<br><a href="http://pics.livejournal.com/spiiin/pic/0001xwst/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0001xwst" alt=""></a></p><p>По нему можно прикинуть, откуда начинается мусор, и как конец уровня связан с началом по высоте и вычислить правильное значение <code>A2A3</code> соответствуюшее началу уровня (и в итоге заметить, что оно на 1 меньше, чем адрес в <code>$47-$48</code> (это первое значение из набора ), то есть равно первому значению и набора - 1).</p><p>Также можно обратить внимание, что рядом с шириной уровня ($366) в ячейке $367 лежит и его ширина).</p><p>Тогда можно вывести полную схему работы комбинатора:<br><a href="http://pics.livejournal.com/spiiin/pic/0001y71x/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0001y71x/s640x480" alt=""></a></p><p>и написать универсальную функцию рисования:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeJob</span> <span class="params">(binaryName, spritesName, addr, baseAddrSet, w,h, levelNo)</span>:</span></span><br><span class="line">  tempName1 = binaryName+<span class="string">".a2a3."</span>+str(levelNo)+<span class="string">".bin"</span></span><br><span class="line"> </span><br><span class="line">  imNameTable = Image.open(spritesName)</span><br><span class="line">  nameSize = imNameTable.size</span><br><span class="line">  nameTable = [imNameTable.crop((x,y,x+<span class="number">8</span>,y+<span class="number">8</span>)) <span class="keyword">for</span> y,x <span class="keyword">in</span> itertools.product(xrange(<span class="number">0</span>,nameSize[<span class="number">1</span>],<span class="number">8</span>),xrange(<span class="number">0</span>,nameSize[<span class="number">0</span>],<span class="number">8</span>))]</span><br><span class="line">  sprites = map (<span class="keyword">lambda</span> im: PpuSprite(im),nameTable) </span><br><span class="line"> </span><br><span class="line">  prepareBinary(binaryName, addr, <span class="number">0x2000</span>, tempName1)</span><br><span class="line">  a3a4 = parseBinData256(tempName1)</span><br><span class="line"> </span><br><span class="line">  prepareBinaries(binaryName, baseAddrSet)</span><br><span class="line">  levelSet = map(loadLevelSetElement, baseAddrSet)</span><br><span class="line">  ll = get4Lines(<span class="number">0</span>,w*<span class="number">4</span>, levelSet, a3a4, w,h)</span><br><span class="line">  drawLevelFromData(ll, sprites,(w*<span class="number">4</span>,h*<span class="number">4</span>),<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure><p>(уровень определяется - дампом памяти, набором адресов, размерами (ширина и высота) и картой тайлов).</p><p>Этой функцией можно нарисовать любой уровень:<br>Уровень 1.<br><a href="http://pics.livejournal.com/spiiin/pic/0001zdhq/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0001zdhq/s640x480" alt="1"></a><br>Уровень 2.<br><a href="http://pics.livejournal.com/spiiin/pic/00020r8e/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/00020r8e/s640x480" alt="2"></a><br>Уровень 3.<br><a href="http://pics.livejournal.com/spiiin/pic/0002115d/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0002115d/s640x480" alt="3"></a><br>Уровень 4.<br><a href="http://pics.livejournal.com/spiiin/pic/000228yk/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/000228yk/s640x480" alt="4"></a><br>Уровень 5.<br><a href="http://pics.livejournal.com/spiiin/pic/00023f84/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/00023f84/s640x480" alt="5"></a><br>Уровень 6.<br><a href="http://pics.livejournal.com/spiiin/pic/00024g9r/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/00024g9r/s640x480" alt="6"></a><br>Уровень 7.<br><a href="http://pics.livejournal.com/spiiin/pic/00025e0b/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/00025e0b/s640x480" alt="7"></a><br>Уровень 8.<br><a href="http://pics.livejournal.com/spiiin/pic/00026hc9/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/00026hc9/s640x480" alt="8"></a><br>Уровень 9.<br><a href="http://pics.livejournal.com/spiiin/pic/000277fy/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/000277fy/s640x480" alt="9"></a><br>Уровень 10. <a href="http://pics.livejournal.com/spiiin/pic/00028s1z/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/00028s1z/s640x480" alt="10"></a><br><a href="http://pastebin.com/e4qedf4X" target="_blank" rel="noopener">Код скрипта</a> (использовался больше в интерактивном режиме)</p><p> <em>//Если что-то долго ломать, то оно сломается.</em></p><p> <strong>Конец</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Шаг 0x0A.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Остается последний шаг, чтобы связать результаты анализа снизу (от экрана к набору) и сверху (от набор
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>Уровни Jungle Book [NES]. Часть 1.</title>
    <link href="http://spiiin.github.io/blog/41044/"/>
    <id>http://spiiin.github.io/blog/41044/</id>
    <published>2011-10-19T21:07:00.000Z</published>
    <updated>2020-09-15T21:41:14.636Z</updated>
    
    <content type="html"><![CDATA[<p><em>//Лучший способ научиться программированию - взять дизассемблер и посмотреть, как это делают другие.</em>  </p><p><strong>Шаг 0xFF.</strong><br>Когда-то давно у меня было несколько выпусков журнала <a href="http://lurkmore.ru/%D0%92%D0%B5%D0%BB%D0%B8%D0%BA%D0%B8%D0%B9_D%D1%80%D0%B0%D0%BA%D0%BE%D0%BD" target="_blank" rel="noopener">“Великий Дракон”</a>, в которых были опубликованы карты уровней из “Утиных историй”. Но только там были швы на границах сшитых скриншотов и на каждом экране была копия Скруджа. Я вспомнил про эти карты и подумал, что было бы неплохо научиться вырывать из картриджа с игрой карты уровней в том формате, в котором они там и записаны. Технически это, конечно, немножко сложнее, чем слепливать скриншоты, но зато можно разобраться с методикой. В каждой игре используется свой способ хранения (разве что может у игр с одинаковым движком будет одинаковый формат), но можно выделить общие действия.  </p><p><strong>Шаг 0x00.</strong><br>Кроме обучения, можно использовать результат и в практических целях:  </p><ul><li>Планирование способов прохождения.  </li><li>Наглядная подсказка.  </li><li>Обнаружение неизвестных ранее секретных зон.  </li><li>Анализ дизайна уровней.  </li><li>Пиратское копирование уровней или графики в другую игру.  </li><li>Модификация уровня и/или создание редактора уровней.  </li><li>Распечатывание и развешивание на стены в качестве обоев.  </li></ul><p>Но карты для Duck Tales мне были не особо нужны, потому что они не особо запутанные и спустя годы я все равно помню все секретные проходы и оптимальные пути и сомневаюсь в наличии неизвестных ранее сокровищ и секретов, еще не открытых обычными геймерами. Поэтому интереснее выбрать игру с лабиринтами, в которых можно заблудиться и ограничено время, за которое необходимо найти выход. Из известных мне игр на NES сходу вспомнились Jungle Book и Alien 3. Маугли повезло больше, поэтому я стал рипать уровни из рома Jungle Book[E].nes.  </p><p>Под катом спрятано техническое описание процесса вырезания и сами карты.  </p><p><strong>Шаг 0x01.</strong><br>Необходимые инструменты - эмулятор NES со встроенным отладчиком и просмотром состояния памяти консоли (<a href="http://www.the-interweb.com/serendipity/index.php?/categories/9-FCEUXD-SP" target="_blank" rel="noopener">FCEUXSP</a>), дизассемблер, бумага и ручка. Также очень не помешает знание какого-нибудь языка программирования, чтобы автоматизировать рассчеты, так как считать и рисовать придется довольно много.  </p><p><strong>Шаг 0x02.</strong><br>Отрисовка графики фона на NES.<br>Консоль умеет рисовать бекграунд и до тридцати двух спрайтов. Чтобы вывести полноэкранный бекграунд, необходимо выключить вывод фона видеопроцессором, и записать в видеопамять по адресу $2000 960 байт. Каждый байт означает номер тайла размером 8х8 в знакогенераторе (в знакогенератор загружается 1 блок графики из картриджа размером в 4 килобайта, который содержит 256 инонок-тайлов, по 2 бита на пиксел). Так выкладывается 30 строк по 32 элемента.<br>Далее по адресам $23C0-$23FF в видеопамять записывается 64 байта атрибутов и каждому квадрату размером 2х2 тайла приписывается еще 2 бита цвета из атрибута. С помощью этого можно подкрасить двухбитовые пикселы тайлов до четырехбитовых. Эти 4 бита являются индексом в палитре, которая позволяет выбрать 16 цветов из 64 поддерживаемых видеопроцессором. Палитра расположена по адресу $3F00. Далее необходимо снова включить отрисовку фона и видеопроцессор обновит картинку на экране. Кроме того, через регистры процессора можно скроллить фоновую картинку по горизонтали и вертикали, поэтому чтобы передвинуть бекграунд вправо или влево, необязательно перерисовывать всю картинку целиком, достаточно включить аппаратный скроллинг и дорисовывать только новые столбы и строки.<br>Управление видеопроцессором осуществляется записью по определенным адресам CPU.<br>Подробнее про отрисовку можно почитать в <a href="http://dendy.migera.ru/" target="_blank" rel="noopener">доке Migera</a>.  </p><p><strong>Шаг 0x03.</strong><br>Эмулятор FCEUXSP умеет отображать содержимое знакогенератора и текущую палитру (Tools-&gt;PPU Viewer), содержимое экранной страницы (Tools-&gt;Name Table Viewer), либо просто просматривать видеопамять (Tools-&gt;Hex Editor, View-&gt;Ppu memory). Еще встроенный отладчик позволяет ставить точки остановки на запись в видеопамять, и можно начать процесса взлома с того, чтобы поставить точку остановки на запись в видеопамять в диапазоне $2000-$23BF (то есть любое обновление экрана). Точка остановки срабатывает от нажатия на кнопку старт в главном меню игры до запуска первого уровня несколько раз, поэтому включать её стоит, когда уровень уже начался, чтобы поймать только обновление экрана.<br>Остановка сработает в тот момент, когда экран сдвинется вправо или влево и отладчик покажет адрес выполнения $E38C (инструкция STA $2007). В этот момент следует сделать дамп памяти Tools-&gt;Hex View и загрузить его в дизассемблер. Как это делается, хорошо описано <a href="http://griever.magicteam.net/doc/?doc=NES_IDA" target="_blank" rel="noopener">здесь</a>.<br>Новые дампы памяти надо делать каждый раз, когда в отладчике обнаруживается, что данные в области ROM’а (от $8000 до $FFFF) отличаются от тех, что видны в дизассемблере. Это происходит потому, что на картридже могут иметься несколько банков памяти, которые подставляются в адресное пространство процессора (вроде бы плоское), добавляя ему второе измерение. Про переключение банков я знаю пока мало, для этого надо вчитываться в доки по мапперам, а некоторые из них еще нерасшифрованы полностью, поэтому отслеживаю соотвествие кода в дампе тому, что отображает просмотрщик памяти в эмуляторе.<br>Функция, на которой остановился отладчик - горизонтальный скроллинг экрана, дорисовка нового столбца слева или справа. Данные копируются из оперативной памяти по адресу $040D и дальше в видеопамять.  </p><p><strong>Шаг 0x04.</strong><br>Точка остановки переставляется на запись в адреса около $040D и срабатывает при очередном горизонтальном скроллинге, когда Маугли бежит вперед.<br>ROM:8462 LDA ($95),Y<br>ROM:8464 STA $40D,X<br>ROM:8467 LDA ($99),Y<br>ROM:8469 STA $40E,X<br>ROM:846C LDA ($71),Y<br>ROM:846E JMP loc_847D<br>ROM:8471 ; —————————————————————————————————————-<br>ROM:8471 LDA ($93),Y ; что-то типа записи в столбик, из которого будет перенос в видеопамять<br>ROM:8473 STA $40D,X<br>ROM:8476 LDA ($97),Y<br>ROM:8478 STA $40E,X<br>ROM:847B LDA ($6F),Y  </p><p>Столбик заполняется данными из адресов, записанных либо в ячейки 95-96 и 98-99, либо в ячейки 93-94 и 97-98. Такая адресация - злейший враг для хакера по двум причинам. Во-первых, чтобы проверить, какие адреса находятся в нулевой странице (по адресам $00-$FF, нужно каждый раз смотреть их в дизассемблере, что добавляет в код третье измерение и сильно усложняет восприятие, а во-вторых, брейкпоинты на чтение, поставленные на нулевую страницу, не работают, так как чтение значения из нее не производится, а происходит вычисление адреса относительно того, что записано в эти ячейки памяти.<br>Я проверяю, что за адреса лежат в этих ячейках памяти на каждом шаге в поисках закономерности - каждые 4 шага адреса повторяются, но это не позволяет разобраться, откуда они берутся.  </p><p><strong>Шаг 0x05.</strong><br>Дальше проверяю то, откуда берутся адреса в ячейках 93-98. Брейкнулся в кусок функции:<br>ROM:856B LDY $DD88,X<br>ROM:856E LDA 0,Y<br>ROM:8571 STA byte_83<br>ROM:8573 LDA 1,Y<br>ROM:8576 STA byte_84<br>ROM:8578 LDA 4,Y<br>ROM:857B STA byte_85<br>ROM:857D LDA 5,Y<br>ROM:8580 STA byte_86<br>ROM:8582 LDY $DD8C,X<br>ROM:8585 LDA 0,Y<br>ROM:8588 STA byte_87<br>ROM:858A LDA 1,Y<br>ROM:858D STA byte_88<br>ROM:858F LDA 4,Y<br>ROM:8592 STA byte_89<br>ROM:8594 LDA 5,Y<br>ROM:8597 STA byte_8A<br>ROM:8599 LDY $DD90,X<br>ROM:859C LDA 0,Y<br>ROM:859F STA byte_93<br>ROM:85A1 LDA 1,Y<br>ROM:85A4 STA byte_94<br>ROM:85A6 LDA 4,Y<br>ROM:85A9 STA byte_95<br>ROM:85AB LDA 5,Y<br>ROM:85AE STA byte_96<br>ROM:85B0 LDY $DD94,X<br>ROM:85B3 LDA 0,Y<br>ROM:85B6 STA byte_97<br>ROM:85B8 LDA 1,Y<br>ROM:85BB STA byte_98<br>ROM:85BD LDA 4,Y<br>ROM:85C0 STA byte_99<br>ROM:85C2 LDA 5,Y<br>ROM:85C5 STA byte_9A<br>ROM:85C7 RTS  </p><p>Отсюда видно, что в роме (область $DDxx - уже области памяти картриджа) есть массивы указателей, которыми индексируется какие-то ячейки оперативной памяти (какие именно показывает регистр Y), и данные из этих ячеек переносятся дальше. Тут непонятно, откуда берется X и Y, но вместо дальнейшего реверс-анализа я смотрю их изменение во времени при нескольких последовательных скроллингах. X меняется последовательно от 0 до 3, а Y не совсем понятно как, но адреса находятся примерно в диапазоне $60-$80. Много их там быть не может, потому что эта область - оперативная память и расходовать ее много нельзя ввиду ее небольшого размера. Поэтому лучше ставить точки остановки на как можно меньшее число адресов в этой зоне, так как иногда одна и та же ячейка может за один кадр использоваться в разных целях (например для рассчета позиций врагов). Так что в качестве следующей точки остановки выбрал ячейки $67-$68  </p><p><strong>Шаг 0x06.</strong><br>Следующая остановка показывает, что запись в эти ячейки производится 1 раз при старте уровня (сразу после затухания экрана LEVEL 1 GET READY) по адресу $F542 (STA 0047,Y). Сделав в отладчике step out , доходим до выхода из функции, засекаем ее начало и делаем дамп памяти, чтобы засунуть его в дизассемблер. Это - функция загрузки уровня. По адресу 35D хранится номер уровня, служащий индексом для таблицы смещений , где лежит набор адресов, копирующих в набор - диапазон 47-82.<br>ROM:F52F LDA byte_35D ; взять номер уровня<br>ROM:F532 ASL A ; (адрес занимает 2 байта)<br>ROM:F533 TAX<br>ROM:F534 LDA $F71A,X ; загрузить из F71A адрес начала таблицы смещений уровня<br>ROM:F537 STA byte_21<br>ROM:F539 LDA $F71B,X<br>ROM:F53C STA byte_22<br>ROM:F53E LDY #$3B ; ‘;’<br>ROM:F540 LDA ($21),Y ; копирование адреса в набор 47-82 для уровня<br>ROM:F542 STA $47,Y<br>ROM:F545 DEY<br>ROM:F546 BPL loc_F540 ; копирование адреса в набор 47-82 для уровня<br>ROM:F548 LDY #$46 ; ‘F’ ; дальше еще полкилобайта какого-то кода  </p><p>Чуть про философию реверса - выбор названий для переменных здесь намного важнее, чем в обычном программировании, потому что, разбираясь с кодом алгоритма, изначально есть только адреса, по сути анонимные переменные , по аналогии с анонимными функциями. А воспринимаемый набор действий над такими переменными без названия имеет только образ, без определения. Мысленно можно построить только граф выполнения, временную развертку команд над адресами. Распознавание в командах действий позволяет заменить граф последовательностью функций, а распознавание назначения адресов - разделить безымянное адресное пространство на области, имеющие определенное предназначение. Чтобы привести алгоритм к известному, надо подобрать такие названия областей, чтобы по ним было понятно их содержимое. Ну и необходимо помнить, что ввиду малого количества памяти эти области могут перекрываться и использоваться в различных целях, то есть в данном месте значения в ячейках 42-83 являются набором стартовых адресов при загрузке уровня, а по окончании уже могут быть например, количеством набранных за уровень очков или еще чем-нибудь.  </p><p><strong>Шаг 0x07.</strong><br>Начиная с обнаружения функции загрузки, можно не лезть дальше вглубь в сам ROM, а расшифровать ее, то есть понять назначение ячеек, в которые считываются данные. Здесь стоит подумать, что именно необходимо искать. Из предыдущего опыта разбора игровых данных в  <a href="http://spiiin.livejournal.com/38881.html" target="_blank" rel="noopener">Охотниках за привидениями</a> , я запомнил, что запись об уровне может иметь сложный формат, содержать вперемежку код логики игровых событий и данные. Так что, скорее всего, здесь тоже применяется какой-нибудь метод для сжатия игровых данных. Так что при анализе вверх от данных из рома к видеопамяти придется разобраться еще с функцией расшифровки данных и сэмулировать ему на каком-нибудь языке. Однако и возможность того, что данные лежат целым блоком, тоже есть. Так что стоит придумать способ отрисовки картинки уровня по какому-либо набору данных. Чтобы найти этот набор, можно взять любой адрес начала записи об уровне и попытаться разделить в нем код и данные. Правило визуального отделения данных и кодов - данные обладают когерентностью (соседние похожи между собой), коды - не обладают. Еще можно узнавать шаблоны кодов (зная коды команд, содержащих в операнде непосредственный адрес (jmp и lda с некоторыми типами адресаций) + код rts для конца функций, можно находить в коде адреса, и попробовать ассемблировать эти куски в дизассемблере). Вообщем, даже если начать рисовать смесью кодов и данных, то все равно можно найти какой-то осмысленный кусок и понять структуру. Так что дальше надо написать программу рисования и скормить ей все данные об уровне.<br>Как было сказано выше, для получения этих данных можно не лезть глубже, а начать вместо обратного просмотра прямой, отслеживая данные от момента считывания из РОМа в зону 47-82 ( набор ) до попадания прямо на экран.<br>Начинаем выныривать.<br>ROM:F71A .WORD $B6E3 ; адреса начала смещений уровней и бонусных зон (всего по 72, хотя под карту юзаются 59, дальше что-то еще).<br>ROM:F71C .WORD $B72B<br>ROM:F71E .WORD $B773<br>ROM:F720 .WORD $B7BB<br>ROM:F722 .WORD $B803<br>ROM:F724 .WORD $B84B<br>ROM:F726 .WORD $B893<br>ROM:F728 .WORD $B8DB<br>ROM:F72A .WORD $B923<br>ROM:F72C .WORD $B96B<br>ROM:F72E .WORD $BBAB<br>ROM:F730 .WORD $BB63<br>ROM:F732 .WORD $B9B3<br>ROM:F734 .WORD $B9FB<br>ROM:F736 .WORD $BA43<br>ROM:F738 .WORD $BA8B<br>ROM:F73A .WORD $BAD3<br>ROM:F73C .WORD $BB1B<br>ROM:F73E .WORD $BBAB  </p><p><strong>Шаг 0x08.</strong><br>Скрипт рисования. На питоне, для работы с изображениями нужна библиотека <a href="http://www.pythonware.com/products/pil/" target="_blank" rel="noopener">PIL</a>.  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Класс инкапсулирует данные об одном тайле и позволяет сравнить тайлы с учетом палитры.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PpuSprite</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, im)</span>:</span></span><br><span class="line">     self.image = im</span><br><span class="line">     self.imageData = im.getdata()</span><br><span class="line">     self.colorTable = im.getcolors()</span><br><span class="line">     self.colorTable.sort()</span><br><span class="line">     self.firstColorsPos = [] </span><br><span class="line">     self.calcFirstColorsPoses()</span><br><span class="line">     self.indexedData = []</span><br><span class="line">     self.prepareIndexedData()</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">calcFirstColorsPoses</span><span class="params">(self)</span>:</span>        </span><br><span class="line">     <span class="keyword">for</span> _,colorInPalette <span class="keyword">in</span> self.colorTable:</span><br><span class="line">       firstColorPos = <span class="number">-1</span></span><br><span class="line">       <span class="keyword">for</span> color <span class="keyword">in</span> self.imageData:</span><br><span class="line">         firstColorPos+=<span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> color == colorInPalette:</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       self.firstColorsPos.append((firstColorPos,colorInPalette))</span><br><span class="line">     self.firstColorsPos.sort()</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">prepareIndexedData</span><span class="params">(self)</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">calcColorHash</span><span class="params">(c)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> c[<span class="number">0</span>]&lt;&lt;<span class="number">16</span> | c[<span class="number">1</span>]&lt;&lt;<span class="number">8</span> | c[<span class="number">2</span>]</span><br><span class="line">     colorHashes = map (<span class="keyword">lambda</span> colorRec : calcColorHash(colorRec[<span class="number">1</span>]), self.firstColorsPos)</span><br><span class="line">     <span class="keyword">for</span> pixel <span class="keyword">in</span> self.imageData:</span><br><span class="line">       pixelHash = calcColorHash(pixel)</span><br><span class="line">       colorIndex = <span class="number">-1</span></span><br><span class="line">       <span class="keyword">for</span> colorHash <span class="keyword">in</span> colorHashes:</span><br><span class="line">         colorIndex +=<span class="number">1</span></span><br><span class="line">         <span class="keyword">if</span> pixelHash == colorHash:</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       self.indexedData.append(colorIndex)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span><span class="params">(self, otherPpuSprite)</span>:</span></span><br><span class="line">     <span class="keyword">if</span> len(self.firstColorsPos) != len(otherPpuSprite.firstColorsPos):</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">for</span> fcp1, fcp2 <span class="keyword">in</span> zip(self.firstColorsPos, otherPpuSprite.firstColorsPos):</span><br><span class="line">       <span class="keyword">if</span>  fcp1[<span class="number">0</span>]!= fcp2[<span class="number">0</span>]:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">if</span> len(self.colorTable) != len(otherPpuSprite.colorTable):</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">for</span> colorTableRec1, colorTableRec2 <span class="keyword">in</span> zip(self.colorTable, otherPpuSprite.colorTable):</span><br><span class="line">       <span class="keyword">if</span> colorTableRec1[<span class="number">0</span>] != colorTableRec2[<span class="number">0</span>]:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">for</span> pixel1, pixel2 <span class="keyword">in</span> zip(self.indexedData, otherPpuSprite.indexedData):</span><br><span class="line">       <span class="keyword">if</span> pixel1!=pixel2:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>Дальше следует захватить из эмулятора блок с тайлами текущего уровня и распилить его на кусочки. FCEUXSP позволяет только посмотреть этот блок (View-&gt;Name Table View), но можно заскриншотить его и вырезать в любом графическом редакторе. Вот так выглядит блок для первого уровня:<br><img src="http://pics.livejournal.com/spiiin/pic/0001tbpp" alt=""><br>Только надо помнить, что эмулятор показывает блок увеличенным в 2 раза, поэтому надо в редакторе уменьшить его до размера 128x128, убедившись, что при уменьшении не используются никакие алгоритмы улучшения качества, так как нужно получить попиксельное совпадение. Дальше из этой картинки можно нарезать тайлы:  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imNameTable = Image.open(os.path.expanduser(<span class="string">"~/desktop/jungleBook/jungleBookTable1.png"</span>))   <span class="comment">#сохраненная таблица тайлов.</span></span><br><span class="line">imLevelTable = Image.open(os.path.expanduser(<span class="string">"~/desktop/jungleBook/jungleBookLevel1.png"</span>))  <span class="comment">#любой скриншот уровня, загружается для теста</span></span><br><span class="line">nameSize = imNameTable.size</span><br><span class="line">levelSize = imLevelTable.size</span><br><span class="line">nameTable = [imNameTable.crop((x,y,x+<span class="number">8</span>,y+<span class="number">8</span>)) <span class="keyword">for</span> y,x <span class="keyword">in</span> itertools.product(xrange(<span class="number">0</span>,nameSize[<span class="number">1</span>],<span class="number">8</span>),xrange(<span class="number">0</span>,nameSize[<span class="number">0</span>],<span class="number">8</span>))]</span><br><span class="line">levelTable = [imLevelTable.crop((x,y,x+<span class="number">8</span>,y+<span class="number">8</span>)) <span class="keyword">for</span> y,x <span class="keyword">in</span> itertools.product(xrange(<span class="number">0</span>,levelSize[<span class="number">1</span>],<span class="number">8</span>),xrange(<span class="number">0</span>,levelSize[<span class="number">0</span>],<span class="number">8</span>))]</span><br><span class="line">ppuSpriteMemTable = map (<span class="keyword">lambda</span> im: PpuSprite(im),nameTable) </span><br><span class="line">ppuSpriteLvlTable = map (<span class="keyword">lambda</span> im: PpuSprite(im),levelTable)</span><br></pre></td></tr></table></figure><p>Функция отрисовки по массиву тайлов (принимает линейный массив данных, таблицу спрайтов, размер уровня и флажок, построчно или постолбцово рисовать, возврашает экземляр класс PIL Image):  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawLevelFromData</span><span class="params">(levelArray, ppuSpriteTable, size, vertical = False)</span>:</span></span><br><span class="line">  w,h = size</span><br><span class="line">  im = Image.new(<span class="string">"RGBA"</span>, (w*<span class="number">8</span>,h*<span class="number">8</span>))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(levelArray)):</span><br><span class="line">    <span class="keyword">if</span> vertical:</span><br><span class="line">      x,y = i/h, i%h</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      x,y = i%w, i/w</span><br><span class="line">    ind = levelArray[i]</span><br><span class="line">    <span class="keyword">if</span> (ind!=<span class="number">-1</span>):</span><br><span class="line">      im.paste(ppuSpriteTable[ind].image, (x*<span class="number">8</span>,y*<span class="number">8</span>,x*<span class="number">8</span>+<span class="number">8</span>,y*<span class="number">8</span>+<span class="number">8</span>))</span><br><span class="line">  <span class="keyword">return</span> im</span><br></pre></td></tr></table></figure><p>Чтобы проверить программу рисования и корректность сравнения по индексированным цветам, превратим скриншот уровня в данные и отдадим этой функции.  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findFirstPicIndex</span><span class="params">(sprite, ppuSpriteTable)</span>:</span></span><br><span class="line">  index = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">for</span> ppuSprite <span class="keyword">in</span> ppuSpriteTable:</span><br><span class="line">    index+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ppuSprite.isEqual(sprite):</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeLevelMap</span><span class="params">(mem, lev)</span>:</span></span><br><span class="line">  levTable = []</span><br><span class="line">  <span class="keyword">for</span> l <span class="keyword">in</span> lev:</span><br><span class="line">    levTable.append(findFirstPicIndex(l, mem))</span><br><span class="line">  <span class="keyword">return</span> levTable</span><br><span class="line"> </span><br><span class="line">mapLevel = makeLevelMap(ppuSpriteMemTable, ppuSpriteLvlTable)</span><br><span class="line">drawLevelFromData(mapLevel, sprites,(WIDTH,HEIGHT),<span class="literal">True</span>).show()</span><br></pre></td></tr></table></figure><p>На выходе можно увидеть уровень, выглядящий примерно как рендер Матрицы на компьютере с недостаточной мощностью:<br><img src="http://pics.livejournal.com/spiiin/pic/0001w7zd" alt="">  </p><p><strong>Шаг 0x09.</strong><br>Дальше я попытался отрисовать данные уровня разными способами, ничего интересного не получил, и понял, что надо все-таки еще искать функцию-комбинатор, которые будет определять, как данные из набора попадают на экран . Набор смещений 47-82 для первого уровня по адресу $B6E3<br>A139 A739 DDC8 DDC8 DBF4<br>DC59 AA49 AAC0 DCBE DD23<br>AB37 ABAE D974 D9F4 A7C9<br>A849 DA74 DAF4 A8C9 A949<br>DB74 A9C9 BBF3 A825 A795<br>A765 A764 A766 A7F5 A7C5<br>Точка остановки на чтение этих значений. $8D62 в новом банке памяти (надо сделать еще один дамп), анализ кода там:<br>берем 4 бита шагов (2 горизонт, 2 вертикаль) и используем их как смещение от адреса DDA8<br>ROM:DDA8 .WORD $4F4F ; idle вторая часть (адреса из набора )<br>ROM:DDAA .WORD $5151<br>ROM:DDAC .WORD $4F4F<br>ROM:DDAE .WORD $5151<br>ROM:DDB0 .WORD $5757<br>ROM:DDB2 .WORD $5959<br>ROM:DDB4 .WORD $5757<br>ROM:DDB6 .WORD $5959<br>и переносим их в 8b-8e<br>потом повторно берем из DDB8 и переносим в 9b-9e:<br>ROM:DDB8 .WORD $615F ; idle вторая часть(адреса из набора )<br>ROM:DDBA .WORD $615F<br>ROM:DDBC .WORD $6967<br>ROM:DDBE .WORD $6967<br>ROM:DDC0 .WORD $615F<br>ROM:DDC2 .WORD $615F<br>ROM:DDC4 .WORD $6967<br>ROM:DDC6 .WORD $6967  </p><p>Это массив направлений , где хранится по 4 значения адресов из набора , которые будут скопированы по адресу предэкран (назовем так адреса 9B-9E и 8B-8E, потому что там лежат адреса массивов, из которых будут считаны номеры тайлов, попадающих в зону экрана $40E-$423).  </p><p><a href="http://spiiin.livejournal.com/43116.html" target="_blank" rel="noopener">Продолжение</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;//Лучший способ научиться программированию - взять дизассемблер и посмотреть, как это делают другие.&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Шаг 0xFF.&lt;
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>Бешик-Тау</title>
    <link href="http://spiiin.github.io/blog/61505/"/>
    <id>http://spiiin.github.io/blog/61505/</id>
    <published>2011-10-18T18:18:00.000Z</published>
    <updated>2020-09-15T21:05:22.856Z</updated>
    
    <content type="html"><![CDATA[<p>В воскресенье устроил своему велику боевое крещение и поехал в горы. 17 км, обалденный вид с вершины, костерок и сумасшедший спуск обратно, всю дорогу вниз. Самый конец сезона.  </p><p><a href="https://picasaweb.google.com/sanya.boyko/ZjIXBD" target="_blank" rel="noopener"><img src="https://lh6.googleusercontent.com/-YASKloEMwkg/TptTNFKu78I/AAAAAAAABx4/tmbYXveJbA4/s640/SAM_0141.JPG" alt=""></a> </p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;В воскресенье устроил своему велику боевое крещение и поехал в горы. 17 км, обалденный вид с вершины, костерок и сумасшедший спуск обратн
      
    
    </summary>
    
    
    
      <category term="photo" scheme="http://spiiin.github.io/tags/photo/"/>
    
  </entry>
  
  <entry>
    <title>Роберт Пирсиг. Дзен и искусство ухода за мотоциклом</title>
    <link href="http://spiiin.github.io/blog/25511/"/>
    <id>http://spiiin.github.io/blog/25511/</id>
    <published>2011-09-26T15:34:00.000Z</published>
    <updated>2020-09-15T21:37:21.073Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Мотоцикл -- это система. Настоящая система.</span><br><span class="line"></span><br><span class="line">Говорить об определенном правительстве и общественных институтах как о «системе» -- значит говорить верно, </span><br><span class="line">поскольку эти организации основаны на тех же структурных концептуальных отношениях, что и мотоцикл. </span><br><span class="line">Они поддерживаются структурными взаимоотношениями, даже когда сами потеряли иное предназначение и смысл. </span><br><span class="line">Люди приходят на фабрику и безо всяких вопросов выполняют абсолютно бессмысленное задание, поскольку структура требует,</span><br><span class="line">чтобы так было. Не существует никакого негодяя, никакого «гадкого типа», желающего, чтобы они жили бессмысленной жизнью,</span><br><span class="line">- просто структура, система требует этого, и никто не хочет взвалить на себя невыполнимую задачу изменить эту</span><br><span class="line">структуру только потому, что она бессмысленна. Но снести фабрику, взбунтоваться против правительства или отказаться</span><br><span class="line">чинить мотоцикл означает нападать скорее на следствия, нежели на причины; когда же нападают только на следствия, </span><br><span class="line">никакая перемена не возможна. Подлинная система, реальная система - суть наше настоящее строение самой систематической</span><br><span class="line">мысли, самой рациональности, и если фабрика снесена до основания, но рациональность, породившая ее на свет, осталась,</span><br><span class="line">то эта рациональность просто создаст еще одну фабрику. Если революция уничтожает систематическое правительство, </span><br><span class="line">остаются нетронутыми систематические шаблоны мышления, создавшие это правительство, и эти шаблоны воспроизведут себя</span><br><span class="line"> в последующем правительстве.</span><br><span class="line"></span><br><span class="line">Так много болтают о системе. И так мало понимают. </span><br><span class="line"></span><br><span class="line">Сборка японского велосипеда требует огромного душевного спокойствия.</span><br><span class="line"></span><br><span class="line">Единственный мотоцикл, который стоит чинить,- это вы сами</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Мотоцикл -- это система. Настоящая система.&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Tiny Castle</title>
    <link href="http://spiiin.github.io/blog/49345/"/>
    <id>http://spiiin.github.io/blog/49345/</id>
    <published>2011-09-10T15:17:00.000Z</published>
    <updated>2020-09-15T21:05:22.848Z</updated>
    
    <content type="html"><![CDATA[<p>Прикольный пример реиграбельности - игра с одним, постоянно меняющимся уровнем.<br><a href="http://pics.livejournal.com/spiiin/pic/0001s7eh/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0001s7eh/s640x480" alt=""></a><br><a href="http://www.nitrome.com/games/tinycastle" target="_blank" rel="noopener">http://www.nitrome.com/games/tinycastle</a>  </p><p>Еще несколько маленьких шедевров на сайте авторов:<br><a href="http://www.nitrome.com/games/steamlands/index.html" target="_blank" rel="noopener">http://www.nitrome.com/games/steamlands/index.html</a><br><a href="http://www.nitrome.com/games/chisel2/index.html" target="_blank" rel="noopener">http://www.nitrome.com/games/chisel2/index.html</a><br><a href="http://www.nitrome.com/games/officetrap/index.html" target="_blank" rel="noopener">http://www.nitrome.com/games/officetrap/index.html</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Прикольный пример реиграбельности - игра с одним, постоянно меняющимся уровнем.&lt;br&gt;&lt;a href=&quot;http://pics.livejournal.com/spiiin/pic/0001s7
      
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>1500 Archers on a 28.8 Kbps</title>
    <link href="http://spiiin.github.io/blog/51338/"/>
    <id>http://spiiin.github.io/blog/51338/</id>
    <published>2011-07-27T17:57:00.000Z</published>
    <updated>2020-09-15T21:05:22.846Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.gamasutra.com/view/feature/3094/1500_archers_on_a_288_network_.php" target="_blank" rel="noopener">http://www.gamasutra.com/view/feature/3094/1500_archers_on_a_288_network_.php</a> Статья о реализации сетевой игры в Age of Empires. Алгоритм подходит для всех сетевых игр. Основная идея – чтобы не ждать сообщений от всех игроков каждый ход, нужно реагировать на них с задержкой в 2 условных тика. То есть ставим себе нулевой ход, всем соперникам минус первый, собираем все события текущего хода, записываем их во очередь событий второго хода и отправляем в сеть, в то же время собирая сообщения соперников и записывая их в очередь либо для следующего хода, либо для следующего через один, в зависимости от того, кто быстрее отработал текущий ход. <img src="http://www.gamasutra.com/features/20010322/terrano_01.jpg" alt=""> Для быстрых клиентов за ход отрисовывается несколько кадров, для медленных – один. Если приходится долго стоять, ожидая одного или нескольких игроков, отстающих более чем на ход, остальные, пока ждут сообщений от отстающих, делают свой ход дольше, тогда для всех сообщений от быстрых игроков за этот ход необходимо ужать время в стандартный диапазон тика (их события произойдут “раньше”, чем от тех, кто лагает). При переходе на следующий ход все принятые сообщения из позапрошлого хода сортируются по времени их наступления и ход “проигрывается”, то есть сообщение выбирается из очереди только в ту фазу хода, когда оно должно произойти. Время тика где-то 50-200 миллисекунд. Получается довольно риалтаймово.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.gamasutra.com/view/feature/3094/1500_archers_on_a_288_network_.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.gamasut
      
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Objictive С tips</title>
    <link href="http://spiiin.github.io/blog/43611/"/>
    <id>http://spiiin.github.io/blog/43611/</id>
    <published>2011-07-11T16:40:00.000Z</published>
    <updated>2020-09-15T21:34:22.457Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. Смешивание языков.</strong> </p><p>Objective-C код совместим с сишным кодом, но не всегда совместим с С++.</p><p>Также существует язык Objective-C++, который позволяет более-менее свободно смешивать C++/Objective-C код. Компилятор gcc по умолчанию считает файлы с расширением .m содержащими код на Objective-C, а файлы с расширением .mm - код на языка Objictive-C++, но ему можно явно указать язык с помощью ключа -x В универсальных заголовочных файлах определить, в какой язык включается файл, можно, проверяя наличие макросимволов __OBJC__ или __cplusplus. </p><p>Чтобы вызывать Objective-C код из языка С++, удобнее всего сделать обычный С++-класс-обертку, содержащий членом указатель на класс Objective-C, так как наследование от него невозможно. </p><p>Если возможности создать класс нет (Objective-C, в отличие от Objective-C++, не дает возможности создавать C++-классы), то проще всего заворачивать вызовы в глобальные функции, и звать их из С++. При этом такие функции, как и обычные сишные, в С++ коде надо объявлять в блоке extern “C”, так как компилятор манглит их имена по правилам языка си. Проще это всё показать примером:  </p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h-файл (общий заголовок)</span></span><br><span class="line"> <span class="keyword">class</span> ObjClassWrapper</span><br><span class="line"> &#123;</span><br><span class="line">   ObjClass * objClass1;</span><br><span class="line">   ObjClassWrapper(); &#123; [[objClass1 alloc] init]; &#125;</span><br><span class="line">   ~ObjClassWrapper(); &#123; [objClass1 dealloc]; &#125;</span><br><span class="line">   <span class="keyword">void</span> method1(); &#123; [objClass1 method1]; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//mm-файл (язык Objective-C++)</span></span><br><span class="line"> <span class="class"><span class="keyword">@interface</span> <span class="title">ObjClass</span></span></span><br><span class="line"> <span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">@implementation</span> <span class="title">ObjClass</span></span></span><br><span class="line"> -(<span class="keyword">void</span>) method1</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">"Method1"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"> ObjClassWrapper::ObjClassWrapper() &#123; [[objClass1 alloc] init]; &#125;</span><br><span class="line"> ObjClassWrapper::~ObjClassWrapper() &#123; [objClass1 dealloc]; &#125;</span><br><span class="line"> <span class="keyword">void</span> ObjClassWrapper::method1(); &#123; [objClass1 method1]; &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//m-файл (язык Objective-C)</span></span><br><span class="line"> <span class="class"><span class="keyword">@implementation</span> <span class="title">StaticObjClass</span></span></span><br><span class="line"> +(<span class="keyword">void</span>) method2</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">"Method2"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">void</span> method2() &#123; [StaticObjClassObjClass method2]; &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//c++-файл</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;universalHeader.h&gt;   //объявляем класс-обертку</span></span></span><br><span class="line"> <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="keyword">void</span> method2(); &#125; <span class="comment">//объявляем метод-обертку</span></span><br><span class="line"> </span><br><span class="line"> ObjClassWrapper w; w.method1();  <span class="comment">//зовем код на Objective-C</span></span><br><span class="line"> method2();</span><br></pre></td></tr></table></figure><p>Про смешивание языков и вызов кода на С++ из языка Objective-C есть статья <a href="http://touchdev.ru/documents/963" target="_blank" rel="noopener">http://touchdev.ru/documents/963</a></p><p><strong>2. True/Yes</strong></p><p>Всегда интересно (<a href="http://stackoverflow.com/questions/615702/is-there-a-difference-between-yes-no-true-false-and-true-false-in-objective-c" target="_blank" rel="noopener">раз</a> <a href="http://stackoverflow.com/questions/541289/objective-c-bool-vs-boo" target="_blank" rel="noopener">два</a> <a href="http://stackoverflow.com/questions/6420987/why-does-objective-c-use-yes-no-macro-convention-instead-of-true-false" target="_blank" rel="noopener">три</a>), нафига разные ключевые слова?</p><p><a href="http://wasm.ru/article.php?article=1022005" target="_blank" rel="noopener">Главное, чтобы помещалось</a></p><p><strong>3. Динамический Objective-C</strong></p><p><strong>3.1</strong><br>Так как Objective-C является динамической веткой развития языка С++, то проверка наличия методов у экземляров выполняется только во время запуска приложения.</p><p>Методы среды выполнения, позволяющие динамически оперировать классами и методами классов, находятся в библиотеке <code>libobjc.A.dylib</code>, которая подключается к любой программе.</p><p>С помощью них можно, например, сделать подмену одного класса другим во всех местах, в которых будет обращения к оригинальному классу:  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[MyBundle class] poseAsClass:[NSBundle class]]; &#x2F;&#x2F;заменяем класс бандла своим, переопределяя его стандартное поведение.</span><br></pre></td></tr></table></figure><p><strong>3.2</strong><br>Однако такой метод уже признан apple устаревшим и вместо него можно подменять отдельные методы класса при помощи <code>class_getInstanceMethod</code> и свойства <code>method_imp</code> у селекторов класса. </p><p>Описание интересного трика с подменой метода :<br><a href="http://www.cocoadev.com/index.pl?MethodSwizzling" target="_blank" rel="noopener">http://www.cocoadev.com/index.pl?MethodSwizzling</a></p><p><strong>3.3</strong><br>Помимо этого в самих классах также можно перегрузить служебные методы, используемые средой выполнения, например, присвоив новый класс свойству isa, проверяющему, какому классу принадлежит объект. Члены класса таким способом поменять нельзя, зато можно полностью сменить интерфейс.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj-&gt;isa &#x3D; [MyClass class];</span><br></pre></td></tr></table></figure><p><strong>3.4</strong><br>Или можно перегрузить методы <code>forwardInvocation:</code> и <code>methodSignatureForSelector:</code> проверяющие само наличие метода у объекта<br><a href="http://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/forwardInvocation:" target="_blank" rel="noopener">ссылка</a></p><p><strong>3.5</strong><br>Ну и в самом языке есть возможность расширения существующих классов, вплоть до базового <code>NSObject</code>‘а, используя категории<br><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocCategories.html#//apple_ref/doc/uid/TP30001163-CH20-SW1" target="_blank" rel="noopener">ссылка</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1. Смешивание языков.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Objective-C код совместим с сишным кодом, но не всегда совместим с С++.&lt;/p&gt;
&lt;p&gt;Также сущес
      
    
    </summary>
    
    
    
      <category term="iphone" scheme="http://spiiin.github.io/tags/iphone/"/>
    
      <category term="objc" scheme="http://spiiin.github.io/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>New Ghostbusters Hard Mode Lua Script</title>
    <link href="http://spiiin.github.io/blog/37438/"/>
    <id>http://spiiin.github.io/blog/37438/</id>
    <published>2011-06-25T14:45:00.000Z</published>
    <updated>2020-09-15T21:27:11.775Z</updated>
    
    <content type="html"><![CDATA[<p>После <a href="http://spiiin.livejournal.com/37106.html" target="_blank" rel="noopener">изучения кода</a> игры New GhostBusters 2 у меня появилась расшифрованная информация о привидениях по уровням. </p><p>Чтобы ей не пропадать зря, решил сделать редактор врагов и усложнить игру наподобии того, как делал с <a href="http://spiiin.livejournal.com/7579.html" target="_blank" rel="noopener">Battletoads</a>, чтобы пройти её со своим мелким племянником.</p><p>Но писать на асме код, который мог бы считывать данные из другого места картриджа, которое еще надо найти свободное, это ад. </p><p>Но в современных эмуляторах есть встроенный скриптовый язык, позволяющий вмешаться в стандартный поток инструкций процессора. С помощью этого языка хакеры делали с играми вещи, напоминающие <a href="http://spiiin.livejournal.com/14975.html" target="_blank" rel="noopener">магию</a>.</p><p>Но любая магия является просто сложной технологией, поэтому решил попробовать пошаманить со скриптами сам. Алгоритм загрузки данных о врагах комнаты в <code>&quot;Охотниках за привидениями&quot;</code> выглядит примерно так:<br><img src="http://pics.livejournal.com/spiiin/pic/0001qqr2/s640x480" alt=""></p><p>Записи о комнатах храняться в виде списка из команд и номеров типов призраков. За командой следует переменной число аргументов, за номером типа координаты места появления (4 байта) и переменное число байт дополнительной информации (0 до 3 байт).</p><p>Игра узнает объем дополнительной информации из массива, в котором для каждого типа призрака есть набор из 3 флажков “имеет ли данный призрак доп. инфу заданного типа”. Такой информацией может быть, например, признак, что привидение неуязвимо (стулья в конце первого уровня и самовоспламеняющиеся свечи в последнем), подтип (головы в конце второго уровня) или направление поворота (импы в третьем уровне). </p><p>Таблица с описанием команд:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Коды команд New GhostBusters 2</span><br><span class="line">КодОписание</span><br><span class="line">FF 0Команда конца уровня.</span><br><span class="line">FF 1 XКоманда указателя на следующую комнату. Описание комнат уровня с номерами хранится отдельно.</span><br><span class="line">FF 2Чекпоинт. После проигрыша игра начнется не с начала уровня, а с последней сохраненной комнаты.</span><br><span class="line">0DМешок-приз.</span><br><span class="line">0EСвечи из последнего уровня.</span><br><span class="line">11Сценка в конце 3-го уровня.</span><br><span class="line">12Стрелка прибора (появляется после отлова всех призраков. доп. байты - направление и номер комнаты)</span><br><span class="line">13Лизун</span><br><span class="line">14Ускоренный лизун</span><br><span class="line">15Лизун с телегой</span><br><span class="line">1Лизун-метатель еды</span><br><span class="line">17Зеленый пацан</span><br><span class="line">18Тень с бензопилой</span><br><span class="line">19Змея из стены</span><br><span class="line">1AПара и тостого и худого призраков (первый босс)</span><br><span class="line">1BПрыгающий стул</span><br><span class="line">1CРозовые крутяшки</span><br><span class="line">1DШахтер с дрелью</span><br><span class="line">1EШахтер с киркой</span><br><span class="line">1FШахтер с граблями</span><br><span class="line">20Шахтер на вагонетке</span><br><span class="line">21Мелкая голова из поезда</span><br><span class="line">22Лизун с лопатой</span><br><span class="line">23Тыквоголов</span><br><span class="line">24Летающий имп</span><br><span class="line">25Имп с гарпуном</span><br><span class="line">26Дух ниндзя с мечом</span><br><span class="line">27Дух ниндзя с сюрекенами</span><br><span class="line">28Тесто</span><br><span class="line">29Блин из канализации</span><br><span class="line">2AТролль с цепью</span><br><span class="line">2BЛизун-метатель мусора</span><br><span class="line">2CЛизун-метатель быстрый</span><br><span class="line">2DВращающаяся труба</span><br><span class="line">2EБосс Ящеры</span><br><span class="line">2FБосс Венс</span><br><span class="line">30Босс Виго</span><br></pre></td></tr></table></figure></p><p> Проглядел доступную документацию по <code>EmuLua</code>, нашел функцию <code>memory.register</code>, про которую сказано, что она может установить произвольную функцию, отслеживающую изменения в ячейке памяти.</p><p> Если установить обработчики на шаги, помеченные на блок-схеме красными кружками с цифрами, то можно выставлять свои данные вместо игровых в аккумулятор вместо реальных данных и заглушать реальный счетчик, подсчитывая сколько байт уже было отдано, а в конце вернуть указатель на реальные данные.</p><p> Но такому простому способу препятствует то, что <code>memory.register</code> а) работает только в режиме ослеживания записей. б) как следствие работает только в области изменяемой памяти (0x0000-0x8000), а данные уровня лежат в ROM. Хендлер на чтение из ROM установить нельзя.</p><p> Почему – не знаю, технически вроде не сложно вытащить такую возможность в скрипты, но факт, что таким способом подстановку данных сейчас сделать нельзя :(</p><p>Пришлось прочитать документацию по всем доступным функциям внимательнее, после чего обнаружилась функция memory.registerrun, устанавливающая функцию,выполняющуюся при выполнении кода по указанному в аргументе адресу.</p><p>Выяснил на практике, что если ставить обработчик <code>memory.registerrun</code>, то он выполняется ДО выполнения команды по адресу, а если через <code>memory.register</code>, то сразу ПОСЛЕ записи в ячейки.</p><p>Алгоритм внедрения модифицировал так - в роме добавил в интерпретатор еще одну команду, которая выставляет флажок в неиспользуемый игрой кусок памяти, а в скриптах сделал функцию, реагирующую на выставление флажка и делающую то же, что команда считывания в оригинальном роме. После тестов я заметил, что функция-обработчик вызывается недетерминированное количество раз (почему-то по 4 за одну запись в ячейку). Поэтому функция-обработчик обязана быть чистой и никаких счетчиков содержать не может :(</p><p>Выяснять, почему так, долго и сложно, поэтому просто убедился в том, что хотя бы memory.registerrun работает, как ожидается и решил использовать только её. Дальше попробовал так - навесить после всех инструкций, считывающие данные о комнате, свои функции-хендлеры на выполнение, которые блокируют действие этой инструкции (переписывают аккумулятор, память или регистр статуса) и дальше возвращаться к оригинальному потоку выполнения.</p><p>С таким подходом следует еще следить за тем, чтобы адрес, на который ставится обработчик находился в том же блоке памяти, иначе можно напороться на неправильную инструкцию. В качестве контрольной проверки может послужить сравнение значения ячейки, хранящей номер уровня с тем, который ожидается в скрипте. Ну и некоторые в некоторых сложных по возможному графу выполнения участках проще вклиниваться в несколько частей, собирая по ходу необходимые данные. Такой метод работает! Дальше оставалось только перехватить логику обработки чекпоинтов и game over, чтобы сбрасывать свои указатели данных. Еще в ходе исследования я заметил, что потенциально движок игры поддерживает до 8 призраков на экране, хотя в коде стоит ограничение на четырех.</p><p>Это ограничение было аккуратно вырезано, после чего игра стала более сложной и веселой. Единственный минус - видимо, за кадр не всегда успевают отрисоваться все объекты на экране, поэтому появляется мерцание. Ну на это уже можно и забить. Оставшиеся проблемы скрипта - я не делал поддержку перезапуска по нажатию кнопок power и reset приставки (это не поддерживается вообще) и загрузку/сохранение вместе с игровыми сейвами (просто неохота было). Так что сейвами пользоваться нельзя, а при перезагрузке игры надо вручную перезапустить скрипт. Вот и вся чёрная магия. </p><p>Видео геймплея:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/aSGLA1R96Gc" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Код скрипта:<br><a href="http://www.everfall.com/paste/id.php?az548wj3t37t" target="_blank" rel="noopener">http://www.everfall.com/paste/id.php?az548wj3t37t</a></p><p>Ссылка на архив (содержит эмулятор, игру на русском, скрипт и инструкции для запуска):<br><a href="http://dl.dropbox.com/u/852723/NewGhostBusters_hard.zip" target="_blank" rel="noopener">http://dl.dropbox.com/u/852723/NewGhostBusters_hard.zip</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;После &lt;a href=&quot;http://spiiin.livejournal.com/37106.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;изучения кода&lt;/a&gt; игры New GhostBusters 2 у меня 
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>КОШАЧИЙ РАЙ</title>
    <link href="http://spiiin.github.io/blog/58486/"/>
    <id>http://spiiin.github.io/blog/58486/</id>
    <published>2011-06-12T09:27:00.000Z</published>
    <updated>2020-09-15T21:05:22.839Z</updated>
    
    <content type="html"><![CDATA[<p>Перерыл половину жж  , чтобы найти.  </p><p>Мне казалось - я бегу<br>Полем<br>На не чующих травы<br>Лапах…<br>Я не помню никакой<br>Боли,<br>Смерть была - один большой<br>Запах.  </p><p>Помню небо -<br>Древний Кот многоликий.<br>Отряхнулся и пошёл,<br>Как по карте.<br>Не взаправду же ведь я - Дикий,<br>Чтоб смотреть, что там лежит<br>На асфальте.  </p><p>А потом запахло мёдом и мятой,<br>Я в траву влетел по самые уши<br>И решил, что в новой жизни (девятой)<br>Буду тем же, кем и был, только лучше.  </p><p>Был котёнком, в сказки не верил,<br>А потом забыл, как все мы забываем -<br>Здесь всегда распахнуты двери,<br>Это место называется Раем.  </p><p>Рай кошачий, до последних окраин,<br>Благодать для тех, кто здесь поселился.<br>Но уж больно убивался хозяин -<br>Я чуть сразу же назад не родился.  </p><p>Весь поникший от нахлынувшей скуки,<br>Брёл по Раю в поисках дома<br>И уткнулся в чьи-то тёплые руки,<br>Руки пахли странно знакомо.  </p><p>Не запомнилось лицо и окраска -<br>Прятал морду в вороте платья.<br>Был покой и тихая ласка,<br>А потом нас встретили братья.  </p><p>Было солнце (просто так, не в окошке)<br>Золотым, как рыбка на блюде.<br>И все были мы здесь - общие кошки,<br>А у нас, конечно, - общие люди.  </p><p>Мы со взрослыми котами небрежно<br>Выходили в круг - померяться силой,<br>И мурлыкали мне кошки так нежно,<br>Потому что я большой и красивый.  </p><p>Здесь тепло всегда, и чисто, и сухо,<br>Не бывает ни дождей, ни метели.<br>Раз порвал я, значит, Серому ухо -<br>Зажило, и пожалеть не успели.  </p><p>Серый крут, он подох, видно, в драке.<br>Серой масти - аккурат мой братишка…<br>По ночам ему всё снятся собаки,<br>Он рычит на них во сне, но не слишком.  </p><p>Мне же снится: я бегу<br>Полем.<br>Каждая травинка -<br>Резная…<br>Может, каждый выбирать<br>Волен?<br>Я всего лишь кот, я -<br>Не знаю.  </p><p>(с) Екатерина Агафонова.   </p><p>Заодно наткнулся на это:<br>“Мифический человеко-месяц” не работает в <a href="http://gaijin.ru/" target="_blank" rel="noopener">Гайдзинах</a>. У нас счёт идёт на человеко-часы”</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Перерыл половину жж  , чтобы найти.  &lt;/p&gt;
&lt;p&gt;Мне казалось - я бегу&lt;br&gt;Полем&lt;br&gt;На не чующих травы&lt;br&gt;Лапах…&lt;br&gt;Я не помню никакой&lt;br&gt;Боли
      
    
    </summary>
    
    
    
      <category term="книги" scheme="http://spiiin.github.io/tags/%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8/"/>
    
  </entry>
  
  <entry>
    <title>New Ghostbusters 2 (E) [NES] All bonuses</title>
    <link href="http://spiiin.github.io/blog/51050/"/>
    <id>http://spiiin.github.io/blog/51050/</id>
    <published>2011-06-03T15:47:00.000Z</published>
    <updated>2020-09-15T21:19:26.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Особенности-игры"><a href="#Особенности-игры" class="headerlink" title="Особенности игры:"></a>Особенности игры:</h2><p> Движок использует для описания логики интерпретатор игровых скриптов, содержащий примерно 25 основных команд и еще 25 дополнительных (среди которых есть циклы, условные и безусловные перехода, команды записи значений по адресам).</p><p> Теперь я понимаю, почему скриптовые языки получаются именно в 5-10 раз медленнее нативных ^_^.</p><p> Записи о призраках и комнатах состоят из перемешанного набора команд интерпретатора скриптов и данных. </p><p> В игре есть бонусы - мешки с деньгами, за которые начисляется по 3000 очков, но появляются они настолько редко, что за прохождение можно найти не более пары, и то если повезет. Но из кода комнаты можно вытащить команду записи условия появления бонуса. Она состоит из записи указателя на цепочку байт, заканчивающуюся нулём, соответствующую набору типов призраков, которых нужно отловить в заданном порядке для получения мешка. Естественно, что случайно наткнуться на нужный порядок практически нереально.</p><p>  Я подозреваю, что стал вообще первым из игроков после самих разработчиков, собравшим все возможные спрятанные мешки.</p><p>Видео:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/L90WP3TiEhI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Цепочки призраков:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stage 1-1. Running Ghost, Slimer, Slimer.</span><br><span class="line">Stage 1-3. Running Ghost, Fast slimer, Invisible Chainsaw Ghost, Slimer.</span><br><span class="line">Stage 1-7. Slimmer with carts, Debris-throwing Slimer, Fast slimer x 3, Debris-throwing Slimer x 2.</span><br><span class="line">Stage 2-5. Jackhammer worker x 2, Mine Car worker, Jackhammer worker x 2, Hammer worker.</span><br><span class="line">Stage 2-6. Mine Car worker, Jackhammer worker, Hammer worker, Mine Car worker, Jackhammer worker, Hammer worker.</span><br><span class="line">Stage 2-7. Mine Car worker x 2, Pick workers</span><br><span class="line">Stage 2-8. Hammer worker, Pick workers, Hammer worker, Mine Car worker.</span><br><span class="line">Stage 2-9. Hammer worker, Pick workers, Jackhammer worker, Mine Car worker.</span><br><span class="line">Stage 3-3. Imp x 3, Blob x 2.</span><br><span class="line">Stage 3-6. Blob x 2, Ninja with sword..</span><br><span class="line">Stage 3-9. Ninja with shureken x 2, Blob.</span><br><span class="line">Stage 3-13. Blob, Fly imp x 3, Blob.</span><br><span class="line">Stage 3-15. Blob, Fly imp x 6, Imp.</span><br><span class="line">Stage 4-6. Fast Debris-throwing Slimer x 3, River Creature x 2, Fast Debris-throwing Slimer.</span><br><span class="line">Stage 4-9. Stand Debris-throwing Slimer x 4, Rotating Creature x 4.</span><br><span class="line">Stage 4-10. River Creature, Rotating Creature, River Creature, Rotating Creature, River Creature x 2, Rotating Creature x 2.</span><br><span class="line">Stage 4-11. River Creature, Rotating Creature x 2, Fast Debris-throwing Slimer, River Creature, Rotating Creature, Fast Debris-throwing Slimer, Rotating Creature.</span><br><span class="line">Stage 5-11. Wall Slime, Chainsaw Ghost, Wall Slime x 3, Chainsaw Ghost x 2.</span><br><span class="line">Stage 5-12. Slimer x 2, Wall Slime x 4, Running Ghost x 2.</span><br></pre></td></tr></table></figure></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Особенности-игры&quot;&gt;&lt;a href=&quot;#Особенности-игры&quot; class=&quot;headerlink&quot; title=&quot;Особенности игры:&quot;&gt;&lt;/a&gt;Особенности игры:&lt;/h2&gt;&lt;p&gt; Движок испо
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>Система паролей Goal! Two [NES]</title>
    <link href="http://spiiin.github.io/blog/30094/"/>
    <id>http://spiiin.github.io/blog/30094/</id>
    <published>2011-05-18T18:56:00.000Z</published>
    <updated>2020-09-15T21:17:12.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Особенности-игры"><a href="#Особенности-игры" class="headerlink" title="Особенности игры:"></a><strong>Особенности игры:</strong></h2><p>Goal! Two приурочена к чемпионату мира по футболу 1992 года, как и <a href="http://spiiin.livejournal.com/33614.html" target="_blank" rel="noopener">Tecmo World Cup</a>. В обеих разработчики вместо реально участвующих команд напихали тех, кого им хотелось. Вероятно, среди авторов был парень из Венесуэлы, так как в игре присутствует эта славная страна, причем даже с формой правильного цвета, хотя в реале до финальных стадий ЧМ Венесуэла вообще ни разу не доходила.</p><p>У игроков присутствуют характеристики, и сборная Бразилии реально бегает быстрее и бьет сильнее, чем, например, колумбийцы. Можно делать замены и выбирать тактику для команды. В игре соблюдаются почти все правила настоящего футбола - присутствуют офсайды, штрафные удары, карточки за нарушения и послематчевые пенальти. В те времена эти возможности поражали воображение.   </p><p>Еще можно сыграть вдвоем за одну команду против компьютера. Этого было уже достаточно, чтобы проводить за игрой столько времени, что адаптер приставки плавился.  </p><p>Изометрическое поле открывает широкие просторы для тактики, но целиться по воротам просто нереально неудобно.  </p><p>Игра сохраняет прогресс игрока в виде пароля из 24 символов. Ага! Ее можно разобрать!  </p><h2 id="Особенности-системы-генерации-пароля"><a href="#Особенности-системы-генерации-пароля" class="headerlink" title="Особенности системы генерации пароля:"></a><strong>Особенности системы генерации пароля:</strong></h2><ul><li>Основная рабочая функция генерации принимает 3 параметра - по какому смещению в пароле, сколько бит и какое число скопировать в пароль. </li></ul><p>Группы логических значений записываются в соседние биты, так что понять принцип действия можно и без дизассемблирования, просто получая пароли для похожих значений. Для защиты используется контрольная сумма из 7 бит в конце пароля.  </p><ul><li><p>Функций генерации не одна, а две - первая сохраняет прогресс в групповом турнире, вторая - в плей-офф.  </p></li><li><p>Функция проверки довольно большая (от $B77D до BA8E = 785 байт + вспомогательные процедуры).</p></li></ul><p>Она помимо расшифровки проверяет содержит размазанную логику с проверкой корректности возможных значений и имеет несколько “плохих” выходов (номер команды игрока должен совпасть с номером группы, в которой играет эта команда, запихнуть ее в другую не получится).  </p><ul><li>Для сохранения количества забитых и пропущенных мячей игра отводит 7 бит. </li></ul><p>Если забить больше 128 голов, пароль сгенерируется неправильно.  </p><ul><li>Генератор для выдачи паролей группового турнира сохраняет результаты матчей (победа, поражение, ничья) и суммарное количество забитых-пропущенных голов и очки команд раздельно.</li></ul><p>В итоге существуют пароли, в которых команда побеждает во всех матчах, но не забивает не одного мяча.  </p><ul><li>Генератор плей-офф паролей сохраняет номера 16 участвующих команд и все 15 результатов матчей между ними. </li></ul><p>Можно подобрать код, например, <code>&#39;XXXXXX XXXXXX XXXXXV BBJ7LB&#39;</code>, который выведет в 1/8 финала все 16 сборных Голландии:   </p><p><a href="http://pics.livejournal.com/spiiin/pic/0001h3t3/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0001h3t3" alt=""></a></p><p>А вот и виртуальный Марко Ван Бастен, уже радуется победе и представляет, что несет в руках Кубок Мира, потому как других сборных с таким паролем просто не осталось:<br><a href="http://pics.livejournal.com/spiiin/pic/0001k4b1/" target="_blank" rel="noopener"><img src="http://pics.livejournal.com/spiiin/pic/0001k4b1" alt=""></a>  </p><p>Игра не позволяет устраивать напрямую дуэли двух команд ни в одном из режимов, но если воспользоваться кодом вроде приведенного выше, то можно всё-таки сыграть зеркальный матч. При этом одна из сборных одевается в гостевую форму, так что проблем с различием по цвету не возникнет.  </p><p>Хорошо структурированный код легче читать, это правило верно даже для машинного кода.  </p><p>Генератор паролей онлайн:<br><a href="http://spin-de.narod.ru/passgen/goal_two.html" target="_blank" rel="noopener">http://spin-de.narod.ru/passgen/goal_two.html</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Особенности-игры&quot;&gt;&lt;a href=&quot;#Особенности-игры&quot; class=&quot;headerlink&quot; title=&quot;Особенности игры:&quot;&gt;&lt;/a&gt;&lt;strong&gt;Особенности игры:&lt;/strong&gt;&lt;/h
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
  </entry>
  
</feed>
