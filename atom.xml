<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiiin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spiiin.github.io/"/>
  <updated>2021-06-15T17:56:17.683Z</updated>
  <id>http://spiiin.github.io/</id>
  
  <author>
    <name>spiiin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Расположение объектов C++ в памяти. Часть 2</title>
    <link href="http://spiiin.github.io/blog/1170009669/"/>
    <id>http://spiiin.github.io/blog/1170009669/</id>
    <published>2021-06-15T15:24:44.000Z</published>
    <updated>2021-06-15T17:56:17.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Продолжение экспериментов с изучением расположения объектов C++ в памяти.<br><a id="more"></a></p><a href="/blog/854775037/" title="Предыдущая заметка">Предыдущая заметка</a> <p>закончилась на том, что самым удобным способом изучения оказался статический анализ информации для отладчика из исполнимого файла или отладочной базы данных. Этот способ удобен, если нужно оптимизировать большую готовую кодовую базу. Но у него есть два серьёзных минуса.</p><h2 id="Минусы-статического-анализа"><a href="#Минусы-статического-анализа" class="headerlink" title="Минусы статического анализа"></a>Минусы статического анализа</h2><p>Во-первых, инструменты и библиотеки требуют написания большого количества кода, из-за чего 1) ни одна из них не покрывает нормально бинарники обеих платформ iOS/Android, 2) написанные руками формулы по спецификации не покрывают всех corner-case и могут содержать ошибки, которые сложно заметить и исправить - поддерживать такой скрипт/инструмент сложно. Было бы намного удобнее воспользоваться кодовой базой самого компилятора или отладчика, чтобы избавиться от необходимости поддержки своего кода.</p><p>Во-вторых, изучение базы классов и оптимизация таким способом производится слишком редко, и зачастую слишком поздно, когда времени остаётся только на исправление самых больных мест.</p><h2 id="Ранняя-оптимизация"><a href="#Ранняя-оптимизация" class="headerlink" title="Ранняя оптимизация"></a>Ранняя оптимизация</h2><p>Идеология “не оптимизировать код пока не потребуют” растёт из цитаты Дональда Кнута <em>“Преждевременная оптимизация – корень всех зол”</em>.</p><p>Проблема такого подхода - программисты пишут изначально плохой код, вообще не задумываясь о том, чтобы его оптимизировать. Ведь пока не найдено “бутылочное горлышко” - твой код не самый плохой, и трогать его не надо. В итоге получается, что среднестатистический код проекта содержит большое количество балласта, который можно было легко выбросить, если сразу его увидеть.</p><p>Сама стадия измерения производительности откладывается как можно дальше, чаще всего на оставшееся до релиза время (а его никогда не бывает слишком много), или вообще забрасывается. Любая некритическая, а, возможно, и критическая) todo-шка в коде в стиле “я сделаю это нормально” рискует прожить в коде много лет. Чаще всего программисты относятся к кодовой базе по принципу “работает - не трогай”, такой подход имеет определенный смысл - переписывание всегда добавляет новые ошибки, но он совсем не способствует тому, чтобы переписывать код на более быстрый.</p><p>Можно попробовать сменить подход, и вытащить стадию оптимизации размера структур и расположения их в памяти как можно раньше. В идеале, ещё до написания кода или хотя бы на момент его компиляции.</p><p>Тогда каждая компиляция станет проверкой прототипа лучшей версии кода.</p><p><strong><code>Чем раньше узнаешь, что с твоими данными что-то не так, тем скорее можешь это исправить</code></strong> (<a href="https://www.dataorienteddesign.com/dodbook/node2.html" target="_blank" rel="noopener">It’s all about your data!</a>).</p><p>Такое исправление не будет “корнем зол”, если на него не потребуется много времени - а с этим и должны помочь инструменты.</p><h2 id="Получение-данных-от-компилятора"><a href="#Получение-данных-от-компилятора" class="headerlink" title="Получение данных от компилятора"></a>Получение данных от компилятора</h2><p>Простое получение данных от <code>Clang</code> и <code>Visual C++</code> во время компиляции рассматривалось в предудыщей заметке - они поддерживают ключи <code>fdump-record-layouts</code>/<code>d1reportAllClassLayout</code> для вывода выравнивания структуры в stdout, однако оно не удобно, так как порождает слишком много текста, плохо фильтруется, и показывает абсолютное выравнивание структур и классов вместо относительного и держать его включенным постоянно неудобно.</p><p>Другой возможный подход - написание плагина к компилятору. Это не очень сложно в теории, Clang задумывался расширяемым, несколько статей для поисков в нужном направлении:<br><a href="https://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/" target="_blank" rel="noopener">Clang tutorial introduction</a> - примеры использования интерфейсов к Clang - <code>плагины, LibTooling, LibClang</code>.<br><a href="https://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">External Clang examples</a> - примеры расширения компилятора, в частности:<br><a href="https://github.com/LibreOffice/core/tree/master/compilerplugins/clang" target="_blank" rel="noopener">LibreOffice compiler plugins</a> - примеры плагинов, реализующих различные проверки. Местами linux-specific (pahole-all-classes.py использует linux-утилиту pahole, чтобы показывать выравнивание и дыры в структурах, почто то что нужно).<br><a href="https://sudonull.com/post/114803-Creating-and-Using-the-Clang-Plugin-in-Xcode" target="_blank" rel="noopener">Creating and Using the Clang Plugin in Xcode</a> - “Hello, world”-плагин для Xcode.</p><p>Плагин собирается в dll/.so/.dylib файл, который передаётся компилятору через командную строку:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$LLVM_HOME</span>/llvm_build/bin/clang ../test.cpp \</span><br><span class="line">  -Xclang -load \</span><br><span class="line">  -Xclang lib/Debug/TestClangPlugin.dylib \</span><br><span class="line">  -Xclang -plugin \</span><br><span class="line">  -Xclang TestClangPlugin</span><br></pre></td></tr></table></figure><p>Но, ключевое слово здесь “в теории”. Сборка плагина требует сборки компилятора из исходников, причём исходников той версии, для которую собирается плагин. Для большой кодовой базы старые версии исходников могут просто не собраться новые версиями средств сборки (а учитывая желание иметь кросс-платформенный плагин - количество требуемых усилий нужно умножать на количество платформ). Кроме того, автор плагина для Xcode отмечает, что компилятор Clang от Apple не поддерживает плагины (и скорее всего может ещё в чем-то отличаться от оригинального), что уже не очень удобно - требуется или использовать обычный компилятор для сборки приложения и модифицированные - для работы с плагинами, либо положиться на то, что Apple не использовала каких-либо специфичных хаков для сборки своего компилятора.</p><p>Кроме того, API компилятора <a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/writing_clang_plugins.md" target="_blank" rel="noopener">нестабильно</a>, так что всё равно возникает необходимость поддержки своих плагинов, а код плагина может быть немаленьким (хотя, по большей части, нужная функциональность почти вся сосредоточена в <a href="https://clang.llvm.org/doxygen/RecordLayoutBuilder_8cpp_source.html" target="_blank" rel="noopener">одном файле</a>.</p><p>Дополнительной проблемой может стать увеличенное время компиляции (я не измерял, насколько постоянно включенные плагины замедляют сборку), хотя тут можно было бы попробовать помечать для обработки отдельные классы (например, <a href="https://en.cppreference.com/w/cpp/language/attributes" target="_blank" rel="noopener">атрибутом</a>) и перекомпилировать только отдельные единицы компиляции, а не весь проект.</p><p>Но пока я возился с документацией по плагинам, я нашёл способ удобнее. Расширяемым сделан не только компилятор, но и отладчик <a href="https://lldb.llvm.org/use/python.html" target="_blank" rel="noopener">LLDB</a>. И самое главное, он расширяется не плагинами, а имеет python-интерфейс. А значит, есть шанс, что скрипт будет работать под любую платформу!</p><h2 id="Интерактивная-отладка-в-LLDB-с-Python"><a href="#Интерактивная-отладка-в-LLDB-с-Python" class="headerlink" title="Интерактивная отладка в LLDB с Python"></a>Интерактивная отладка в LLDB с Python</h2><p>После небольших экспериментов я понял, что это то, что нужно, скрипт работает в <code>XCode</code>, <code>Android Studio</code> и <code>Visual Studio Code</code> (с использованием плагина <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a>).</p><p><a href="https://github.com/spiiin/lldb_dump_class_layout" target="_blank" rel="noopener">https://github.com/spiiin/lldb_dump_class_layout</a> - скрипт для LLDB.</p><p>Для загрузки скрипта из отладчика нужно выполнить команду для импорта скрипта:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command script import ~&#x2F;PATH_TO_SCRIPT&#x2F;dump_class_laouyt.py</span><br></pre></td></tr></table></figure><p>После чего из lldb можно выполнять команды <code>layout STRUCT_NAME</code> (для поиска в загруженных образах информации о типе STRUCT_NAME) и <code>layoutvar VARIABLE_NAME</code> (для получения информации о переменной на фрейме стека).</p><p><img src="/blog/1170009669/lldb1.png" alt="lldb1"><br><img src="/blog/1170009669/lldb2.png" alt="lldb2"><br><img src="/blog/1170009669/lldb3.png" alt="lldb3"></p><p>Одна из интересных возможностей скрипта - изучения памяти для типов из STL, например, для <code>std::map</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; aaa;</span><br><span class="line">(<span class="keyword">void</span>)<span class="keyword">sizeof</span>(aaa); <span class="comment">//чтобы компилятор не выбросил неиспользуемый тип</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) layoutvar aaa</span><br><span class="line"><span class="built_in">std</span>::__1::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">24</span>&gt; <span class="built_in">std</span>::__1::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">24</span>&gt;   <span class="built_in">std</span>::__1::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;::__base __tree_</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">8</span>&gt;    <span class="built_in">std</span>::__1::__tree&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;::__iter_pointer __begin_node_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__compressed_pair&lt;<span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt; &gt; __pair1_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;, <span class="number">0</span>, <span class="literal">false</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;, <span class="number">0</span>, <span class="literal">false</span>&gt;</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;         <span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt; __value_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;          <span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;::pointer __left_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">1</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;, <span class="number">1</span>, <span class="literal">true</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;, <span class="number">1</span>, <span class="literal">true</span>&gt;</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">1</span>&gt;         SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt; SimpleAllocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">1</span>&gt;           <span class="built_in">std</span>::__1::allocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt; <span class="built_in">std</span>::__1::allocator&lt;<span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt; &gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__compressed_pair&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt; &gt; __pair3_</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="number">0</span>, <span class="literal">false</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="number">0</span>, <span class="literal">false</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;        <span class="keyword">unsigned</span> <span class="keyword">long</span> __value_</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;       <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;, <span class="number">1</span>, <span class="literal">true</span>&gt; <span class="built_in">std</span>::__1::__compressed_pair_elem&lt;<span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;, <span class="number">1</span>, <span class="literal">true</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;         <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt; <span class="built_in">std</span>::__1::__map_value_compare&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;, <span class="literal">true</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;           <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt; <span class="built_in">std</span>::__1::less&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">1</span>&gt;             <span class="built_in">std</span>::__1::binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt; <span class="built_in">std</span>::__1::binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt;</span><br><span class="line">Total byte size: <span class="number">24</span></span><br><span class="line">Total pad bytes: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Итог, 24 байта на стеке. Плюс, что интереснее, можно посмотреть, сколько занимает каждая нода в куче.<br>Напрямую сама нода спрятана от программиста, но можно написать код аллокатора, который может засечь размер:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleAllocator</span> :</span> <span class="keyword">private</span> <span class="built_in">std</span>::allocator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> value_type = T;</span><br><span class="line"><span class="keyword">using</span> pointer = <span class="keyword">typename</span> <span class="built_in">std</span>::allocator&lt;T&gt;::pointer;</span><br><span class="line"><span class="keyword">using</span> size_type = <span class="keyword">typename</span> <span class="built_in">std</span>::allocator&lt;T&gt;::size_type;</span><br><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Allocator sizeof(T)=="</span> &lt;&lt; <span class="keyword">sizeof</span>(T) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::allocator&lt;T&gt;::allocate(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::allocator&lt;T&gt;::deallocate(p, n); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;, SimpleAllocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; aaa;</span><br><span class="line">aaa[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Allocator sizeof(T)==40 bytes</span></span><br></pre></td></tr></table></figure><p>Или запросить у скрипта нужную структуру данных (название структуры можно узнать из вывода предыдущего запроса:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(lldb) layout <span class="string">"std::__1::__tree_node&lt;std::__1::__value_type&lt;int, int&gt;, void *&gt;"</span></span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">40</span>&gt; <span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">32</span>&gt;   <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt;</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__tree_node_base_types&lt;<span class="keyword">void</span> *&gt;::__end_node_type <span class="built_in">std</span>::__1::__tree_node_base_types&lt;<span class="keyword">void</span> *&gt;::__end_node_type</span><br><span class="line"> +<span class="number">0</span> &lt; <span class="number">8</span>&gt;      <span class="built_in">std</span>::__1::__tree_end_node&lt;<span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt; *&gt;::pointer __left_</span><br><span class="line"> +<span class="number">8</span> &lt; <span class="number">8</span>&gt;    <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt;::pointer __right_</span><br><span class="line"> +<span class="number">16</span> &lt; <span class="number">8</span>&gt;    <span class="built_in">std</span>::__1::__tree_node_base&lt;<span class="keyword">void</span> *&gt;::__parent_pointer __parent_</span><br><span class="line"> +<span class="number">24</span> &lt; <span class="number">1</span>&gt;    <span class="keyword">bool</span> __is_black_</span><br><span class="line"> +<span class="number">25</span> &lt; <span class="number">3</span>&gt;  &lt;PADDING: <span class="number">3</span> bytes&gt;</span><br><span class="line"> +<span class="number">28</span> &lt; <span class="number">8</span>&gt;   <span class="built_in">std</span>::__1::__tree_node&lt;<span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">void</span> *&gt;::__node_value_type __value_</span><br><span class="line"> +<span class="number">28</span> &lt; <span class="number">8</span>&gt;     <span class="built_in">std</span>::__1::__value_type&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type __cc</span><br><span class="line"> +<span class="number">28</span> &lt; <span class="number">4</span>&gt;      <span class="keyword">const</span> <span class="keyword">int</span> first</span><br><span class="line"> +<span class="number">32</span> &lt; <span class="number">4</span>&gt;      <span class="keyword">int</span> second</span><br><span class="line"> +<span class="number">36</span> &lt; <span class="number">4</span>&gt;  &lt;PADDING: <span class="number">4</span> bytes&gt;</span><br><span class="line">Total byte size: <span class="number">40</span></span><br><span class="line">Total pad bytes: <span class="number">7</span></span><br><span class="line">Padding percentage: <span class="number">17.50</span> %</span><br></pre></td></tr></table></figure><p>Каждая нода красно-чёрного дерева пар из двух 32-битных целых занимает 40 байт - 3 указателя  (на родителя, левую и правую ноды), один флаг (красная/чёрная нода), выровненный на 8 байт, ну и само значение ноды - пара из двух целых 8 байт:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * __left_, __right_, __parent_; <span class="comment">//24 bytes</span></span><br><span class="line"><span class="keyword">bool</span> __black_;                       <span class="comment">//1 bytes</span></span><br><span class="line"><span class="keyword">char</span> padding[<span class="number">3</span>];                     <span class="comment">//3 bytes padding</span></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; __value_;  <span class="comment">//8 bytes</span></span><br><span class="line"><span class="keyword">char</span> padding[<span class="number">4</span>];                     <span class="comment">//4 bytes paddding</span></span><br></pre></td></tr></table></figure></p><p>(попробуйте найти эти данные, читая код <code>map.h/tree.h</code>)</p><p>Для сравнения - положив пары целых в отсортированный <code>std::vector</code>, можно полностью избавиться от лишних данных (<a href="https://cpp-optimizations.netlify.app/dont_need_map/" target="_blank" rel="noopener">бенчмарк результатов</a>).</p><p>С плагином можно смотреть в получающуюся структуру класса в памяти для загруженного приложения в любой момент из любой среды разработки или просто из консоли, <code>LLDB</code> умеет загружать данные как из DWARF-секций, так и из PDB-базы Visual Studio.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Продолжение экспериментов с изучением расположения объектов C++ в памяти.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://spiiin.github.io/tags/c/"/>
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Расположение объектов C++ в памяти</title>
    <link href="http://spiiin.github.io/blog/854775037/"/>
    <id>http://spiiin.github.io/blog/854775037/</id>
    <published>2021-06-09T15:16:20.000Z</published>
    <updated>2021-06-17T15:07:11.876Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обычно на вопрос о расположении объекта в памяти программисты C++ отвечают “это зависит от реализации”, а как именно зависит - не особо понимают. Это действительно практически не нужно знать для написания корректных программ, но может пригодиться для написания быстрых.</p><p>После просмотра доклада об оптимизации <code>Witcher 3</code> для Switch (<a href="https://www.gdcvault.com/play/1026635/-Witcher-3-on-the" target="_blank" rel="noopener">видео</a> на 14:28), я решил проверить, возможно ли получить информацию об расположении объектов в памяти таким же или похожим способом для телефонов.<br><a id="more"></a></p><p><strong><code>Зачем это нужно в контексте разработки мобильных игр (и не только):</code></strong></p><ul><li>Пробраться “вглубь” языка, лучше понять его фичи</li><li>Улучшить понимание работы компиляторов и отличия в реализациях</li><li>Получить возможность оценить размер базовых объектов используемых библиотек</li><li>Научиться data-oriented design (если начинать проектировать от данных, хорошо бы понять, как они вообще выглядят)</li><li><strong>Оптимизировать наиболее часто используемые структуры - уменьшить системные требования игры</strong></li></ul><p>Заметки про <code>data-oriented design</code> и <code>entity-component-system</code> подход - <a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a>,  <a href="/blog/1488389622/" title="ECS для казуальных игр">ECS для казуальных игр</a></p><p><strong><code>Когда можно браться за подобные исследования</code></strong></p><ul><li>Если у вас есть много времени</li><li>Если игра не влезает в память и тормозит, а нужно её запихать и разогнать</li><li>Если хотите “достичь невозможного” (Do the impossible! ;) )</li></ul><p><strong><code>Когда не стоит</code></strong><br>Если просто нужно сделать фичу или окошко для игры - то лучше сделать поскорее, закрыть задачу, выпустить апдейт/релиз, выпить шампанского (или коньяка, в зависимости от масштабов запуска). Потом выехать погулять на природу и тогда, возможно, задуматься о расположении объектов в памяти.</p><h2 id="Как-уменьшение-размера-структур-уменьшает-производительность"><a href="#Как-уменьшение-размера-структур-уменьшает-производительность" class="headerlink" title="Как уменьшение размера структур уменьшает производительность"></a>Как уменьшение размера структур уменьшает производительность</h2><p>Кроме очевидного <strong><code>уменьшения времени на копирование</code></strong> байт, необходимого для создания объекта, более важным является то, что объекты лучше <strong><code>помещаются в кеш</code></strong>.</p><p>Т.е. во-первых, уменьшается количество страниц оперативной памяти, которые будут выгружена на диск (<a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C" target="_blank" rel="noopener">Виртуальная память</a>).</p><p>Во-вторых, процессор имеет свой <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0" target="_blank" rel="noopener">кеш памяти</a> нескольких уровней. При запросе данных из памяти он загружает не только запрошенную ячейки, но ещё и соседние ячейки. Количество таких ячеек называется <em>кеш-линией</em>. В случае обращения к соседним ячейкам данные будут получены не из оперативной памяти, а из кеша, что <strong>сильно</strong> быстрее.</p><blockquote><p>Разница между получением данных из кеша 1 уровня и основной памяти достигает 2х порядков <strong>(~100 раз быстрее)</strong>, конкретные числа зависят от железа.</p></blockquote><p><img src="/blog/854775037/cache.gif" alt="cache"><br>(источник - <a href="https://technology.riotgames.com/news/profiling-measurement-and-analysis" target="_blank" rel="noopener">https://technology.riotgames.com/news/profiling-measurement-and-analysis</a>)</p><p>Примеры и бенчмарки:<br><a href="https://gameprogrammingpatterns.com/data-locality.html" target="_blank" rel="noopener">Data Locality</a> - глава из книги <strong><code>Game Programming Patterns</code></strong>.<br><a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html" target="_blank" rel="noopener">Latency Numbers Every Programmer Should Know</a> - визуализация задержек доступа к разным типам памяти.<br><a href="http://overbyte.com.au/misc/Pitfalls2009.pdf" target="_blank" rel="noopener">Pitfalls of Object Oriented Programming</a> - слайды с бенчмарками на PS3 с закрытого доклада Тони Альбрехта.<br><a href="https://youtu.be/VAT9E-M-PoE" target="_blank" rel="noopener">Pitfalls of Object Oriented Programming, Revisited - Tony Albrecht (TGC 2017)</a> - публичный доклад 2017 года Тони Альбрехта, бенчмарки для PC и PS4.<br><a href="https://solid-angle.blogspot.com/2010/02/musings-on-data-oriented-design.html" target="_blank" rel="noopener">Musings on Data-Oriented Design</a> - статья про то, что компиляторы преобразуют код, но не трогают данные.<br><a href="https://gamesfromwithin.com/data-oriented-design" target="_blank" rel="noopener">Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP)</a> - одна из первых статей о дизайне, ориентированном на данные, применительно к геймдеву</p><h2 id="Понятия"><a href="#Понятия" class="headerlink" title="Понятия"></a>Понятия</h2><p><strong><code>Размер объекта</code></strong> (<code>size</code>) - количество байт в памяти, которое занимает (на стеке или в куче) созданный экземпляр класса объекта. Размер объекта можно получить с помощью оператора <code>sizeof</code>. Если объект умеет выделять динамическую память в конструкторе (или любой другой функцией), естественно, компилятор не учитают это в размере самого объекта - подобные действия выполняются уже во время работы программы.</p><p><strong><code>Выравнивание</code></strong> (<code>alignment</code>) - способ размещения данных в памяти так, чтобы к ним можно было быстро обращаться (на некоторых процессорах к невыровненным данным вообще невозможно обратиться).<br>Процессор загружает данные из памяти не по одному байту, а по размеру <em>машинного слова</em>.</p><p>Например, на машине с 64-битной адресацией, если нужно загрузить адрес из памяти, то он должен быть выровнен в памяти по границе 8 байт (может находиться в памяти только по адресам, заканчивающимся на <code>0x0</code> или <code>0x8</code>). Если адрес <code>0x1122334455667788</code>, например, сохранён начиная с ячейки памяти <code>0x00000003</code> (в big-endian формате):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00000000: 00 00 00 00 00 11 22 33</span><br><span class="line">0x00000008: 44 55 66 77 88 00 00 00</span><br></pre></td></tr></table></figure><p>Процессор может загрузить только слова по адресам <code>0x00000000</code> или <code>0x00000008</code>. Таким образом, чтобы “собрать” нужный адрес, ему потребовалось по загрузить 2 слова <code>0x000000112233</code> и <code>0x4455667788000000</code> и произвести операции сдвига и совмещения адресов, что сильно дольше одной команды загрузки.</p><p>Получить выравнивание структуры с помощью оператора <code>alignof</code>.</p><p><strong><code>Padding</code></strong> (иногда переводят тоже как <code>выравнивание</code>, что может создать путаницу, так что если пусть называется <code>паддинг</code>) - добавление неиспользуемых байт после окончания описания какого-либо объекта в памяти так, чтобы следующий за ним объект оставался выровненным. Оператора, который бы позволил добраться до этих неиспользуемых байт, нет, но прочитать или записать их можно (лучше так никогда не делать).</p><p>В совсем тривиальных случаях <code>размер, выравнивание и паддинг</code> легко рассчитать, глядя на код, но при малейшем усложнении это резко становится сложным. Собственно, цель заметки - исследовать различные способы получения этой информации для компиляторов C++, используемых мной в работе, т.е. для ОС <strong><code>Windows/iOS/Android</code></strong> (<code>Visual C++</code> и <code>Clang</code>).</p><h2 id="Отладка-программы"><a href="#Отладка-программы" class="headerlink" title="Отладка программы"></a>Отладка программы</h2><p>Более продвинутый способ, чем ручной подсчёт - использование средств отладки программы (сюда я включаю сразу как точки остановки, так и просто диагностический вывод или использование подсказок ide компилятора). Для начала подойдёт простой вывод полученных чисел в консоль:<br><a href="https://gcc.godbolt.org/z/8fKa74j9n" target="_blank" rel="noopener">https://gcc.godbolt.org/z/8fKa74j9n</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> b1;</span><br><span class="line">  <span class="keyword">bool</span> b2;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> b1;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A):"</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(B):"</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//  sizeof(A):8</span></span><br><span class="line"><span class="comment">//  sizeof(B):12</span></span><br></pre></td></tr></table></figure></p><p>Посмотреть, где именно находится дополнительная “дырка” в структуре <code>B</code> можно с помощью макроса <a href="https://en.cppreference.com/w/cpp/types/offsetof" target="_blank" rel="noopener">offsetof</a>, хотя здесь проще перейти к способу с отладчиком.<br>Для идентификации данных в памяти можно “пометить” их при инициализации:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> b1 = <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">bool</span> b2 = <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> b1 = <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0xBBBBBBBB</span>;</span><br><span class="line">  <span class="keyword">bool</span> b2 = <span class="number">0x1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>При использовании <code>Visual Studio</code> можно вызвать посмотреть адрес переменной в окне <code>Locals</code>, и затем изучить содержимое памяти с помощью окна <a href="https://docs.microsoft.com/ru-ru/visualstudio/debugger/memory-windows?view=vs-2019" target="_blank" rel="noopener">Memory</a>.<br><img src="/blog/854775037/vs_memory_small.png" alt="vs-memory"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x002EB138  01 01 00 00  &lt;---  A.b1, A.b2, padding[2]</span><br><span class="line">0x002EB13C  aa aa aa aa  &lt;---  A.i</span><br><span class="line">0x002EB140  01 00 00 00  &lt;---  B.b1, padding[3]</span><br><span class="line">0x002EB144  bb bb bb bb  &lt;---  B.i</span><br><span class="line">0x002EB148  01 00 00 00  &lt;---  B.b2, padding[3]</span><br></pre></td></tr></table></figure></p><p>В <code>XCode</code> для просмотра памяти можно воспользоваться командой отладчика:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb &#x2F;12xb 0x002EB138</span><br><span class="line">&#x2F;&#x2F;вывести 12 байт в hex-формате, начиная с адреса 0x002EB138</span><br></pre></td></tr></table></figure><p>Небольшую хитрость при таком способе представляет лишь просмотр пространства в конце структуры, так как его сложнее пометить, но здесь можно воспользоваться наследованием (данные структуры наследника будут располагаться сразу за предком), массивом из нескольких структур, или просто скопировать все данные в непрерывный массив данных с помощью <code>memcpy</code>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> values[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(values, d1, <span class="keyword">sizeof</span>(A));</span><br><span class="line"><span class="comment">//можем изучать в отладчике содержимое values</span></span><br></pre></td></tr></table></figure><p>Собственно, если говорить о <a href="https://www.cplusplus.com/reference/type_traits/is_trivial/" target="_blank" rel="noopener">тривиальных типах данных</a> (без виртуальных функций или множественного/виртуального наследования), то на этом можно было бы и остановиться.</p><p>Таким способом можно изучать и сложные классы, некоторые так и делают, например, <a href="https://shaharmike.com/cpp/vtable-part1/" target="_blank" rel="noopener">статьи</a> Shakar Mike по исследованиям содержимого и формата таблиц виртуальной памяти. Однако при этом достаточно сложно на глаз определить работу в случаях, которые находятся за рамками тривиальных разобранных в статьях примерах. Так что лучше сразу читать спецификацию, которую использует <code>Clang</code> в том числе и для <code>iOS/Android</code> - <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#layout" target="_blank" rel="noopener">Itanium C++ ABI</a>.</p><p><em>не уверен, что это на 100% верно, но скрипты, которые анализируют размеры и расположение в памяти, использующие другие способы, показывают, что используется эти спецификация</em>.</p><p>Главное отличие в поведении компилятора <code>Visual C++</code> - он кладёт указатель на виртуальный базовый класс в сам объект, а не добавляет его в виртуальную таблицу класса.</p><p>Если <em>совсем кратко</em> и на пальцах объяснять виртуальное и множественное наследование - все невиртуальные предки располагаются перед собственными членами класса (в порядке объявления слева направо, но первый класс с таблицей виртуальных функций “всплывает” наверх), а все виртуальные предки - сразу за собственными членами.</p><p>Спецификация объясняет все особенности множественного и виртуального наследования, но всё равно, использовать отладчик на классах из реальных проектов сложно, потому что:</p><ul><li>В случае сложных иерархий можно просто запутаться в обычных и виртуальных наследниках</li><li>Тяжело изучать классы из std или чужих библиотек</li><li>Легко пропустить “дырки” в каких-нибудь классах</li><li>Сложно представить, какие данные в какую кеш-линию попадут</li></ul><p>Таким образом, вместо изучения программы методом запуска её с отладчиком и написанием диагностического кода хочется воспользоваться более продвинутыми способами.</p><h2 id="Изучение-способов-достать-информацию-о-типах"><a href="#Изучение-способов-достать-информацию-о-типах" class="headerlink" title="Изучение способов достать информацию о типах"></a>Изучение способов достать информацию о типах</h2><p>К сожалению, в C++ нет интроспекции, но <code>отладчик ведь как-то получает эту информацию</code>?</p><p>Собственно, об этом способе рассказывается в докладе о Ведьмаке.</p><p>Компилятор пишет её в отладочную секцию исполнимого файла в бинарном виде, откуда её могут прочитать какие-либо тулзы.</p><blockquote><p>Из этой информации кстати можно сделать полезный вывод о том, как работает сборка в режиме Release with Debug info - она не замедляет код, а просто добавляет в испонимый файл эту дебажную информацию, которую потом можно просто отрезать не пересобирая исполнимый файл.</p></blockquote><p>Автор доклада взял браузер отладочного формата (<a href="http://msinilo.pl/blog2/post/p425/" target="_blank" rel="noopener">статья</a>, сейчас <a href="https://issues.unrealengine.com/issue/UE-96827" target="_blank" rel="noopener">используется</a> где-то в <code>Unreal Engine</code>), который использует <code>Visual Studio</code>, и <a href="https://github.com/rdev0/PadAnalyzer/commits" target="_blank" rel="noopener">зафигачил</a> туда поддержку форматов PDB (отладочная база данных <code>Visual Studio</code> для x86/x64/XboxOne), и чтение отладочной информации в формате <code>Dwarf</code> из <code>Elf</code>-файлов (Switch, PS4).</p><p>В этом месте я очень обрадовался, так как Elf-файлы и отладочные секции в <a href="http://dwarfstd.org/" target="_blank" rel="noopener">формате Dwarf</a> - стандартные для <code>Unix</code>, а значит, был шанс, что получится загрузить в утилиту и бинарники для <code>iOS</code> и <code>Android</code>. С некоторыми усилиями я собрал тулзу и запустил её, но понял, что радоваться рановато - <code>iOS/macOS</code> бинарники не загружались, так как отличались от стандартного формата, но <code>Android</code> so-файл удалось загрузить! Но даже с ним возникли проблемы, оказалось, что тулза неправильно показывает расположение объектов с виртуальным наследованием - в Ведьмаке 3, видимо, не было сложных схем наследования, так что автор порта просто не обратил внимание на этот баг, но в моём проекте это широко использовалось.<br><img src="/blog/854775037/pad_analyzer_small.png" alt="pad_analyzer"></p><p>Было грустно, что <code>Pad Analyzer</code> <em>как будто</em> должен был подойти для изучения мобильных платформ, но не помог. Однако им можно было воспользоваться как референсом для других скриптов, так что я решил попробовать разобраться с Dwarf-форматом чуть детальнее.</p><p>С загрузкой <code>iOS/macOS</code> оказалось относительно просто - в Apple решили не писать в финальный бинарник отладочную секцию, а сохранить в нём просто айдишник, по которому может быть найден <strong><code>dsym</code></strong>-файл со ссылками на реальную отладочную информацию, находящуюся в <strong><code>*.o-файлах</code></strong>.</p><p>Ссылки с детальными объяснениями:<br><a href="https://stackoverflow.com/questions/10044697/where-how-does-apples-gcc-store-dwarf-inside-an-executable/12827463#12827463" target="_blank" rel="noopener">Ответ на stackoverflow</a> от программера из Apple.<br><a href="http://wiki.dwarfstd.org/index.php?title=Apple%27s_%22Lazy%22_DWARF_Scheme" target="_blank" rel="noopener">Apple’s “Lazy” DWARF Scheme</a> - “Ленивые дворфы от Эпл”<br><a href="https://stackoverflow.com/questions/24961746/what-the-structure-of-dsym-file" target="_blank" rel="noopener">Описание структуры dsym-файла</a> - со ссылкой на тулзу на Python, которая может загружать Mach-O файлы.</p><blockquote><p>Здесь тоже есть полезное знание о том, из-за чего XCode после перегенерации проекта вынуждена перекомпилировать все файлы - она не может расшарить отладочную информацию из предыдущих сборок.</p></blockquote><p>Pad Analyzer не умеет загружать <em>.o файлы, но можно было либо разобраться, как добавлять их, либо попробовать собрать пустой Elf-файл, и “пересадить” в него отладочную секцию из </em>.o файла. Звучит безумно, но задача выполнима:<br><a href="https://dzone.com/articles/converting-a-raw-binary-file-into-an-elfdwarf-file" target="_blank" rel="noopener">Converting a Raw Binary File Into an ELF/Dwarf File</a><br><a href="https://habr.com/ru/company/inforion/blog/460247/" target="_blank" rel="noopener">Рецепты для ELF-ов</a></p><p>Но, к счастью, по одной из ссылок я натолкнулся на библиотеку <a href="https://github.com/eliben/pyelftools" target="_blank" rel="noopener">pyelftools</a> и визуализатор dwarf-формата <a href="https://github.com/sevaa/dwex" target="_blank" rel="noopener">dwex</a>. Это был шаг вперёд, потому что он умел открывать 32- и 64-битные <code>.o-файлы для MacOSx</code>, собранные 32- и 64-бинарники для <code>.so бинарники для Android</code>, и 32-битные <code>.o бинарники для Android</code>. Оставалась проблема с тем, что <a href="https://github.com/eliben/pyelftools/issues/317" target="_blank" rel="noopener">не работали</a> 64-битные *.o-файлы для Android. </p><p>Сам <code>Dwarf Explorer</code> не предназначен для показа полной информации об объекте, но, раз у него есть дерево со ссылками на предков, можно написать свой алгоритм, который соберёт все данные.</p><h2 id="Статическое-изучение-отладочной-информации"><a href="#Статическое-изучение-отладочной-информации" class="headerlink" title="Статическое изучение отладочной информации"></a>Статическое изучение отладочной информации</h2><p>Я набросал примерно <a href="https://gist.github.com/spiiin/d9edf2c32f555b530b1413d632c14888" target="_blank" rel="noopener">такой скрипт</a> в <code>Jupyter</code> с использованием библиотеки <code>Dwex/pyelftools</code>, чтобы проверить результаты. После нескольких исправлений он работает <em>почти правильно</em> (не ходит рекурсивно по всем членам, из-за чего не может узнать их выравнивание, так что предполагает выравнивание в 8 байт (зачастую оказывается прав из-за того, что классы содержат указатели :), и сравнивает полученные рассчётами размер с тем, что записан в dwarf - так что можно узнать, корректно ли он отработал. Тем не менее, скрипт точно показывает <strong><code>относительное смещение</code></strong> каждого члена структуры и знает <strong><code>размер каждого члена</code></strong>, а значит, и <strong><code>паддинг</code></strong>, т.е. его в большинстве случаев можно использовать для того, чтобы найти “дыры” внутри структур.<br><img src="/blog/854775037/dwarf_pad_analyze_small.png" alt="dwarf-pad"></p><p>Пример вывода скрипта:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#39;alphaModeChanged&#39;      | 720 |&lt; 32&gt; | b&#39;function&lt;void (int)&gt;&#39;</span><br><span class="line">b&#39;texture&#39;               | 752 |&lt; 16&gt; | b&#39;sharedResource&lt;tex&gt;&#39;</span><br><span class="line">b&#39;maskTexture&#39;           | 768 |&lt; 16&gt; | b&#39;sharedResource&lt;tex&gt;&#39;</span><br><span class="line">b&#39;maskRender&#39;            | 784 |&lt;  8&gt; | b&#39;ptr render&#39;</span><br><span class="line">b&#39;alphaModeCoefficient&#39;  | 792 |&lt;  4&gt; | b&#39;float&#39;  </span><br><span class="line">b&#39;batching&#39;              | 796 |&lt;  1&gt; | b&#39;bool&#39;   </span><br><span class="line">b&#39;drawOnlyAdditive&#39;      | 797 |&lt;  1&gt; | b&#39;bool&#39;   </span><br><span class="line">b&#39;mode&#39;                  | 798 |&lt;  1&gt; | b&#39;blendMode&#39;</span><br><span class="line">b&#39;flipX&#39;                 | 799 |&lt;  1&gt; | b&#39;bool&#39;   </span><br><span class="line">b&#39;flipY&#39;                 | 800 |&lt;  1&gt; | b&#39;bool&#39;   </span><br><span class="line">b&#39;logged&#39;                | 801 |&lt;  1&gt; | b&#39;bool&#39;   </span><br><span class="line">---padding---            | 802 |&lt;  6&gt; | ---unused---</span><br><span class="line">b&#39;texturePart&#39;           | 808 |&lt;  8&gt; | b&#39;ptr texPart&#39;</span><br><span class="line">b&#39;part&#39;                  | 816 |&lt; 24&gt; | b&#39;basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;&#39;</span><br><span class="line">b&#39;maskImageSize&#39;         | 840 |&lt;  8&gt; | b&#39;pair&lt;float, float&gt;&#39;</span><br><span class="line">b&#39;needHitTest&#39;           | 848 |&lt;  1&gt; | b&#39;bool&#39;   </span><br><span class="line">           padded offset: 848</span><br><span class="line">^^^------- sprite--------^^^</span><br></pre></td></tr></table></figure></p><p>Для Linux есть утилита <a href="https://lwn.net/Articles/335942/" target="_blank" rel="noopener">pahole</a> и скрипт <del><a href="https://github.com/arvidn/struct_layout" target="_blank" rel="noopener">struct_layout</a> (он использует linux утилиту dwarfdump)</del> (сырая и не работает), которые также умеют показывать пустоты внутри структур, но мне не удалось завести их <code>Android/iOS</code>.</p><h2 id="Получение-данных-от-Clang-во-время-компиляции"><a href="#Получение-данных-от-Clang-во-время-компиляции" class="headerlink" title="Получение данных от Clang во время компиляции"></a>Получение данных от Clang во время компиляции</h2><p>Другой интересный подход - <code>Clang</code> с ключом <strong><code>-Xclang  -fdump-record-layouts</code></strong> (<a href="https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/" target="_blank" rel="noopener">статья</a>) выводит прямо в stdout данные о расположении структур в памяти (аналогично, для <code>Visual C++</code> - <strong><code>/d1reportAllClassLayout</code></strong>.</p><p>Это удобно для небольших типов, пример: <a href="https://gcc.godbolt.org/z/3fev6fc5d" target="_blank" rel="noopener">https://gcc.godbolt.org/z/3fev6fc5d</a>, но на реальных проекта выдаёт несколько десятков мегабайт текста на каждый файл (так что приходится не добавлять ключ в <code>XCode/Android Studio</code>, а просто скопировать командную строку из среды разработки и вызывать её из консоли для одного файла, иначе есть риск получить десятки гигабайт текста).</p><p>Тогда можно набросать <a href="https://gist.github.com/spiiin/9b19c549d1367fb00ad301896423a82b" target="_blank" rel="noopener">скрипт</a>, который парсит текстовый вывод и отображает его в виде дерева:<br><img src="/blog/854775037/string_ndk_small.png" alt="string-ndk"><br><em>(если анализировать не stl, а свои типы, то всё выглядит понятнее)</em></p><p>Этот подход показывает корректные <strong><code>выравнивания</code></strong> всех структур, но Clang не показывает <strong><code>размеры</code></strong> вложенных членов (на скриншоте размеры, полученные другим способом), а значит, в таком выводе не видны <strong><code>паддинги</code></strong>.</p><p>Cкорее всего можно получить все нужные данные от Clang, если не охотится за его выводом в текстовом виде, а использовать его <a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">API</a>, однако его компиляция - отдельное приключение =\ Кажется, <a href="https://github.com/def-/ycmd/commit/2a7124bcb5730f301e3e73a4af81316bbff81926" target="_blank" rel="noopener">что-то подобное</a> - обращение к libclang за размером типы и выравниванием).</p><h2 id="Выводы"><a href="#Выводы" class="headerlink" title="Выводы"></a>Выводы</h2><p>Если немного заморочиться с написанием вспомогательных скриптов (каждый из них пока не доделан до конца, когда-нибудь я их закончу), то можно заглянуть сквозь тему внутрь объектов. Только осторожно, есть шансы наткнуться там на упырей, питающихся памятью, с которыми потом придётся начинать бороться!<br><img src="/blog/854775037/shadows_small.png" alt="shadows-small"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Обычно на вопрос о расположении объекта в памяти программисты C++ отвечают “это зависит от реализации”, а как именно зависит - не особо понимают. Это действительно практически не нужно знать для написания корректных программ, но может пригодиться для написания быстрых.&lt;/p&gt;
&lt;p&gt;После просмотра доклада об оптимизации &lt;code&gt;Witcher 3&lt;/code&gt; для Switch (&lt;a href=&quot;https://www.gdcvault.com/play/1026635/-Witcher-3-on-the&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;видео&lt;/a&gt; на 14:28), я решил проверить, возможно ли получить информацию об расположении объектов в памяти таким же или похожим способом для телефонов.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://spiiin.github.io/tags/c/"/>
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Runtime-полиморфизм в C++</title>
    <link href="http://spiiin.github.io/blog/1552834708/"/>
    <id>http://spiiin.github.io/blog/1552834708/</id>
    <published>2021-05-31T19:50:18.000Z</published>
    <updated>2021-05-31T22:04:41.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ссылки по нестандартному способу организации полиморфизма в C++, а также материалы Шона Пэрента (Adobe) по архитектуре программ.<br><a id="more"></a></p><p><code>Лекция про организацию неинклюзивного полиморфизма</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/QGcVXgEVMJg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br><em>“My class T inherits from nothing”</em></p><p>Также может послужить небольшим туториалом по rvalue-ссылкам и обзором преимуществ использование value-семантики для перемещаемых объектов.</p><p>Доклад является часть серии <strong><code>Better Code</code></strong> (<a href="https://sean-parent.stlab.cc/papers-and-presentations/" target="_blank" rel="noopener">тут</a> все доклады и дополнительные статьи).</p><p>Часть из них посвящена формальному математическому подходу к построению структур данных и алгоритмов, частично базируется на книге Александра Степанова и Пола Мак-Джонса <a href="http://elementsofprogramming.com/" target="_blank" rel="noopener">Elements of programming</a> (в интернете можно откопать русский перевод) и заметках <a href="http://stepanovpapers.com/notes.pdf" target="_blank" rel="noopener">Notes of Programming</a>. Но некоторые представляют интерес не только со стороны фундаментальной подготовки.</p><p><code>Другие лекции и материалы Шона</code><br><a href="https://youtu.be/2KGkcGtGVM4" target="_blank" rel="noopener">Sean Parent - Polymorphic Task</a> - подход, применяемый в первой статье, для написания класса task за 10 минут.<br><a href="https://sean-parent.stlab.cc/presentations/2013-03-05-language-delay/language-delay.pdf" target="_blank" rel="noopener">Language Delay</a> - чистый C++ позволяет использовать 0.25% производительности компьютера (объяснение, где скрыты остальные 99.75% на <a href="https://youtu.be/zULU6Hhp42w?t=938" target="_blank" rel="noopener">видео</a>).<br><img src="/blog/1552834708/desktop_power.png" alt="desktop-power"><br><a href="https://youtu.be/ejF6qqohp3M" target="_blank" rel="noopener">Sean Parent “Better Code: Relationships”</a> - про отношения между объектами в коде. Цель - написание кода без противоречий. Объяснение идеи контрактов и концептов.<br><blockquote><p>Архитектура - это искусство проектировать и конструировать структуры</p></blockquote><br><a href="&quot;https://stlab.cc/tips/about-mvc.html&quot;">How did MVC get so Fed up?</a> - описание “правильного” паттерна MVC версии Smalltalk. Видео-версия объяснения проблемы - в докладе <a href="https://youtu.be/0WlJEz2wb8Y?t=877" target="_blank" rel="noopener">“Better Code: Human Interface”</a>. Цель правильного UI - <strong>не врать</strong>. Другой подход к упрощению ui - парадигма <em>immediate gui</em> и <a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">Dear ImGui</a> как известный её представитель. Ещё цитата из доклада:<br><blockquote><p>Таксономия всего в программе - коллекции, объекты, свойства, операции, отношения.</p></blockquote></p><p><code>Доклад, использующий идею runtime-полиморфизма</code><br><a href="https://youtu.be/gVGtNFg4ay0" target="_blank" rel="noopener">Louis Dionne “Runtime Polymorphism: Back to the Basics”</a> - про разные способы соединения классов с их виртуальным таблицами.</p><p><code>REPL-интерпретатор C++ кода</code><br><a href="https://github.com/root-project/cling" target="_blank" rel="noopener">Cling</a> - удобен для экспериментов в стиле первого доклада.</p><p>С первым днём лета, пусть ваш код код остаётся простым и надёжным!</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ссылки по нестандартному способу организации полиморфизма в C++, а также материалы Шона Пэрента (Adobe) по архитектуре программ.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Заметки о языках программирования</title>
    <link href="http://spiiin.github.io/blog/2297379949/"/>
    <id>http://spiiin.github.io/blog/2297379949/</id>
    <published>2021-05-26T15:57:06.000Z</published>
    <updated>2021-06-09T15:22:15.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Заметки о языках программирования<br><a id="more"></a></p><h1 id="Императивные-языки"><a href="#Императивные-языки" class="headerlink" title="Императивные языки"></a>Императивные языки</h1><h2 id="Си"><a href="#Си" class="headerlink" title="Си"></a>Си</h2><p>Хороший старт для изучения C или программирования вообще - книжка <strong><code>Кернига и Ритчи &quot;Язык программирования Си&quot;</code></strong> (TCPL).</p><p><em>После прочтения её обнаружил, что курс программирования на C++ в моём университете был на 80% взят из этой книги (и оставшие 20% - краткий рассказ про классы</em></p><p>Информации по современному си не очень много, но найти-таки можно:<br><a href="https://floooh.github.io/2019/09/27/modern-c-for-cpp-peeps.html" target="_blank" rel="noopener">Modern C for C++ Peeps</a><br><a href="https://floooh.github.io/2018/06/02/one-year-of-c.html" target="_blank" rel="noopener">One year of C</a><br><a href="https://youtu.be/QpAhX-gsHMs" target="_blank" rel="noopener">Modern C and What We Can Learn From It - Luca Sas</a> - паттерны современного Си.</p><h2 id="Ortodox-C"><a href="#Ortodox-C" class="headerlink" title="Ortodox C++"></a>Ortodox C++</h2><p><a href="https://gist.github.com/bkaradzic/2e39896bc7d8c34e042b" target="_blank" rel="noopener">Orthodox C++</a> - подход к использованию C++, с использованием небольшого подмножества языка, улучшающего Cи, но с отказом от современных фич, усложняющих понимание кода. Основная цель - упростить понимание написанного кода и исключить скрытые от программиста неочевидные эффекты.<br><a href="https://www.polymonster.co.uk/blog/not-so-modern-cpp" target="_blank" rel="noopener">Not so modern C++</a> - статья Alex Dixon о выборе практичных частей C++.</p><h2 id="Zig"><a href="#Zig" class="headerlink" title="Zig"></a>Zig</h2><p><a href="https://ziglang.org/" target="_blank" rel="noopener">Zig</a> - язык, который пытается исправить недостатки Си не надстройкой сверху, а изменением и удалением фич. Основные идеи (с сайта) - исключить скрытые эффекты, выделения памяти и макросы. Из добавлений - улучшение обработки ошибок, вычислений времени компиляции, что интересно - имеет в комплекте небольшой быстрый компилятор Си и систему сборки. Выглядит как небольшая и аккуратная альтернатива Си для тех, кому нужен Си вместо C++.<br><a href="https://youtu.be/Z4oYSByyRak" target="_blank" rel="noopener">Zig: A programming language designed for robustness, optimality, and clarity –  Andrew Kelley</a><br><a href="https://youtu.be/Gv2I7qTux7g" target="_blank" rel="noopener">The Road to Zig 1.0 - Andrew Kelley</a></p><h2 id="Jai"><a href="#Jai" class="headerlink" title="Jai"></a>Jai</h2><p>Разрабатываемый автором игр Braid и The Witness язык программирования для игр. Доступных компиляторов пока нет, основные идеи изложены в цикле видео:<br><a href="https://www.youtube.com/watch?v=TH9VCN6UkyQ&amp;list=PLmV5I2fxaiCKfxMBrNsU1kgKJXD3PkyxO&amp;ab_channel=JonathanBlowJonathanBlow" target="_blank" rel="noopener">Jonathan Blow - A Programming Language for Games</a>.<br>Короткое резюме по основным фичам (также много интересного про <code>C++</code>):<br><a href="https://youtu.be/roLD9-TA06Q" target="_blank" rel="noopener">The Jai Programming Language and What Can We Learn From It - Luca Sas [ACCU 2019]</a><br><a href="https://youtu.be/uZgbKrDEzAs" target="_blank" rel="noopener">Jon Blow’s Design decisions on creating Jai a new language for game programmers</a></p><p>В языке много решений проблем, специфических для разработки игр. Навскидку, фичи - рефлексия, Data-oriented-design паттерны, выполнение кода и и кеширование результатов в compile-time, удобство рефакторинга (похожие синтаксические формы для анонимных-функций, блоков кода и методов), возможности по настройке расположения объектов в памяти, кастомные аллокаторы, стандартная библиотека в стиле SDL. Выглядит вкусно, хотелось бы увидеть в действии.</p><h1 id="Отступление-1-Эффективность-языка"><a href="#Отступление-1-Эффективность-языка" class="headerlink" title="Отступление 1. Эффективность языка"></a>Отступление 1. Эффективность языка</h1><p>Что мы вообще ожидаем от языков программирования и почему пользуемся теми или иными?<br>Я немного касался этой темы в заметке <a href="/blog/3652741154/" title="10 лет в геймдеве">10 лет в геймдеве</a> в разделах <strong><code>&quot;Языки программирования&quot;</code></strong> и <strong><code>&quot;Культура разработки&quot;</code></strong>, а также в заметке <a href="/blog/1808122922/" title="Nim in imaginary world">Nim in imaginary world</a> в разделе <strong><code>Критерии выбора языка</code></strong>.</p><p>С помощью программирования мы решаем определённые задачи, и выбор языка в первую очередь в первую очередь состоит в том, насколько эффективно он позволяет решать определённый класс задач. Языки общего назначения позволяют решать широкий спектр задач, но в решении некоторых одни оказываются эффективнее других по какому-либо критерию.</p><blockquote><p>Эффективность языка в решении задач - главный технический критерий языка программирования</p></blockquote><p>Языки, перечисленные выше, выбирают таким критерием <code>скорость работы конечной программы</code> - дизайн этих языков построен так, чтобы в ходе решения программист мог оценить, какой по быстродействию код получится на выходе. Примеры задач, для которых этот критерий является важным:</p><ul><li>построение систем, которые должны работать без задержек</li><li>выполнение на компьютерах с ограниченными ресурсами</li><li>задачи, в которых требуется максимальное быстродействие</li></ul><p>С другой стороны, под эффективностью часто подразумевают <code>скорость решения задачи на выбранном языке</code>. Этот критерий во многих категориях задач перевешивает эффективность работы самой программы, поэтому ради того, чтобы решить задачу быстро, быстродействием программы пренебрегают в пользу абстракций более высокого уровня, а также “защиты от дурака” со стороны компилятора.</p><p>В этом случае критерием эффективности является простота использования языка. Важно не то, как много фич поддерживается языком, а то, насколько хорошо компилятор понимает, что мы хотим ему сказать. Чем больше он может сделать за нас – тем лучше. Любое усложнение языка/компилятора должно в конечном счёте увеличивать производительность программиста/команды.</p><p>Ещё один важный критерий эффективности (точнее, совокупность критериев) - <code>&quot;поддерживаемость&quot; языка</code>. Я понимаю под этим общую распространённость и доступность - в какой форме осуществляется поддержка компилятора и тулзов к нему (IDE, отладчики, системы сборки, менеджеры зависимостей etc), как часто язык меняется, как легко найти в интернете решение типичных проблем, и насколько сложно найти других программистов, которые готовы и способны изучить язык и писать на нём код. Это важно для любых языков, которые претендуют на то, чтобы быть востребованными в профессиональной разработке.</p><p>Из-за этого критерия часто для решения задач могут быть выбраны язык, программы на которых получаются медленными и пишутся долго, но которые хорошо поддерживаются - являются стандартом в индустрии, или за которыми стоят большие корпорации, и которые любят учить разработчики, чтобы много зарабатывать (<em>не буду показывать пальцем на такие языки</em>).</p><h1 id="Отступление-2-Масштабируемость"><a href="#Отступление-2-Масштабируемость" class="headerlink" title="Отступление 2. Масштабируемость"></a>Отступление 2. Масштабируемость</h1><p>Главным критерием выбора языка для создания на нём больших систем является <code>возможность писать масштабируемые программы</code>. А в программировании рано или поздно любая система становится большой.</p><p>Важность этого критерия сложно описать в паре абзацев, и под этой эффективностью можно понимать очень многое. Например, можно перечислить:</p><ul><li>Поддерживаемые парадигмы программирования</li><li>Способы для разделения частей программы (классы, модули)</li><li>Спектр задач, которые можно решать с помощью одного языка</li><li>Платформа (доступность библиотек, способ взаимодействия между частями системы)</li><li>Совместимость системы созданной на языке, с различными аппаратными платформами и с другими системами (в том числе, на других языках)</li></ul><p>В конечном счёте, язык должен помочь справится с двумя видами сложности, возникающими при масштабируемости программы:</p><ul><li>“Сложность в ширину” - растущий объем кода, который нужно разделять на независимые части</li><li>“Сложность в высоту” - поддержка абстракций более высокого семантического уровня</li></ul><p>Императивные языки, перечисленные выше, относятся к языкам среднего уровня, в которых можно проследить, какой код получается на выходе.</p><p>Высокоуровневые языки я бы разделил на две категории по тому, какой вид сложности они хотят сделать простым.</p><p>Одна из причин успеха “объектно-ориентированных языков” (<code>C++</code>, <code>Java</code>, <code>C#</code>, когда-то <code>Delphi</code>) - это их способ борьбы со “сложностью в ширину”. Концепции, которые применяются в них для борьбы с этой сложностью, похожие, из-за чего программисты часто не видят особой разницы между этими языками и способны быстро изучать похожие новые языки.</p><p>Не сильно отличаются и другие языки из этой группы, которые берут на себя роль либо “склеивающих языков” (<a href="https://www.osp.ru/os/1998/03/179470" target="_blank" rel="noopener">Сценарии: высокоуровневое программирование для XXI века</a> - важная статья, описывающая такое применение, скриптовые - <code>Python</code>, <code>Perl</code>, <code>Tcl</code>, <code>JavaScript</code>), либо “языков управления частями программы” (<code>Python</code>, <code>Lua</code>, <code>Squirell</code>), жертвуя эффективностью ради некоторого повышения “сложности в высоту” - возможности отойти дальше от уровня железа.</p><p>Видео, которое достаточно просто и понятно объясняет, почему все языки программирования из Top-10 рейтингов - ООП-языки - <strong><code>Why Isn&#39;t Functional Programming the Norm? – Richard Feldman</code></strong> (несмотря на название, оно про причины популярности языков и не касается функционального программирования):<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/QyJZzq0v7Z4" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Из-за того, что дизайн этих языков сосредоточен вокруг решения проблемы уменьшения “сложности в ширину”, встаёт вопрос о том, как они решают проблему роста “сложности в глубину”, возникающей в ходе дальнейшей эволюции систем. Один из найденных путей - <code>создание вокруг языка стандартной платформы</code>, которая является нижним уровнем абстракции сама по себе (т.е. “прячет” от программиста решение низкоуровневых проблем и даёт большой набор библиотек для решения стандартных задач).</p><p>Цена такого подхода решения проблемы - языки работающие над платформой становятся уже немного менее “общего назначения” за счёт зависимости от своей платформ.</p><p>Примеры - самые известные и популярные - <code>.Net</code>, <code>Java</code> (общего назначения, над которыми сверху строились специальные новые языки), сильно уступающие по популярности платформы для Smalltalk типа <code>Pharo</code>. “Развёрнутый” случай - платформы, выстроенные над языком для решения более-менее конкретной задачи, вроде <code>Jupyter</code> для Python, <code>Rails</code> для Ruby, <code>Otp</code> для Erlang. Слитые вместе язык и платформа для ещё более конкретных целей - языки типа <code>Matemathica</code> или <code>J</code>.</p><p>Я не вижу особого смысла писать про какие-то из этих языков, потому что они мейнстримные и так у всех на слуху, а информации по них в интернете хватает. Остановлюсь только немного на C++, так как использую его в работе над играми, а затем перейду к менее известным языкам, которые пытаются решать проблему возрастания сложности “в высоту”.</p><h1 id="С"><a href="#С" class="headerlink" title="С++"></a>С++</h1><p>C++ - язык с богатой историей, выросший из C. Начальная история языка описана самим автором в книге <strong><code>&quot;Дизайн и эволюция C++&quot;</code></strong>. Книга сложная для чтения и бесполезная с точки зрения изучения языка, интересна именно с точки зрения того, в каких условиях находился Бьярн Страуструп в то время, когда проектировал первую версию языка.</p><p>Бьярн пользовался языком C, и решал проблему “сложности в ширину”, добавив в C классы, чтобы с помощью них решить проблему масштабируемости. Инкапсуляция в языке решает проблему роста сложности в ширину, а наследование и полиморфизм - в глубину. История с ООП и классами хорошо освещается в видео <strong><code>Why Isn&#39;t Functional Programming the Norm?</code></strong>, которое было приведено в предыдущем разделе.</p><p>Отдельный интерес представляет постановка задачи сохранения максимальной обратной совместимости с C - как улучшить язык, не ломая то, что уже построено с помощью подмножества этого языка. Многие программисты сталкиваются с такой проблемой при улучшении своих фреймворков, движков, инструментов, и эта книга - одна из немногих, где описывается подход к решению аналогичных проблем на уровне проектирования языка программирования. Один из принципов добавления новых возможностей в C++ после создания <code>C with Classes</code> - делать так, чтобы получалось не медленнее, чем в C, потому что иначе программисты на C не будут этим пользоваться.</p><p>Также в книге много обсуждений того, как могли бы выглядеть различными варианты синтаксиса и ограничений, и почему был выбран именно тот вариант, который существует в C++. Важным требованием было использование существующего компоновщика C, т.е. C++ строился как платформа над C, чтобы получить возможность использования уже созданных инструментов (это требование всё равно накрылось с добавлением шаблонов - нормальные реализации требуют знаний о других единицах компиляции).</p><p>Кстати, отдельный вопрос, тоже связанный с языками программирования - почему получилось так, что на языке C было написано много кода? Детальный ответ есть в книге Эрика Раймонда <strong><code>&quot;Философия программирования под Unix&quot;</code></strong> – C был языком Unix, а Unix была операционной системой раннего интернета, и именно вокруг Unix образовалась хакерская субкультура и концепция свободного программного обеспечения. Отсюда видна ещё одна важная функция языка:<br><blockquote><p>Умение программировать на правильном языке означает причастность к сообществу/субкультуре программистов</p></blockquote></p><p>(<em>я так когда-то чтобы понимать о чём пишут русскоязычные “функциональные” программисты в ЖЖ на начальном уровне изучил ocaml и haskell</em>)</p><p>Другая интересная тема из книги - создание и формат работы комитета C++, после которых удивляешься, как вообще язык движется вперёд, настолько это бюрократическая и политическая структура. При этом язык пытается учитывать интересы очень широкого круга программистов, использующих его.</p><p>Ещё один принцип дизайна – не добавлять фичи в язык без тщательного обдумывания, под девизом “Помни о <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D0%B7%D0%B0_(%D0%BA%D0%BE%D1%80%D0%B0%D0%B1%D0%BB%D1%8C" target="_blank" rel="noopener">Vasa</a>)” (которым Страуструп стращает всех <a href="https://www.stroustrup.com/P0977-remember-the-vasa.pdf" target="_blank" rel="noopener">до сих пор</a>). Хотя глядя на новые стандарты и все возможные правила и исключения, язык стоило бы назвать Vasa – C++ выглядит языком, который нужно продолжать изучать постоянно и бесконечно. Поэтому вместо добавления чего-то в ядро языка, это предлагается добавлять в сторонние библиотеки.</p><p>Тем не менее, C++ можно использовать, зная только некоторые его подмножества, спасибо ему хотя бы за это. Также С++ - это язык, на котором можно написать кроссплатформенный игровой движок, который с относительно небольшими усилиями будет почти одинаково работать под iOS/android/консоли/windows/mac/unix.</p><h1 id="Отступление-3-Масштабируемость-вверх"><a href="#Отступление-3-Масштабируемость-вверх" class="headerlink" title="Отступление 3. Масштабируемость вверх"></a>Отступление 3. Масштабируемость вверх</h1><p>Рост сложности “в ширину” мешает программистам работать над частями системы параллельно, и архитектуры, направленные на то, чтобы снизить эту сложность, “изолируют” подсистемы друг от друга. Хорошая книга про поиск способов борьбы с этой сложностью - <strong><code>&quot;Мифический человеко-месяц&quot;</code></strong> Фредерика Брукса.</p><p>Проблема роста сложности “в глубину” пока не особо волнует рядовых разработчиков, хотя способы справится с ней исследуются давно. Одно из её проявлений - ощущение того, что решение задач на “обычных” языках выглядит громоздко, требует написание большого количества повторяющегося кода, а подсистемы в большом количестве повторяют один и тот же функционал.<br><a href="https://www.computerra.ru/183817/steps/" target="_blank" rel="noopener">Система STEPS</a> - статьи об исследовании под руководством <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D0%B9,_%D0%90%D0%BB%D0%B0%D0%BD_%D0%9A%D1%91%D1%80%D1%82%D0%B8%D1%81" target="_blank" rel="noopener">Алана Кея</a>, целью которого является поиск методов написать операционную систему на порядки меньшую по количеству строк кода, чем существующие.</p><p>Что интересно, исследования таких методов проводились ещё в 50х – рекурсивное описание языков, на которых пишутся более сложные языки, на которых пишутся ещё более сложные языки. В  <strong><code>&quot;Руководстве пользователя Lisp 1.5&quot;</code></strong> уже на 13-й странице в качестве примера даётся небольшая программа, которая является интерпретатором Лиспа на Лиспе (это скорее “фрактальный рост сложности”) – это книга также вполне может быть первым учебником по программированию.</p><p>Способы создания новых языков, соответствующих предметной области - это либо отдельные утилиты для создания <a href="https://comp590-19s.github.io/" target="_blank" rel="noopener">“маленьких языков”</a>, либо языки с системой макросов для расширения, сужения или изменения собственного синтаксиса, либо платформы для создания языков.</p><p>Классификация и терминология приводятся в книге Мартина Фаулера <strong><code>&quot;Предметно-ориентированные языки программирования&quot;</code></strong>.</p><p><a href="https://habr.com/ru/post/258667/" target="_blank" rel="noopener">Метапрограммирование: какое оно есть и каким должно быть</a> - небольшая статья с обзором возможностей макросов в разных языках.</p><h1 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h1><p>Примеры способов описания Domain Specific Languages без циклического “повышения” сложности языков.</p><p><code>Лексические и текстовые макросы</code><br>Иногда для кодогенерации достаточно обычной текстовой подстановки в шаблоны (templating engine, <a href="https://en.wikipedia.org/wiki/Comparison_of_code_generation_tools" target="_blank" rel="noopener">сравнение движков для подстановки</a>). Пример практического использования - статья <a href="https://habr.com/ru/company/playrix/blog/467827/" target="_blank" rel="noopener">Как мы делали нашу маленькую Unity с нуля</a>, раздел <code>генератор кода</code> (парсинг размеченного файла, и замена в нём текста по шаблону на другой текста) или <code>макросы QT</code>.</p><p>Примеры DSL, не связанные с компьютером - <a href="https://alg.cubing.net/" target="_blank" rel="noopener">нотация вращения кубика Рубика</a> (интерпретатор - человек, семантическая модель - кубик Рубика), <a href="https://jugglinglab.org/anim?423" target="_blank" rel="noopener">жонглёрская нотация - siteswap</a> (кстати, возможно один из авторов - <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%BD%D0%BD%D0%BE%D0%BD,_%D0%9A%D0%BB%D0%BE%D0%B4" target="_blank" rel="noopener">Клод Шеннон</a>).</p><p><code>Hexo</code>, <code>Jekyll</code>, и другие статические генераторы сайтов, хороший пример использования множества DSL, используют набор языков и надстроек над ними для генерации сайта - html, js, css, markdown, hexo nunjacks, sass + можно подключить свой парсер на javascript).</p><p><code>mermaid</code>, <code>dot</code> и другие языки описания графов.</p><p><code>JavaScript</code> как язык преобразований над DOM.</p><p><code>Ruby on Rails</code> - пример использования языка, синтаксис которого достаточно гибкий, чтобы выглядеть как DSL без непосредственного написания DSL.</p><p><code>Cmake</code> и другие декларативные системы сборки</p><h1 id="Языки-для-создания-языков"><a href="#Языки-для-создания-языков" class="headerlink" title="Языки для создания языков"></a>Языки для создания языков</h1><p>Большинство языков поддерживают различные парадигмы, из-за чего многие программисты видят в новых изучаемых языках только ту часть, которую они знали до этого - <em>“На любом языке можно написать фортрановскую программу”</em></p><p><em>Языки программирования можно разделить по разным критериям: императивные, прикладные, логические, проблемно-ориентированные, и т.д. Но возникает ощущение, что все они представляют собой либо «агглютинацию (сочетания) свойств», либо «кристаллизацию стиля». COBOL, PL/1, Ada, и т.д., принадлежат к первому типу, а LISP, APL и Smalltalk – ко второму. Алан Кей</em></p><h2 id="Генераторы-анализаторов"><a href="#Генераторы-анализаторов" class="headerlink" title="Генераторы анализаторов"></a>Генераторы анализаторов</h2><p><code>Lex/Yack</code>, <code>Antlr</code> и подобные утилиты служат генерации анализаторов грамматик языков. Парсер на выходе выдаёт абстрактное синтаксическое дерево, которое может быть обработано компилятором, или другим анализатором этого дерева. Если нужен свой микроязык или отличный от стандартных формат данных, с которым не может справится элементарное разбиение на лексемы из языка программирования - то можно попробовать.<br><em>Я один раз в жизни возился с таким самописным генератором шейдеров из самописного языка в hlsl и glsl и помню, что разобраться в этом было достаточно сложно</em></p><h2 id="Meta-Programming-System"><a href="#Meta-Programming-System" class="headerlink" title="Meta Programming System"></a>Meta Programming System</h2><p><a href="https://www.jetbrains.com/mps/" target="_blank" rel="noopener">Jetbrains MPS</a> - система для создания языков. В отличие от генераторов анализаторов, на выходе получается не голое абстрактное дерево, а язык, полностью интегрированный с продвинутой средой разработки.<br><a href="https://rsdn.org/article/philosophy/LOP.xml" target="_blank" rel="noopener">Языково-ориентированное программирование: следующая парадигма</a> - статья от Сергея Дмитриева, автора системы и концепции.<br><a href="https://martinfowler.com/articles/languageWorkbench.html" target="_blank" rel="noopener">Language Workbenches: The Killer-App for Domain Specific Languages?</a> - Мартин Фаулер про Language Oriented Programming.</p><h2 id="Nemerle"><a href="#Nemerle" class="headerlink" title="Nemerle"></a>Nemerle</h2><p><a href="http://nemerle.org" target="_blank" rel="noopener">Nemerle</a> - язык с мощными макросами, позволяющий изменять синтаксис и использовать расширение синтаксиса как библиотеки. Фичи Nemerle постепенно перетекают в C#.<br><a href="https://rsdn.org/summary/3766.xml" target="_blank" rel="noopener">Серия статей на русском</a>.<br>Изначально был написан под .Net, что являлось как плюсом для быстрой разработки компилятора, так и минусом. В процессе разработки был создан фреймворк для разработки языков N2, позже переименованный в <a href="https://github.com/rsdn/nitra" target="_blank" rel="noopener">Nitra</a>. В дальнейшем автор хотел описать через Nitra C# и другие языки, в том числе создать на ней новую версию Nemerle. Проект масштабный, перешёл от разработки по фану к JetBrains, а затем снова вернулся к фанатской разработки одним человеком, к сожалению.<br><a href="https://youtu.be/HSPivYkQ2t4" target="_blank" rel="noopener">CLRium #3: Язык программирования Nemerle (Влад Чистяков)</a><br><a href="https://youtu.be/O693I7Yk4GY" target="_blank" rel="noopener">CLRium #3: Nitra. Средство создания языков программирования и не только (Влад Чистяков)</a>.</p><h2 id="Nim"><a href="#Nim" class="headerlink" title="Nim"></a>Nim</h2><p><a href="https://nim-lang.org/" target="_blank" rel="noopener">Nim</a> - ещё один язык с макросами позволяющими строить и модифицировать AST во время компиляции программы.<br>Мои заметки про Nim:<br><a href="/blog/1808122922/" title="Nim in imaginery world">Nim in imaginery world</a> (особенности языка и выполнения кода во время компиляции)<br><a href="/blog/3170392974/" title="Nim vk-get-pictures">Nim vk-get-pictures</a> (в конце ссылки на примеры DSL на языке)<br><a href="https://youtu.be/8SoJR3sCaR4" target="_blank" rel="noopener">C++ as Assembly 2.0 - Hello Nim - Viktor Kirilov - code::dive 2019</a> - доклад про возможности Nim от Виктора Кирилова (ещё один интересный <a href="https://youtu.be/7WgCt0Wooeo" target="_blank" rel="noopener">доклад про hot-code reload</a> от него).<br>Основные тезисы доклада, что даёт метапрограммирование в <code>Nim</code>:</p><ul><li>Более высокий уровень уровень zero-cost абстракций:<ul><li>помогает использовать паттерны</li><li>помогает увеличить читаемость и поддерживаемость кода</li></ul></li><li>Помогает строить DSL-и<ul><li>DSL для HMTL</li><li>DSL для построения интерфейсов к библиотекам GUI и биндингов</li></ul></li><li>Ручное написание сериализации/десериализации в прошлом<ul><li>интерация по полям структур во время компиляции - больше нельзя что-нибудь пропустить</li></ul></li><li>Не нужно 3rd-party движков для кодогенерации на уровне макросов или текста</li></ul><h2 id="Racket"><a href="#Racket" class="headerlink" title="Racket"></a>Racket</h2><p><a href="https://racket-lang.org/" target="_blank" rel="noopener">Racket</a> - язык семейства Lisp/Scheme. Позволяет создавать свои языки, в том числе и не лиспоподобные.<br><a href="https://beautifulracket.com/" target="_blank" rel="noopener">Beautiful Racket</a> - книга про создание на Racket языков.<br><a href="https://habr.com/ru/post/445822/" target="_blank" rel="noopener">Зачем ЯОП? Зачем Racket?</a> - перевод эссе из книги, со ссылками на примеры реализованных DSL.<br><a href="https://habr.com/ru/post/467125/" target="_blank" rel="noopener">Современная игра для NES, написанная на Lisp-подобном языке</a> - DSL <a href="https://gitlab.com/nebogeo/co2" target="_blank" rel="noopener">CO2</a> для генерации NES-кода на Racket<br><a href="https://youtu.be/z8Pz4bJV3Tk" target="_blank" rel="noopener">Lambda World 2019 - Language-Oriented Programming with Racket - Matthias Felleisen</a> - использование Racket для создания группы DSL для работы с видео.<br><a href="https://youtu.be/oSmqbnhHp1c" target="_blank" rel="noopener">RacketCon 2013: Dan Liebgold - Racket on the Playstation 3? It’s Not What you Think!</a> - доклад от Naughty Dog про создание языка для описания структур данных, генерирующего код десериализации, а также описание сериализаванных данных на этом языке для игры<br><a href="https://ubm-twvideo01.s3.amazonaws.com/o1/vault/gdc08/slides/S6636i1.pdf" target="_blank" rel="noopener">Adventures in Data Compilation Uncharted: Drake’s Fortune</a> - Ещё один старый доклад Naughty Dog про их Data Compiler (Naughty Dog вообще <a href="https://en.m.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp" target="_blank" rel="noopener">большие экспериментаторы</a> с <a href="https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/" target="_blank" rel="noopener">лиспом в продакшене</a>).</p><p>Пример кода описания данных из книги <strong><code>&quot;Игровой движок. Программирование и внутреннее устройство&quot;</code></strong> Джейсона Грегори (лид программист Naughty Dog):<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">simple-animation.scm</span><br><span class="line"></span><br><span class="line"><span class="comment">;;тип</span></span><br><span class="line">(<span class="name">deftype</span> simple-animation()</span><br><span class="line">(<span class="name">name</span> string)</span><br><span class="line">(<span class="name">speed</span> float <span class="symbol">:default</span> <span class="number">1.0</span>)</span><br><span class="line">(<span class="name">fade-in-seconds</span> float <span class="symbol">:default</span> <span class="number">0.25</span>)</span><br><span class="line">(<span class="name">fade-out-seconds</span> float <span class="symbol">:default</span> <span class="number">0.25</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;экземпляры</span></span><br><span class="line">(<span class="name">define-export</span> anim-walk</span><br><span class="line">(<span class="name">new</span> simple-animation</span><br><span class="line"><span class="symbol">:name</span> <span class="string">"walk"</span></span><br><span class="line"><span class="symbol">:speed</span> <span class="number">1.0</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name">define-export</span> anim-walk-fast</span><br><span class="line">(<span class="name">new</span> simple-animation</span><br><span class="line"><span class="symbol">:name</span> <span class="string">"walk"</span></span><br><span class="line"><span class="symbol">:speed</span> <span class="number">2.0</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name">define-export</span> anim-jump</span><br><span class="line">(<span class="name">new</span> simple-animation</span><br><span class="line"><span class="symbol">:name</span> <span class="string">"jump"</span></span><br><span class="line"><span class="symbol">:fade-in-seconds</span> <span class="number">0.1</span></span><br><span class="line"><span class="symbol">:fade-out-seconds</span> <span class="number">0.1</span></span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//генерируемый по схеме c++ код</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleAnimation</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name</span><br><span class="line">  <span class="keyword">float</span> speed;</span><br><span class="line">  <span class="keyword">float</span> fadeInSeconds;</span><br><span class="line">  <span class="keyword">float</span> fadeOutSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//использование</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SimpleAnimation* pWalkAnim = LookupAnimation&lt;SimpleAnimation*&gt;(stringHash(<span class="string">"anim-walk"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Заметки о языках программирования&lt;br&gt;
    
    </summary>
    
    
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Nim vk-get-pictures</title>
    <link href="http://spiiin.github.io/blog/3170392974/"/>
    <id>http://spiiin.github.io/blog/3170392974/</id>
    <published>2021-05-21T20:58:25.000Z</published>
    <updated>2021-05-21T23:20:19.087Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Вторая программа на Nim – скрипт скачивания картинок из альбома Vkontakte.</p><a id="more"></a><a href="/blog/1798415512/" title="(2015) - Версия на Scala">(2015) - Версия на Scala</a> <p>Следующий эксперимент после решения <a href="/blog/1808122922/" title="задачи Джеймса Бонда-младшего">задачи Джеймса Бонда-младшего</a> - скрипт для выкачивания всех картинок из альбома вконтакте в несколько потоков.</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/3add8ce6df83f22b524859f0957069b5.js?file=nim_vk_get_pictures.nim"></script>    </div></div><p>Смысл выбора задачи - попробовать использовать Nim в качестве скриптового языка, для написания <em>quick-and-dirty</em> кода.</p><p>Код на <strong><code>Nim</code></strong>, написанный в таком стиле, похож на <strong><code>Pascal</code></strong>. Однако после изучения стиля нескольких библиотек становятся ощутимее различия. Разница в том, что импортируется из модулей в программу. Это не просто “структуры данных и алгоритмы”, а элементы синтаксиса. В <strong><code>Nim</code></strong>, по сравнению с <strong><code>Python</code></strong>, меньше синтаксического сахара в языке, но его можно добавить, импортируя “сахарные” библиотеки. Практически, каждый модуль может быть написан на своём “микро-языке”, в зависимости от того, что он импортирует.</p><p>Примеры библиотек:<br><a href="https://youtu.be/i0RB7UqxERE" target="_blank" rel="noopener">Async/await</a><br><a href="https://nim-lang.org/blog/2021/03/10/fusion-and-pattern-matching.html" target="_blank" rel="noopener">Pattern matching</a><br><a href="https://github.com/juancarlospaco/nim-html-dsl" target="_blank" rel="noopener">HTML DSL</a></p><p>В терминах Фаулера из книги “Предметно-ориентированные языки программирования”, библиотеки могут представлять <code>свободные API</code> (fluent interface, “языкообразные апи”) или <code>API командных запросов</code> (“обычные” для объектного программирования вызовы методов у объектов), причем одна и та же библиотека может представлять различные API для работы с ней.</p><p>Гибкий синтаксис приближает <strong><code>Nim</code></strong> к таким языкам, как <strong><code>Lisp</code></strong> или <strong><code>Smalltalk</code></strong>. Возможно, правильный выбор языков может сильно <a href="https://www.computerra.ru/183817/steps/" target="_blank" rel="noopener">уменьшать количество строк кода</a>, необходимого для решения задач, хотя пока о том, что даст языково-ориентированное программирование, больше мечтают (<a href="https://rsdn.org/article/philosophy/LOP.xml" target="_blank" rel="noopener">MPS</a>, <a href="https://martinfowler.com/articles/languageWorkbench.html" target="_blank" rel="noopener">Language Workbenches</a>, <a href="https://youtu.be/z8Pz4bJV3Tk" target="_blank" rel="noopener">Racket</a>).</p><p>Вдобавок к изменениям синтаксиса, компилятор имеет переключатели, существенно меняющие поведение (<a href="https://nim-lang.org/docs/hcr.html" target="_blank" rel="noopener">hot code reload</a>, <a href="https://forum.nim-lang.org/t/5734" target="_blank" rel="noopener">ARC garbage collector</a>, <a href="https://nim-lang.org/docs/threads.html" target="_blank" rel="noopener">threads</a>) и использовать C++ в качестве <a href="https://youtu.be/8SoJR3sCaR4" target="_blank" rel="noopener">“ассемблера”</a> для сборки под разные платформы.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Вторая программа на Nim – скрипт скачивания картинок из альбома Vkontakte.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vk" scheme="http://spiiin.github.io/tags/vk/"/>
    
      <category term="nim" scheme="http://spiiin.github.io/tags/nim/"/>
    
  </entry>
  
  <entry>
    <title>Nim in imaginary world</title>
    <link href="http://spiiin.github.io/blog/1808122922/"/>
    <id>http://spiiin.github.io/blog/1808122922/</id>
    <published>2021-05-04T11:00:08.000Z</published>
    <updated>2021-05-26T15:55:45.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Когда я изучаю новый язык, то после базового изучения синтаксиса пробую решать на нём выдуманную задачку, взятую из игры <code>James Bond Jr</code> для платформы NES. Попробовал решить её на <a href="https://nim-lang.org/" target="_blank" rel="noopener">Nim</a> и сравнить с решениями на других языках.<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">В этой игрушке в первой зоне сын известного спецагента Джеймса Бонда должен деактивировать 5 ракет главзлодея.</span><br><span class="line">Чтобы “выключить” ракету, необходимо решить головоломку:</span><br><span class="line">Заданы исходное поле из разноцветных клеток и целевая позиция, </span><br><span class="line">в которую надо перевести поле, сдвигая любую строку или столбец.</span><br></pre></td></tr></table></figure><p><img src="/blog/1808122922/bomb_1_small.png" alt="bomb1"><br>(Первая, самая простая, версия загадки)</p><p>Задача хороша тем, что несмотря на кажущуюся простоту, требует немного задуматься в более сложных вариантах, как при решении руками, так и при составлении алгоритма – простое построение дерева решения в лоб для одной из головоломок может занять очень много времени.</p><p>Предыдущие эксперименты:<br><a href="/blog/28461/" title="(2009) Python in imaginary world">(2009) Python in imaginary world</a> - первая попытка решить задачу на Python, скрины и решения всех 5 головоломок.<br><a href="/blog/3351183716/" title="(2015) Scala in imaginary world">(2015) Scala in imaginary world</a> - решение на Scala после прохождения <a href="https://www.coursera.org/learn/progfun1" target="_blank" rel="noopener">курса Мартина Одерски на Coursera</a>.</p><p>Отдельно исходники решения:<br><a href="https://gist.github.com/spiiin/aadd940534e03d84322b121aa9ac0041" target="_blank" rel="noopener">Python</a> (портировал со второй на третью версию)<br><a href="https://gist.github.com/spiiin/257ff552ed1c9de6ed6f" target="_blank" rel="noopener">Scala</a></p><p>В решениях оставлена только самая сложная версия головоломки:<br><img src="/blog/1808122922/bomb_4_small.png" alt="bomb4"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>, <span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">target = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>, <span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>, <span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>, <span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] <span class="comment">##4</span></span><br></pre></td></tr></table></figure></p><h2 id="Критерии-выбора-языка"><a href="#Критерии-выбора-языка" class="headerlink" title="Критерии выбора языка"></a>Критерии выбора языка</h2><p><code>Python</code> когда-то заинтересовал тем, что в нём можно было очень быстро сделать прототип того, что хочешь, причём на высоком уровне абстракции. При этом начинать писать на нём полезные вещи можно буквально через несколько дней после изучения, а с помощью большого набора готовых библиотек можно отыскать быстрый способ решить конкретную задачу минимальным количеством кода.</p><p>Но через несколько лет захотелось найти языки, которые были бы лучше по какому-либо из критериев:</p><p><strong><code>- со статической типизацией</code></strong><br>Иногда мешает, что ошибки типов находятся только в рантайме. Особенно если нужно модифицировать функцию, возвращающую различными способами список из 3-4 элементов сложных типов. Это можно вылечить культурой разработки (тесты, аннотации типов), но хочется подобрать язык, который защитит от таких ошибок совсем (ну или хотя бы чуть-чуть лучше).</p><p><strong><code>- с более выразительным синтаксисом</code></strong><br><a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">Дзен питона</a> - <em>There should be one— and preferably only one —obvious way to do it</em>. При этом, на нём не очень удобно писать в функциональном стиле, лямбда-функции местами ограничены. <em>Изредка</em>, но хочется немного более свободного способа выражения мыслей.</p><p><strong><code>- с возможностью собирать нативный код</code></strong><br>Язык с виртуальной машиной типа Python можно запаковать в исполнимый файл без зависимостей только вместе с этой виртуальной машиной. Но случае распространения программ конечным пользователям не всегда удобно, что небольшая утилита или скрипт тянет за собой тонны кода интерпретатора и библиотек. Иногда хочется иметь возможность получить небольшой исполнимый файл, который только лишь делает необходимую работу.</p><p><strong><code>- более быстрый</code></strong><br><em>Изредка</em>, нужно чтобы небольшая утилита при этом была ещё и быстрой. При использовании скриптовых языков в этом случае принято переходить на C.</p><p><strong><code>- максимально кроссплатформенный</code></strong><br>Python хорош для работы в Windows/Unix/macOS, но использовать его на мобильных платформах (Android/iOS) сложно. Не то чтобы невозможно, но скорее нецелесообразно. В этом случае снова логично переходить на C - iOS поддерживает C/C++ в своих ObjectiveC/ObjecticeC++ вставках, Android имеет компилировать нативный код через NDK, также можно собрать его с помощью Emscripten для запуска в браузере.</p><p><strong><code>- кросс-языковое использование</code></strong><br>В идеале, должен быть способ использовать программу или утилиту из других языков различными способами. В этом случае снова самым удобным является код на C, собранный в библиотеку - почти все языки позволяют вызвать такой код. Если же вы хотите выполнить Python скрипт из своей программы, то не всегда понятно, что делать в этом случае - встроить ли в программу интерпретатор python и нужные для скрипты библиотеки? полагаться на то, что Python уже есть в окружении и вызвать его как системный процесс, прочитав его поток вывода? Или вообще завернуть всё окружение в docker?</p><p><code>Scala</code> обладает первыми двумя качествами (статически типизированная и выразительная), но при этом нацелена на экосистему Java, т.е. обладает проблемами там, где хочется связи с не Java-миром, а также компактности и скорости.</p><h2 id="Nim"><a href="#Nim" class="headerlink" title="Nim"></a>Nim</h2><p>Автор <code>Nim</code> декларирует то, что он соответствует всем требуемым критериям, в основном из-за того, что язык компилируется в C/C++-код, а значит - легко взаимодействует с ним, и компилируется там, где и эти языки (т.е. практически на любой платформе). Поэтому захотелось затестировать его и сравнить для себя с Python.</p><p>Первая попытка решения:<br><a href="https://gist.github.com/spiiin/44721f2e5a70294fa390218ad92385e4" target="_blank" rel="noopener">Nim</a><br><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/44721f2e5a70294fa390218ad92385e4.js?file=james_bond_nim.nim"></script>    </div></div></p><h2 id="Особенности-синтаксиса"><a href="#Особенности-синтаксиса" class="headerlink" title="Особенности синтаксиса"></a>Особенности синтаксиса</h2><p><strong><code>- Поддержка спецсимволов &quot;из коробки&quot;</code></strong><br>Можно вывести ответ в чуть более удобной форме<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">    <span class="type">Dir</span> = <span class="keyword">enum</span> →, ←, ↑, ↓, <span class="type">NOP</span></span><br><span class="line"></span><br><span class="line">(<span class="type">NOP</span>,<span class="number">0</span>): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">(→,<span class="number">2</span>): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">(←,<span class="number">0</span>): [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">(↓,<span class="number">3</span>): [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">0</span>): [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">2</span>): [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(↑,<span class="number">1</span>): [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">0</span>): [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(←,<span class="number">2</span>): [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">(↑,<span class="number">2</span>): [<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p><strong><code>- Нельзя использовать итераторы вне for-цикла</code></strong><br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sort of magic - iterator can be used only with `for`, but it can be wrapped to var sequence, and after calculation</span></span><br><span class="line"><span class="keyword">proc</span> generateProduct[T,U] (aa:T, bb:U) : <span class="built_in">auto</span> = (<span class="keyword">var</span> x = newSeq[<span class="keyword">tuple</span>[a:<span class="keyword">type</span>(aa[<span class="number">0</span>]), b:<span class="keyword">type</span>(bb[<span class="number">0</span>])]](); <span class="keyword">for</span> pair <span class="keyword">in</span> product(aa, bb) : x.add(pair); x)</span><br></pre></td></tr></table></figure></p><p>Вся выглядящая магией функция <code>generateProduct</code> - это обёртка вокруг итератора <code>product</code>, чтобы можно было использовать его в произвольном коде, а не только внутри for. Скорее всего подобное можно завернуть в макрос, которым можно трансформировать любой итератор в функцию, но это уже за рамками первой программы.</p><p><strong><code>- В стандартной библиотеке нет нужных комбинаторных функций</code></strong></p><p>Функция <code>product</code> взята из библиотеки <a href="https://github.com/narimiran/itertools" target="_blank" rel="noopener">itertools</a>. Не очень страшно, скорее всего стандартная библиотека будет расширена в новых версиях языка.</p><p><strong><code>- Выразительность системы типов</code></strong><br>Ещё раз посмотрим  на код <code>generateProduct</code>. В ней есть интересный способ записи информации о типах. Тип переменной <code>x</code> тут можно прочитать как:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Последовательность из пар, </span><br><span class="line">в которых тип первого элемента пары: &quot;такой же, как первый элемент массива aa&quot;, </span><br><span class="line">а тип второго элемента пары: &quot;такой же, как первый элемент массива bb&quot;.</span><br></pre></td></tr></table></figure></p><p>Это неудобочитаемо, мы не описали явно, что <code>aa</code> и <code>bb</code> - массивы, но тем не менее компилятор проверит, что это так , когда будет выводить тип <code>x</code> (точнее даже - ему будет достаточно того, что для типов aa и bb можно обратиться к первому элементу и взять его тип).</p><p>Возможность потребовать от компилятора вывести тип в любом месте кода напоминает мне <code>Lisp</code>, хотя Goran Krampe в <a href="http://goran.krampe.se/nim/" target="_blank" rel="noopener">серии статей про Nim</a> утверждает, что это - наследие <code>Smalltalk</code>.</p><p>Более стандартный способ выражения типов, в котором явно сказано что <code>aa</code> и <code>bb</code> - это <em>массивы из элементов какого-то типа</em>:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sort of magic - iterator can be used only with `for`, but it can be wrapped to var sequence</span></span><br><span class="line"><span class="keyword">proc</span> generateProduct[T,U] (aa:openArray[T], bb:openArray[U]) : <span class="built_in">seq</span>[<span class="keyword">tuple</span>[a:T, b:U]] = </span><br><span class="line">    (<span class="keyword">var</span> x = newSeq[<span class="keyword">tuple</span>[a:T, b:U]](); <span class="keyword">for</span> pair <span class="keyword">in</span> product(aa, bb) : x.add(pair); x)</span><br></pre></td></tr></table></figure></p><p><strong><code>- Синтаксис стимулирует разбивать код на от отдельные файлы</code></strong><br>Одна из идиом языка - определить свои типы и “доопределить” стандартные функции, чтобы они работали с новыми типами:</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">     <span class="type">FieldPathInfo</span> = <span class="keyword">tuple</span>[rate: <span class="built_in">int</span>, v:<span class="type">Field</span>, prev:<span class="type">Field</span>, level:<span class="built_in">int</span>, operation: <span class="type">OperationCode</span>]</span><br><span class="line"><span class="keyword">proc</span> `&lt;`(a : <span class="type">FieldPathInfo</span>, b : <span class="type">FieldPathInfo</span>) : <span class="built_in">auto</span> = a.rate &gt; b.rate <span class="comment">#определяем какой из типов "больше"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#хоп, теперь можно позвать opened.sort() - сортировка будет использовать этот оператор</span></span><br><span class="line"><span class="keyword">var</span> opened = newSeq[<span class="type">FieldPathInfo</span>]()</span><br><span class="line">opened.sort()</span><br></pre></td></tr></table></figure><p>Раз уж типы и функции, работающие с этими типами, нельзя связать в класс, то любому нормальному программисту захочется отделить их в отдельный файл.</p><blockquote><p>Код по выразительности сопоставим с Python, система типов позволяет не только аннотировать тип, но и написать код зависимости между типами, который проверит компилятор. Удобно, что этот код - такой же код на Nim, как и остальная программа, а не отдельный язык (как в случае с C++).</p></blockquote><h2 id="Кроссплатформенность"><a href="#Кроссплатформенность" class="headerlink" title="Кроссплатформенность"></a>Кроссплатформенность</h2><p><a href="https://nim-lang.org/docs/nimc.html" target="_blank" rel="noopener">Руководство к компилятору</a> выдаёт все нужные ключи, чтобы траслировать код из Nim в C, C++, Objective C и JavaScript (<a href="https://github.com/def-/nimes" target="_blank" rel="noopener">тут</a>, правда, отмечают, что проще транслировать полученный C код в JavaScript с помощью Emscripten - это более надёжный вариант, чем nim-&gt;js).</p><p>Я протестировал сборку под macOS, но не смотрел сборку для ios/android - “скелет” программы требует намного больше усилий, чем просто компиляция из командной строки, так что тут Nim тоже находится примерно на уровне <code>Python</code>.</p><h2 id="Скорость"><a href="#Скорость" class="headerlink" title="Скорость"></a>Скорость</h2><p>Моя старая программа на Python находит решение на моём компьютере за ~2-3 секунды. Версия на Nim работает ~4 секунды.</p><p>В первую очередь, конечно, надо просто включить оптимизацию :)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nim -d:release --opt:speed c james_bond_nim.nim</span><br></pre></td></tr></table></figure></p><p>С такими ключами программа работает уже ~1-2 секунды, что, конечно, опережает Python-версию, но разница между компилируемым и интерпретируемым языком должна быть ощутимее.</p><p>Поэтому я всё-таки изучил Nim ещё немного, чтобы понять, что не так. Основная причина тормознутости в том, что базовый тип языка <code>seq</code> - неподходящая структура данных, так как, в отличие от базового <code>list</code> в Python, выполняет лишние копирования. Забавно, что даже с учётом этого, оптимизированная Nim версия выполняется быстрее. Более подходящая структура - <a href="https://nim-lang.org/docs/lists.html#DoublyLinkedList" target="_blank" rel="noopener">DoublyLinkedList</a>.</p><p><a href="https://gist.github.com/spiiin/1089716ab64e6056ed878c1508e87c86" target="_blank" rel="noopener">Nim - быстрая версия</a><br><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/1089716ab64e6056ed878c1508e87c86.js?file=james_bond_nim4.nim"></script>    </div></div></p><p>Также для красоты сделал тип для более удобной работы с открытым списком – объединил в структуру связанный список и хеш-таблицу для кеширования значений (хеш-таблица есть и в python-версии):<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">OpenList</span> = <span class="keyword">object</span></span><br><span class="line">       opened : <span class="type">DoublyLinkedList</span>[<span class="type">FieldPathInfo</span>]</span><br><span class="line">       openedLen : <span class="built_in">int</span></span><br><span class="line">       hashes : <span class="type">HashSet</span>[<span class="type">Field</span>]</span><br></pre></td></tr></table></figure></p><p>Убрал зависимость от библиотеки <code>itertools</code>:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="comment">#there is no product in standart library</span></span><br><span class="line"><span class="keyword">iterator</span> product[T, U](s1: openArray[T], s2: openArray[U]): <span class="keyword">tuple</span>[a: T, b: U] =</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> s1:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> s2:</span><br><span class="line">            <span class="keyword">yield</span> (a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span> generateProduct[T,U] (aa:openArray[T], bb:openArray[U]) : <span class="built_in">seq</span>[<span class="keyword">tuple</span>[a:T, b:U]] = </span><br><span class="line">    (<span class="keyword">var</span> x = newSeq[<span class="keyword">tuple</span>[a:T, b:U]](); <span class="keyword">for</span> pair <span class="keyword">in</span> product(aa, bb) : x.add(pair); x)</span><br></pre></td></tr></table></figure></p><p>Для теста “кросс-язычности” экспортировал функцию поиска в Python:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nimpy</span><br><span class="line"><span class="keyword">proc</span> main() : <span class="type">Field</span> <span class="meta">&#123;.exportpy.&#125;</span></span><br></pre></td></tr></table></figure></p><p>И определил свою функцию конвертации в строку для вывода на экран:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">proc</span> `$`(op: <span class="type">OperationCode</span>) : <span class="built_in">auto</span> = <span class="string">"("</span> &amp; $op.dir &amp; <span class="string">","</span> &amp; $op.line &amp; <span class="string">")"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>В результате замены seq на DoublyLinkedList программа начала выполняться за доли секунды - в десятки раз быстрее аналогичной Python-версии.</p></blockquote><p>Для выполнения точных замеров нужно конечно сгенерировать множество входных данных и исследовать скорость на них, но мне было достаточно того, чтобы добиться измеримых “на глаз” показателей скорости.</p><p>Ещё одна из возможностей Nim - <strong>перенос выполнения кода полностью на момент компиляции</strong>, но воспользоваться ей сходу не получилось, так что она тоже находится за рамками первой программы после изучения языка.</p><p><code>**update**</code><br>Третьим заходом всё-таки выполнил решение в полностью в compile-time:<br><a href="https://gist.github.com/spiiin/501a0225f2d09328c74b59a6e9de8f54" target="_blank" rel="noopener">Compile-time версия решения</a></p><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/501a0225f2d09328c74b59a6e9de8f54.js?file=james_bond_compile_time.nim"></script>    </div></div><p>Основные изменения - изменить <code>let</code> на <code>const</code> в определениях переменных (последовательно в функции решения и ещё 2 зависимых от него определениях глобальных переменных):<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="comment">#let answer = solve().reconstructPath() //run-time</span></span><br><span class="line"><span class="keyword">const</span> answer = solve().reconstructPath() //compile-time</span><br></pre></td></tr></table></figure></p><p>Дополнительно оказалось, что функция <code>shuffle</code> из библиотеки <code>random</code> не умеет работать в compile-time - это проблема библиотеки, но решение нашлось достаточно <a href="https://github.com/nim-lang/Nim/issues/12028" target="_blank" rel="noopener">быстро</a> - переписанная для использования в compile-time версия:<br><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rng <span class="meta">&#123;.compileTime.&#125;</span> = initRand(<span class="number">0x1337DEADBEEF</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">proc</span> compileTimeShuffle[T](x: <span class="keyword">var</span> openArray[T]) =</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> countdown(x.high, <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">let</span> j = rng.rand(i)</span><br><span class="line">    swap(x[i], x[j])</span><br></pre></td></tr></table></figure></p><p>Компилятор выполняет вычисления медленнее, чем скомпилированная программа, и собирает программу за минуту-полторы, вдобавок просит добавить ему ключ, позволяющий продлить ему время на вычисления:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nim c --maxLoopIterationsVM:100000000 nim_james_bond_compile_time.nim</span><br></pre></td></tr></table></figure></p><p>Обычно compile-time вычисления делаются для более простых вещей, однако здесь интересна именно сама возможность в один проход собрать программу, которая выдаёт ответ в виде строчки:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo(&quot;ответ, уже посчитанный компилятором&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="Итоги"><a href="#Итоги" class="headerlink" title="Итоги"></a>Итоги</h2><p>Nim на удивление хорошо подходит по тем критериям, которые я искал изначально – статически типизируемый, выразительный, быстрый, кроссплатформенный и легко связываемый с другими языками.</p><p>Я пока не изучил его продвинутые возможности – систему макросов, возможности по подключению бекэндов, использования нативных библиотек на других языках, выполнение кода во время выполнения - каждая из них выглядит интересной.</p><p>Недостатки языка также очевидны – у него пока нет продвинутой экосистемы тулзов, за ним не стоит большая корпорация, и он достаточно молод (видны некоторые изменения синтаксиса в документации по сравнению с актуальной версией компилятора, в стандартной библиотеке как будто не хватает каких-то нужных для удобной работы функций).</p><p>Но <code>Nim</code> обладает одним из самых важных свойств для языка программирования - на нём приятно писать.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Когда я изучаю новый язык, то после базового изучения синтаксиса пробую решать на нём выдуманную задачку, взятую из игры &lt;code&gt;James Bond Jr&lt;/code&gt; для платформы NES. Попробовал решить её на &lt;a href=&quot;https://nim-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nim&lt;/a&gt; и сравнить с решениями на других языках.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="nim" scheme="http://spiiin.github.io/tags/nim/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Senior</title>
    <link href="http://spiiin.github.io/blog/258274191/"/>
    <id>http://spiiin.github.io/blog/258274191/</id>
    <published>2021-04-20T08:37:58.000Z</published>
    <updated>2021-04-20T09:58:35.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Как быть старшим программистом (в контексте “старшим разработчиком игр”) и чему учиться дальше.<br><a id="more"></a></p><p>Предыдущие заметки</p><p><a href="https://spiiin.github.io/blog/1048/" title="2011 – Как устроиться на работу программистом">2011 – Как устроиться на работу программистом</a></p><p><a href="https://spiiin.github.io/blog/15798/" title="2020 – Уровень программирования: Middle">2020 – Уровень программирования: Middle</a></p><p>Где-то с этого уровня (по моей оценке) основной целью становится умение прокачивать навыки, не касающиеся программирования.</p><p><code>Pre-requisites</code>:</p><ul><li>Умение хорошо писать на одном языке, хотя бы минимально - ещё на одном-двух.</li><li>Понимание, что хочешь развиваться в конкретной отрасли (текст про мобильный геймдев широкого профиля).</li></ul><p><img src="/blog/258274191/frontend.jpg" alt="fronted"></p><h2 id="Становится-бессмысленным-спрашивать-у-кого-то-что-учить"><a href="#Становится-бессмысленным-спрашивать-у-кого-то-что-учить" class="headerlink" title="Становится бессмысленным спрашивать у кого-то, что учить"></a>Становится бессмысленным спрашивать у кого-то, что учить</h2><p>Навыков на этом этапе развития достаточно, чтобы решать поставленные задачи, это может отбивать желание учиться и развиваться дальше. Достигнута простая цель “научиться писать на C++”, и эго подсказывает, “твой код хорош”, даже если это не так. Мозг сильно блокирует желание учиться чему-то абсолютно новому, это некомфортно.</p><p>Хорошо, если рядом есть скилловые коллеги, на которых можно ориентироваться, но если оказываешься самым умным, то можно превратиться в <em>“senior-программиста на заводе”</em>,  которого из-за низких хард-скиллов не возьмут в нормальную компанию.</p><p>Просто помни, что над тобой ещё есть несколько уровней, с высоты которых ты можешь казаться таким же “программистом на заводе”, который написал и поддерживает приложение из нескольких форм на каком-нибудь давно мёртвом языке типа Delphi 7 и страшно этим гордится как профессиональным достижением.</p><p>Не всегда очевидно, что если просидеть на поддержке продукта 5-10 лет (зарплата устраивает и повышается), то потом при смене работы с вас “спросят за стаж” - предлагать работу с понижением и обучением взрослому программисту менее перспективно для работодателя, чем взять молодого и быстрее обучающегося.<br><blockquote><p>Твой набор скиллов - это твоя ценность и стоимость, и только ты ответственен за то, чтобы его прокачивать. И спектр этих навыков определяешь ты сам.</p></blockquote></p><p>Хочешь- будешь только “Гуру языка XXX”, хочешь, научишься отлаживать, профилировать, писать крутые тулзы, эффекты и вести работу команды.</p><p>Цениться может любой вариант, важно лишь то, в чём у тебя будет конкурентное преимущество. На мой взгляд, намного ценнее специалист, который понимает, что его код решает какую-то конкретную проблему и разбирается в этой проблеме.</p><p><strong><code>Тебе навряд ли будут предлагать делать то, что ты не умеешь, если ты не учишься сам или делал плохо</code></strong>.</p><h2 id="Наличие-одиночества"><a href="#Наличие-одиночества" class="headerlink" title="Наличие одиночества"></a>Наличие одиночества</h2><p>Решение задач с определённого уровня чаще всего не “механическое”, а требует времени на обдумывание или исследование материала. </p><p>Когда ты доходишь до задач такого уровня, готовое решение не нагуглится просто потому, что именно такую задачу никто ещё не решал. Максимум, что можно сделать, это посмотреть на то, какие подобные задачи решались до вас, и с какими трудностями сталкивались те, кто решал их раньше. Это в перспективе эффективнее, чем делать своё решение сразу и пройти по всем граблям.</p><p>Соотвественно, если тебя всё время отвлекают (собраниями, неотложными срочными задачами), ты в принципе не сможешь начать решать такие задачи.</p><p>Этого состояния одиночества необходимо достичь, причём вместе с ним приходит и ответственность за то, что задача будет решена - такого рода отвественность не “размазывается” по команде, и от неё не улизнуть в отпуск или на больничный.</p><p>Хотя, если не удаётся достичь состояния в рабочее время (вполне бывают проекты с таким темпом, когда просто некогда остановиться и задуматься надолго), его можно добиться хобби проектами, в свободное время.</p><blockquote><p>Это состояние - не какое-либо “общение с пустотой”, не надо лишать себя общения с людьми, это быстро приведёт к выгоранию, скорее состояние активного “общения с информацией”.</p></blockquote><h2 id="Желание-работать-на-результат"><a href="#Желание-работать-на-результат" class="headerlink" title="Желание работать на результат"></a>Желание работать на результат</h2><p>Одна из важных целей в развитии - умение ориентироваться на результат и правильно его обозначать. Можно делать что угодно как хобби и тратить время на это, но в профессиональной деятельности по определению результатом будет повышение дохода. </p><p>А значит, долгосрочное планирование должно быть направлено на это.</p><p>Хорошая книга про ориентировании <em>компаний</em> на результат - <code>&quot;Великие по собственному выбору&quot;</code> Джима Коллинза. Хотя книга о компаниях, она сильно мотивирует и на личное развитие.<br>Основные тезисы книги:<br><strong><code>- Дисциплина+идея</code></strong>. Намного эффективнее двигаться вперёд постоянно небольшими запланированными шагами, чем большими рывками с выматывающими сверх-усилиями.<br><strong><code>- Здоровая паранойа</code></strong>. Строй свою жизнь/работу/отдых с учётом того, что что-то может пойти не так. В мире много неопределенностей, к которым можно подготовиться, это лучше, чем действовать вслепую.<br><strong><code>- Умение работать с эмпирическими данными</code></strong>. Для этого знай, где их брать, что они означают, и что можно сделать с этим знанием.</p><p>Более развернутая статья - <a href="https://vas3k.club/post/4919/" target="_blank" rel="noopener">Умение зарабатывать деньги</a> (Доступна только по подписке).</p><p>Важное дополнение оттуда - научись управлять своими эмоциями, они чаще всего бесполезны. Если есть проблемы с эмоциями, которые мешают быть эффективным, нужно учиться минимизироавать их влияние. Не забывай следить за здоровьем, учись диверсифицировать доходы.</p><h2 id="Разобраться-с-ценностями-своими-компании"><a href="#Разобраться-с-ценностями-своими-компании" class="headerlink" title="Разобраться с ценностями (своими/компании)"></a>Разобраться с ценностями (своими/компании)</h2><p>Логично вытекающее из предыдущего пункта дополнение - честный вопрос себе <strong><code>&quot;а нафига я вообще делаю, что делаю&quot;</code></strong>. В ходе ответа на него также возникает вопрос, соответствует ли твой ответ и мировоззрение тому, что декларирует и делает компания, в которой ты работаешь.</p><p>Примеры мотивации:</p><div class="table-container"><table><thead><tr><th>Ценность</th><th style="text-align:left">Личная</th><th style="text-align:left">Компании</th></tr></thead><tbody><tr><td>Власть</td><td style="text-align:left">Карьерный рост</td><td style="text-align:left">Победа над конкурентами</td></tr><tr><td>Заработок</td><td style="text-align:left">Накопление ресурсов</td><td style="text-align:left">Раcширение компании(экспансия)</td></tr><tr><td>Известность</td><td style="text-align:left">Развитие личного бренда</td><td style="text-align:left">Развитие бренда компании</td></tr><tr><td>Исследование</td><td style="text-align:left">Развитие навыков</td><td style="text-align:left">Исследование технологий</td></tr></tbody></table></div><p>Здорово, если личные ценности гармонируют и совпадают с целями компании, и если нет перегиба в желаниях с личной стороны, и отличий в декларируемых и реальных действиях со стороны компании.</p><p>“Личные перегибы” здесь означает желание достигнуть цели в ущерб коллегам, а не совместно с ними, “отличия в декларируемых намерениях компании” - пустые лозунги, отличающиеся от правил, которые применяются в компании в реальности.</p><blockquote><p>Соответствие внутренних целей тому, что делаешь, нужно, чтобы не выгореть в долгосрочной перспективе, и чтобы продолжать получать кайф от того, что делаешь, даже если сиюминутные задачи будут не самыми интересными.</p></blockquote><h2 id="Освоение-смежных-областей"><a href="#Освоение-смежных-областей" class="headerlink" title="Освоение смежных областей"></a>Освоение смежных областей</h2><p>Найди время, чтобы  изучить на базовом уровне что-то новое, чем никогда не занимался раньше. Это полезно для мозга, и часто помогает открыть для себя какие-то новые возможности. В каком-то смысле, <strong><code>вселенная откроет что-то новое для тебя</code></strong>.</p><p>Например, если программируешь игры - попытайся понять, тех, кто <em>создаёт</em> игры - в чём заключается работа геймдизайнера или продюссера.<br>Для понимания работы геймдизайнера отлично подходит книга <code>&quot;Искусство геймдизайна&quot; Джесси Шелла</code> (эта книга затрагивает не только о геймдизайн, но и вообще, устройство мира и психологию человека).</p><p>Для начального понимания работы продюсера игр есть хороший доклад - <a href="https://www.youtube.com/watch?v=a9wSZ9L_Jk8&amp;ab_channel=DevGAMM" target="_blank" rel="noopener">Три главных фокуса продюсера</a> Александра Штаченко.</p><p>Можно попытаться разобраться с тем, как устроены компании, попытаться научиться писать музыку или разобраться с принципами классической анимации. Мир полон интересных задач, которые решают люди различных профессий.</p><blockquote><p>В конечном итоге, освоение новых областей улучшит твою способность учиться и сделает тебя лучшим программистом.</p></blockquote><h2 id="Смотреть-на-rocket-science-решения"><a href="#Смотреть-на-rocket-science-решения" class="headerlink" title="Смотреть на rocket-science решения"></a>Смотреть на rocket-science решения</h2><p>Перед началом реализации решения любой задачи, хорошо бы вспомнить, что кто-то уже брался за похожую задачу до тебя. </p><p><strong><code>Может существовать готовое хорошее решение, которое можно использовать, не расходуя ресурсов на реализацию своего решения</code></strong>.</p><p>Даже если готовое решение не подходит, можно, чтобы сэкономить время и “мысленное топливо”:</p><ul><li>Изучить идеи, которыми руководствовались те, кто решал задачу до тебя, проблемы, с которыми они сталкивались, плюсы и минусы чужих решений.</li><li>Пропустить шаг с реализацией первого простого решения, а сразу улучшать или адаптировать готовое продвинутое.</li><li>Прикинуть, насколько своё решение будет лучше “среднего общедоступного”, насколько эффективнее ваше решение чем то, которое, возможно, будут использовать конкуренты.</li><li>Понять, что решения не существует или оно слишком дорогое в рамках текущего бюджета проекта.</li></ul><p><strong>Где искать эти готовые решения?</strong></p><p>Пару лет назад я наткнулся на достаточно продвинутого хакера (в смысле, исследователя безопасности веб-сайтов), который в интервью сказал, что достаточно просто мониторить твиттер ~100-200 продвинутых ребят в области, чтобы быть в курсе всех трендов своей области. Основные  публично доступные крутые решения делают и обсуждают относительно небольшая группа людей.<br>Естественно, есть “порог входа”, нужно уже обладать достаточным опытом и багажом знаний, чтобы хотя бы понимать обсуждаемые темы.</p><p>Тогда мне показалось странным, так как я читал только русскоязычный твиттер, в котором даже технические ребята постят нытьё, мемасы и политоту. Сейчас я понимаю, что англоязычный геймдев сегмент-твиттера - вполне себе место для коротких технических дискуссий, в которых участвуют лид-программисты ведущих компаний, авторы лучших open-source библиотек, ресёрчеры разных направлений, причём их твиты в большинстве именно на технические темы.</p><blockquote><p>Основные публичные площадки обсуждения технических решений сейчас, в порядке убывания - твиттер, реддит, гитхаб.</p></blockquote><p>Способ составления начального списка - авторы докладов с технических конференций (почти 100% оставляют в начале или конце доклада свои контакты), авторы технических статей или библиотек, которые находятся поиском информации в гугле. Дальше - следить за тем, кого читают они.</p><h2 id="Умение-анализировать-информацию"><a href="#Умение-анализировать-информацию" class="headerlink" title="Умение анализировать информацию"></a>Умение анализировать информацию</h2><blockquote><p>В первую очередь - научиться собирать информацию эмпирическим путём. Без проверенной и отфильтрованной входной информации невозможно получить никаких полезных выводов.</p></blockquote><p>Любая маркетинговая информация (“самый лучший игровой движок, самый быстрый язык для программирования игр”) - лишь входная для проверки и получения собственных результатов.</p><p><strong><code>Про это могут забыть те, на ком лежит ответственность за принятие решения по выбору инструментов</code></strong>, зачастую, потому что они слишком нагружены какой-либо другой ответственностью, чтобы отвлечься и проанализировать выбор технологии.</p><p><strong><code>Одним мощных способов получения эмпирических данных - reverse engeneering продуктов конкурентов</code></strong>. Часто не сложно посмотреть, какие ресурсы использует какая-либо игра, какой формат данных использует и насколько активно использует железо. Это не всегда легальный и иногда всё же трудный способ, однако вполне доступный для персонального использования.<br> (<em>кстати, особенно любят прятать и шифровать ресурсы игр китайские разработчики, непревзойдённые мастера копирования</em>)</p><p>Кроме анализа, полезно научиться правильно хранить информацию, с определенного уровня её объёмы не позволяют быстро найти нужную. Один из вариантов упорядочивания знаний - метод <code>Zettelkasten</code>. Лично мой вариант - <a href="https://obsidian.md/features" target="_blank" rel="noopener">Obsidian</a>, бесплатный, работает с md-файлами в папке (не vendor-lock), с удобным графом связей между заметками:</p><p><img src="/blog/258274191/zettel.png" alt="zettel"></p><p>Другие варианты - персональный блог, облачные системы хранения заметок, персональная вики.</p><p>Также умение собирать и анализировать информацию очень защищает от того, чтобы остаться “самоучкой” с сильными искажениями во взглядах и в подходах к решению проблем.</p><h2 id="Создавать-себе-инструменты"><a href="#Создавать-себе-инструменты" class="headerlink" title="Создавать себе инструменты"></a>Создавать себе инструменты</h2><p>Пару раз доводилось видеть на собеседовании программистов с несколькими годами опыта, которые никогда не программировали для себя. Мне кажется большим упущением не использовать свои профессиональные навыки для улучшения собственной продуктивности.</p><p>Существует множество задач, которые можно автоматизировать, причём зачастую просто соединив готовые компоненты. Такие техники в общем называются NoCode (<a href="https://vas3k.ru/blog/nocode/" target="_blank" rel="noopener">статья Вастрика</a>).</p><p>С некоторыми навыками программирования можно достичь ещё больше, не обязательно писать хороший код, часто бывает достаточно реализовать для себя одну-две функции, которых очень не хватает в окружающем софта. Многие хорошие программы можно настраивать, дописывать плагины, расширять скриптами (и просто дописывать в них фичи, если они open-source).</p><p><a href="https://habr.com/ru/post/435428/" target="_blank" rel="noopener">Удалённое управление эмулятором Fceux с помощью Python</a> - статья про создание инструментов, в ней примеры и дописывания нехватающих функций в исходники, и скриптования, и соединения разных инструментов вместе, ради получения нового функционала.</p><blockquote><p>С помощью выбора и создания правильных инструментов можно подняться намного выше “средне-рыночного” уровня.</p></blockquote><p>Ну и вообще, создание инcтрументов - одна из важных hacker-values (<strong><code>ни одна проблема не должна решаться вручную дважды</code></strong>), и путь к знанию.</p><p>Ссылки:<br><a href="http://www.paulgraham.com/avg.html" target="_blank" rel="noopener">Beating the average</a> (<a href="https://nestor.minsk.by/sr/2003/07/30710.html" target="_blank" rel="noopener">Перевод</a>)<br><a href="http://www.catb.org/~esr/faqs/hacker-howto.html" target="_blank" rel="noopener">How To Become A Hacker</a></p><h2 id="Навыки-управления-командой"><a href="#Навыки-управления-командой" class="headerlink" title="Навыки управления командой"></a>Навыки управления командой</h2><p>Даже если планируешь развиваться в техническом направлении, навыки управления командой помогут:<br><strong><code>- Научиться более точно оценивать сроки</code></strong><br><strong><code>- Делегировать часть задач коллегам, не всегда возможно успеть выполнить всё самому</code></strong><br><strong><code>- Организовывать и собирать команды</code></strong><br><strong><code>- Понимать, сколько и какого уровня людей нужно, чтобы решить конкретную большую задачу</code></strong><br><strong><code>- Как руководитель, быть более осведомлённым о целях и положении дел в проекте/компании - лучше понимать свою отрасль</code></strong></p><h2 id="Разобраться-в-железе-и-операционных-системах"><a href="#Разобраться-в-железе-и-операционных-системах" class="headerlink" title="Разобраться в железе и операционных системах"></a>Разобраться в железе и операционных системах</h2><p><a href="https://habr.com/ru/company/vdsina/blog/551302/" target="_blank" rel="noopener">Программирование это сложно</a>.<br>Оно <strong>доступно</strong> для того, что быстро начать, но <code>&quot;Easy to learn and difficult to master&quot;</code>.</p><blockquote><p>Сложности начинаются с того момента, когда в дело вступают ограничения железа.</p></blockquote><p>Об этих ограничениях имеют мало представления джуниоры и мидлы, они в основном <em>решают поставленные задачи</em>, в лучшем случае выбирают алгоритмы с подходящей асимптотикой.</p><blockquote><p>Вторая сложность - борьба с увеличением запутанности кода со временем.</p></blockquote><p>Основной метод борьбы с запутанностью в мощных языках - выбирать правильные ограничения и идеи, позволяющие <em>сохранить простоту</em>.</p><p>Программирование состоит из двух частей - представлении того, что нужно непосредственно <em>сделать компьютеру</em>, чтобы решить задачу, и обдумывание средств, как выразить это на языке программирования, так чтобы это работало эффективно и выразительно с точки зрения синтаксиса языка.</p><p><a href="https://caseymuratori.com/blog_0015" target="_blank" rel="noopener">Semantic compression</a> - статья про семантическое сжатие кода.</p><p>Про причины необходимости разбираться в железе писал в заметке <a href="https://spiiin.github.io/blog/3652741154/">десять лет в геймдеве</a>, разделы <strong><code>Гештальты геймдева</code></strong> и<br><strong><code>Инструменты</code></strong></p><h2 id="Научиться-работать-с-кодом"><a href="#Научиться-работать-с-кодом" class="headerlink" title="Научиться работать с кодом"></a>Научиться работать с кодом</h2><p><strong>Все</strong> умеют писать код. Кроме этого, необходимо уметь:<br><strong><code>- Переписывать (и переиспользовать) и документировать</code></strong><br><strong><code>- Тестировать</code></strong><br><strong><code>- Очищать и улучшать качество</code></strong><br><strong><code>- Профилировать</code></strong><br><strong><code>- Отлаживать</code></strong><br><strong><code>- Выявлять скрытые дефекты и ошибки</code></strong> (к примеру, статическим анализатором, инструментами поиска утечёк и обращений к освобождённой памяти)</p><p>Часто работу с кодом понимают только в контексте рефакторинга, но кроме в играх часто встречается необходимость улучшать производительность bottle-neck участков кода.</p><p>Примеры такой оптимизации (и создания инструментов оптимизации) в докладе <a href="https://www.gdcvault.com/play/1026635/-Witcher-3-on-the" target="_blank" rel="noopener">‘Witcher 3’ on the Nintendo Switch: CPU &amp; Memory Optimization</a>, на 14:42 Роман Лебедев рассказывает о создании инструмента, который показывает выравнивание структур в памяти и позволяет оптимизировать потребляемую память и скорость доступа к полям структур.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Как быть старшим программистом (в контексте “старшим разработчиком игр”) и чему учиться дальше.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Скриншоты из PC-игр - 2</title>
    <link href="http://spiiin.github.io/blog/2486469456/"/>
    <id>http://spiiin.github.io/blog/2486469456/</id>
    <published>2021-02-15T11:21:04.000Z</published>
    <updated>2021-02-15T16:53:47.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Ссылки на треды со скриншотами из PC игр с форума NeoGAF<br><a id="more"></a></p><p><a href="/blog/2347839193/" title="Старый пост">Старый пост</a> - со ссылками на периоды 2009-2016.<br>Несколько часов залипательного изучения красивейших скриншотов.</p><p><a href="https://www.neogaf.com/threads/2017-pc-screenshot-thread.1329720/" target="_blank" rel="noopener">2017</a><br><a href="https://www.neogaf.com/threads/2018-pc-screenshot-thread.1460776/" target="_blank" rel="noopener">2018</a><br><a href="https://www.neogaf.com/threads/2019-pc-screenshot-thread.1470464/" target="_blank" rel="noopener">2019</a><br><a href="https://www.neogaf.com/threads/2020-pc-screenshot-thread-of-no-compromises.1518478/" target="_blank" rel="noopener">2020</a><br><a href="https://www.neogaf.com/threads/2021-pc-screenshot-thread-of-no-compromises.1584774/" target="_blank" rel="noopener">2021</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ссылки на треды со скриншотами из PC игр с форума NeoGAF&lt;br&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="3d" scheme="http://spiiin.github.io/tags/3d/"/>
    
  </entry>
  
  <entry>
    <title>Шпаргалка по разработке MMO</title>
    <link href="http://spiiin.github.io/blog/1123790904/"/>
    <id>http://spiiin.github.io/blog/1123790904/</id>
    <published>2021-02-10T00:12:40.000Z</published>
    <updated>2021-02-10T01:17:22.497Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Набор ссылок и подсказки по терминологии для разработки многопользовательских и MMO-игр.</p><a id="more"></a><h2 id="Начальные-материалы"><a href="#Начальные-материалы" class="headerlink" title="Начальные материалы"></a>Начальные материалы</h2><p>Книга:<br>Многопользовательские игры. Разработка сетевых приложений Глейзер Д., Мадхав С. (<a href="https://www.piter.com/collection/programmirovanie-igr/product/mnogopolzovatelskie-igry-razrabotka-setevyh-prilozheniy" target="_blank" rel="noopener">ссылка</a>).<br>Описывает основные понятия, ориентирована больше на сессионные игры, иногда отсылает к изучению более продвинутых тем на другие материалы.</p><p>Статьи:<br><a href="https://habr.com/ru/post/467025/" target="_blank" rel="noopener">О сетевой модели в играх для начинающих</a> - описаны базовые понятия, много отсылок на другие статьи по разным темам.<br><a href="https://web.archive.org/web/20190519135537/http://trac.bookofhook.com/bookofhook/trac.cgi/wiki/IntroductionToMultiplayerGameProgramming" target="_blank" rel="noopener">Introduction to Multiplayer Game Programming</a> - хороший разбор вариантов выбора “нижнего уровня” игрового протокола, немного об игровой логике.<br><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a> - несколько статей о “верхнем уровне” игрового протокола.<br><a href="https://gafferongames.com/post/reading_and_writing_packets/" target="_blank" rel="noopener">Reading and Writing Packets</a> - методы сериализации.<br><a href="https://ruoyusun.com/2019/03/28/game-networking-1.html" target="_blank" rel="noopener">Game Networking Demystified, Part I: State vs. Input (series)</a> - серия статей с очень кратким обзором базовых понятий.<br><a href="http://t-machine.org/index.php/2013/06/22/mmo-scalability-is-finally-irrelevant-for-indie-mmos/" target="_blank" rel="noopener">MMO scalability is finally irrelevant for Indie MMOs</a> - небольшая статья о пропускной способности и мощности серверов.<br><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem</a> - о настройке сервера, поддерживающего 10000 TCP-соединений.</p><h2 id="Общая-архитектура-игры"><a href="#Общая-архитектура-игры" class="headerlink" title="Общая архитектура игры"></a>Общая архитектура игры</h2><p>Условно “Клиент-сервер-бекенд архитектура” (client/game server/web-server(with db), three-tiered server architecture), etc).<br>Конкретное устройство сильно зависит от потребностей игры. Примеры:</p><p><a href="https://www.ibm.com/developerworks/library/ar-powerup1/index.html" target="_blank" rel="noopener">Building a simple yet powerful MMO game architecture, Part 1</a> - обзор архитектуры от IBM.<br><a href="https://www.ibm.com/developerworks/library/ar-powerup2/" target="_blank" rel="noopener">Part 2</a> - вторая часть статьи (в самой статье кривые ссылки).<br><a href="https://www.ibm.com/developerworks/library/ar-powerup3/ar-powerup3.html" target="_blank" rel="noopener">Part 3</a> - третья часть.</p><p><a href="https://youtu.be/-AU_qlCu9ZI?t=361" target="_blank" rel="noopener">Бэкенд-разработка в геймдеве</a> – доклад Максима Барышников, Wargaming, тайминг на обзор архитектуры.</p><h2 id="Архитектура-игрового-сервера"><a href="#Архитектура-игрового-сервера" class="headerlink" title="Архитектура игрового сервера"></a>Архитектура игрового сервера</h2><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/x_4Y2-B-THo" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Очень хорошо и понятно описана архитектура всей игры, и возможное устройство сервера MMO (единственный найденный доклад с примером архитектуры реального проекта)</p><p><img src="/blog/1123790904/arch_server.png" alt="arch_server"></p><h2 id="Архитектура-клиента"><a href="#Архитектура-клиента" class="headerlink" title="Архитектура клиента"></a>Архитектура клиента</h2><p><code>Предсказание на клиенте</code></p><ul><li>чтобы не ждать ответа сервера, предсказывать информацию на основе предыдущих данных (если игрок двигается вправо - в следующем кадре скорее всего тоже будет). Если от сервера приходит другая информация, то плавно интерполировать реальные данные с предсказанными, чтобы избежать скачков.</li></ul><p><code>Разные техники сглаживания позиции</code></p><ul><li>интерполяция ставит клиента на полученное от сервера значение (минус - клиент видит позицию немного в прошлом)</li><li>экстраполяция - клиент пытается предугадать где будут другие игроки на основе данных с сервера (минус - если позиция резко изменится, будет большее расхождение)</li><li>(для fps) - компенсация лага - сервер “перематывает время назад”, и проверяет, что было на экране игрока в момент, когда тот выстрелил, чтобы не отказывать ему в попадании из-за задержки</li><li>Обязательно тестировать отладочным выводом и симуляцием лагающего клиента.<br><a href="https://www.youtube.com/watch?v=7jb0FOcImdg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=7jb0FOcImdg</a> - 8 Frames in 16ms: Rollback Networking in Mortal Kombat and Injustice 2<br><a href="https://www.youtube.com/watch?v=W3aieHjyNvw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=W3aieHjyNvw</a> - Overwatch Gameplay Architecture and Netcode (вторая половина)</li></ul><p><code>Переход игрока между зонами</code></p><ul><li>трансфер данных игрока между двумя шардами через бд.</li><li>можно сделать пересекающиеся зоны, когда игрок существует и видим одновременно из 2х соседних зон, или просто явным телепортом.</li></ul><p><code>Игровой цикл</code></p><ul><li><p>нужен апдейт с фиксированным шагом времени вместо обычного “update(dt)+render”<br><a href="https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-3/3.2-game-loop.html" target="_blank" rel="noopener">https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-3/3.2-game-loop.html</a></p></li><li><p>очередь событий<br>Не обрабатывать события напрямую, а ставить в очередь на отправку - можно оптимизировать, сделать батчинг, отбросить повторы, приоритезировать, . При приёмё - сортировать с другими событиями игровой очереди.<br><a href="https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-5/5.2-event-queue.html" target="_blank" rel="noopener">https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-5/5.2-event-queue.html</a></p></li></ul><h2 id="“Нижний-уровень”-протокола"><a href="#“Нижний-уровень”-протокола" class="headerlink" title="“Нижний уровень” протокола"></a>“Нижний уровень” протокола</h2><p>Понятия, относящиеся к уровню взаимодействия с ОС.</p><p><code>Оборачивать в заменяемые компоненты</code></p><p><code>Udp vs Tcp vs библиотека для смешанного решения</code></p><ul><li>чаще всего свой протокол - надстройка над udp</li><li>не надо писать свой, если не уверен в том, что надо :)</li><li>фичи транспортного протокола можно реализовать на прикладном уровне<ul><li>Варианты<br><a href="https://github.com/networkprotocol/yojimbo" target="_blank" rel="noopener">https://github.com/networkprotocol/yojimbo</a><br><a href="https://github.com/ValveSoftware/GameNetworkingSockets" target="_blank" rel="noopener">https://github.com/ValveSoftware/GameNetworkingSockets</a><br>использовать либу с обёртками</li></ul></li></ul><p><code>Порты для одного клиента - один vs несколько</code></p><ul><li>демультиплексинг данных не нужен - всё равно придётся инспектировать протокол</li><li>можно юзать, если много данных, чтобы получить больший буфер данных от операционной системы на пользователя</li><li>могут закончиться</li></ul><p><code>Опрос каждый кадр vs опрос в отдельном потоке</code></p><ul><li>способы опроса: iocp/epoll/kqueue</li><li>Проблема 10к соединений <a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></li><li>Библиотеки-обёртки для опроса портов и цикла событий:</li><li>libuv</li><li>libevent</li><li>boost asio<br><a href="https://libwebsockets.org/" target="_blank" rel="noopener">https://libwebsockets.org/</a><br><a href="https://stackoverflow.com/questions/118945/best-c-c-network-library" target="_blank" rel="noopener">https://stackoverflow.com/questions/118945/best-c-c-network-library</a></li></ul><p><code>NAT</code></p><ul><li>нужен id клиента кроме его адрес+порт (порт может внезапно измениться)</li></ul><h2 id="“Верхний”-уровень-протокола"><a href="#“Верхний”-уровень-протокола" class="headerlink" title="“Верхний” уровень протокола"></a>“Верхний” уровень протокола</h2><p>Прикладной уровень протокола</p><p><code>Разбиение пакетов</code></p><ul><li>если пришёл пакет с пропущенным номером - либо выбросить, либо положить в буфер, чтобы некоторое время подождать предыдущих</li><li>маленькие пакеты можно группировать в большие (и не забывать всё равно рассылать недозаполненные, чтобы избежать лага)</li><li>большие пакеты, не вмещающиеся по размеру, делить на подпакеты и слать отдельно, собирая на стороне получателя</li><li>пакеты с высоким приоритетом и с низким (передаются только когда нет высоких)</li><li>(возможны и решения на уровне библиотеки)</li></ul><p><code>Сжатие</code></p><ul><li>cначала убедиться, что клиенту отправляется ТОЛЬКО информация, которая ему необходима! </li><li>проверка, что видит игрок, и какие данные нужны его клиенту - pvs - potentionally visible set</li><li>урезать значения. float-&gt;16bit, int-&gt;8bit, битовые флаги -&gt;запаковать вместе</li><li>битовые потоки вместо байтовых</li><li>удобный трюк - 32 битовой число можно записать как литерал из 4х символов (“l34t” == 0x6C333474)</li><li>использовать для запаковки знание информации об игре</li><li>если изменяются не все поля объекта, можно использовать битовую маску, чтобы отметить какие из полей нужно прочитать.</li><li>отсекать многократно повторяющиеся команды на клиенте перед отправкой, также при обнаруженном сбое отправки отправлять не устаревшие данные, а последние (ещё один слой абстракции между игровым кодом и сетевыми пакетами)</li><li>слать клиенту не состояние, а дельту между состояниями (т.е. если не было изменения координаты какой-либо - не слать её повторно)</li><li>сжатие:<ul><li>rle</li><li>huffman</li><li>zlib<br><a href="https://github.com/r-lyeh-archived/quant" target="_blank" rel="noopener">https://github.com/r-lyeh-archived/quant</a> - библиотека для дискретизации</li></ul></li></ul><p><code>Сериализация данных</code></p><ul><li>библиотеки (много различий - требуют ли схемы, ending, поддержка rpc, etc)<ul><li>protocolBuffers, flatBuffers, cap’n’proto, thrift, msgpack, cereal, yas, boost::serialization, bitsery</li><li>своя схема на lex/yacc + кодогенерация</li></ul></li><li>Схему данных пакетов в теории можно не хранить на клиенте, а передавать на старте сессии - тогда не надо обновлять клиент (но лучше не надо)</li></ul><h2 id="Игровая-логика"><a href="#Игровая-логика" class="headerlink" title="Игровая логика"></a>Игровая логика</h2><p><code>Безопасность и читеры</code></p><ul><li>один читер может испортить игру 100-1000 игрокам</li><li>не слать клиенту информацию вроде “рядом с вами невидимый игрок”</li><li>проверять, не слишком ли много действий в секунду совершает игрок</li><li>не верить данным от клиента - авторитарный сервер</li><li>не изобретать своих шифрований и не хранить ключи симметричного шифрования на клиенте.</li><li>шифрование - у сервера есть приватный и публичный ключ. Клиент генерирует только симметричный ключ (уникальный для сессии) и передаёт серверу зашифровав публичным ключом сервера. Сервер шифрует данные симметричным ключом клиента.</li><li>libsodium</li></ul><p><code>Хинты для оптимизации игрового протокола</code></p><ul><li>Минимизировать или вообще избегать обязательных (reliable) рассылок апдейтов/rpc каждый такт от сервера клиентам.</li><li>Не реплицировать то, что можно не реплицировать (если какое-нибудь разрушаемое дерево вообще не влияет на геймплей - пусть клиенты считают его как хотят)</li><li>Если нужно реплицировать на клиент большой кусок данных (стартовое состояние мира при подключении) - передать не за один заход, а разбить на много мелких (иначе можно перегрузить сеть и другие клиенты будут лагать).</li><li>Возможная оптимизация клиента - удалять на клиенте всех акторов за пределами досягаемости камеры/гильдейских знаний игрока (не рендерить и не знать ничего о том, что он не может увидеть). Можно настроить время очистки.<br><a href="https://habr.com/ru/company/mailru/blog/352634/" target="_blank" rel="noopener">https://habr.com/ru/company/mailru/blog/352634/</a> Сетевая оптимизация для Unreal Engine 4</li></ul><h2 id="Отладка-сети"><a href="#Отладка-сети" class="headerlink" title="Отладка сети"></a>Отладка сети</h2><p><code>Замеры качества соеднинения</code></p><ul><li>проверка времени - ping</li><li>проверка потерь - либо считать пакеты, которые пришли с неверным порядковым номером, либо считать количество необходимых ретрансляций</li></ul><p><a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/Networking/NetworkProfiler/index.html" target="_blank" rel="noopener">https://docs.unrealengine.com/en-US/InteractiveExperiences/Networking/NetworkProfiler/index.html</a> - по ссылке - описание тулзы профайлинга данных по сети. Standalone тул. Клиент в отладочном режиме пишет в файл протокол, который можно загрузить в тулзу и исследовать.<br>(<a href="https://youtu.be/VusAHXoHF3Y?t=273" target="_blank" rel="noopener">https://youtu.be/VusAHXoHF3Y?t=273</a> - Replication Graph For Optimizing Real-Time Strategy Games | Unreal Fest Europe 2019 | Unreal Engine - пример использования)</p><ul><li>плейтесты на реальном сервере, тесты с сервером на машине разработчике нерепрезентативны</li><li>обязательно необходимо симулировать плохую сеть, чтобы понять, как будет вести себя клиент в экстремальных условиях</li><li>подсчёт трафика : поднимаете дедикейтед. устраиваете на нём плейтест. Смотрите траффик на отдельно взятом порту. Оцениваете, сколько в среднем траффика на вход и на выход.</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Набор ссылок и подсказки по терминологии для разработки многопользовательских и MMO-игр.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>10 лет в геймдеве</title>
    <link href="http://spiiin.github.io/blog/3652741154/"/>
    <id>http://spiiin.github.io/blog/3652741154/</id>
    <published>2021-02-05T15:31:25.000Z</published>
    <updated>2021-02-07T22:13:53.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Когда-то давно, когда я учился в университете на втором курсе, мой одногруппник скинул мне ссылку на раздел местного форума о поиске работы. <a href="https://www.gaijinent.com/" target="_blank" rel="noopener">“Гайдзины”</a> искали программистов в офис в Севастополе.<br>Я уже тогда решил для себя, что хочу делать игры, но не особо хотел бросать учёбу. Сходил на собеседование, после которого мне сказали, что подумают.</p><p>Подумали они около месяца, после чего в январе 2008 года пригласили в офис, чтобы начинать работать. Я отнёсся к этому как к стажировке (в универе всё равно были каникулы между семестрами), и согласился.<br>После каникул решил остаться там работать на полставки (работа, конечно, мешала учёбе, но зато можно было делать игры, и получать за это деньги).</p><p>В универе я успел покататься по олимпиадам по программированию, и заработать хорошую репутацию, так что на мои пропуски закрывали глаза, поэтому удавалось балансировать между работой и учёбой ещё 4 года (с учебными отпусками, временным самоувольнением поучиться семестр, и просто с забитием на универ к концу). Посчитал, что с учётом отпусков и перерывов, я профессионально занимаюсь разработкой игр уже около 10 лет.</p><p>У меня нет какой-то особенной мудрости, накопленной за эти годы, и поучающих советов другим (даже несмотря на то, что некоторые разделы поста выглядят как советы). Эти заметки написаны просто для себя.</p><a id="more"></a><h2 id="Зачем"><a href="#Зачем" class="headerlink" title="Зачем"></a>Зачем</h2><p>Когда давно работаешь в индустрии игр, в какой-то момент сталкиваешься с тем, что забываешь о своих изначальных желаниях и идеях - почему ты пришёл сюда и чего хотел. Каждый приходит в геймдев со своими собственными мечтами и намерениями.</p><p>Я пришёл с простой прагматичной целью – узнать, как делаются игры и эффекты в них, понять “магию”, которая создаёт картинки на экране. Я только открыл для себя <code>HoMM3</code> и <code>Warcraft3</code>, и в обеих играх мне дико нравилось заклинание “Цепь молний”. Моей локальной целью было сделать такую же.</p><p>И, о чудо, после выпуска пары казуалок, мы сделали экшн <a href="/blog/12483/" title="Braveheart">Braveheart</a>, с кучей визуальных эффектов, среди которых была и та заветная цепная молния!<br><img src="/blog/3652741154/braveheart-chain-lighting.png" alt="chain"></p><p>Однако, к тому моменту я уже понял, что моя цель - <code>делать крутые игры</code>, про которые я мог бы сказать это сам, и про которые так говорили бы игроки.</p><h2 id="Чем-вообще-занимаются-в-геймдеве"><a href="#Чем-вообще-занимаются-в-геймдеве" class="headerlink" title="Чем вообще занимаются в геймдеве?"></a>Чем вообще занимаются в геймдеве?</h2><p>Когда-то делал себе пометки, как это – <a href="https://spiiin.livejournal.com/82899.html" target="_blank" rel="noopener">работать программистом</a> в целом.<br>Недавно также отписывал в <a href="https://vas3k.club/question/7938/#comment-4f9155a7-8650-4551-a716-be5f576c5032" target="_blank" rel="noopener">закрытом сообществе</a> - в чем отличия разработки игр от других сфер:</p><p><strong><code>- В геймдеве встречаются очень разные задачи, от создания бекэнда и серверов для мультиплейерных игр до программирования графики, обычные гуи приложения (тулзы), скрипты автоматизации, оптимизации, архитектура движков.</code></strong></p><p> Несмотря на то, что есть специализации, за длительное время работы скорее всего окажется, что позанимаешься всеми. Это и плюс - расширяет кругозор, и не возникнет ощущения, что постоянно занимаешься чем-то одним, и минус - нельзя просто выучить что-то одно и пользоваться этим много лет, загребая деньги лопатой. Тем не менее, C++ из геймдева никуда не ушёл.</p><p>(тут должна быть картинка про зарплаты по отношению к другим сферам <code>&quot;Пишу на C++/Objective C/Java/Lua/Python/C#/GLSL/HLSL и ещё паре малоизвестных языков за еду&quot;</code>)</p><p><strong><code>- Тренды очень динамические, планка качества игр поднимается, и даже если делаешь клон очередной популярной игры, нужно сделать его чем-то лучше (иначе зачем в него играть).</code></strong></p><p>Кроме того, постоянно меняются способы монетизации, появляются новые платформы, то что было приемлемо пару лет назад, не сработает сейчас. Может оказаться, что игра, которую вы делали несколько лет, перестала быть актуальной. Игры делать дорого и долго, и всегда есть шанс, что игрокам просто не понравится то, что вы сделали.</p><p><strong><code>- Не стоит идти в геймдев, чтобы сделать игру мечты.</code></strong></p><p>Игры делают, чтобы зарабатывать деньги, поэтому делать вы будете то, что приносит деньги. Скорее всего, придётся писать очередную матч-3 или слоты для телефонов. Так что, если хотите длительно работать в геймдеве, вам должно нравиться делать вообще любые игры. Просто помните, что и <code>до разработки игры мечты тоже когда-нибудь доберётесь</code>.</p><p>Если просто хочется сделать свою крутую игру без опыта, <strong>НЕ НАДО</strong>: собирать команду друзей или участвовать в хакатонах (лучше вообще их не касаться, это как олимпиадное программирование). Лучше всего попробовать реализовать то, что хочется, в виде мода для уже существующей игры - так рождались <code>Counter-Strike</code>, <code>DotA</code>, <code>Team Fortress</code>.</p><p><strong><code>- В геймдеве чаще встречаются интересные люди, которые интересуются не только покупкой второй машины и куда вложить заработанные 300кк/сек$.</code></strong></p><p>Это мой опыт, кто-то отписывается, что видел геймдев-галеры.<br>Встречаются компании с интересной корпоративной культурой и необычной организацией, можно почитать про устройство <a href="http://media.steampowered.com/apps/valve/hbook-RU.pdf" target="_blank" rel="noopener">Valve</a> или <a href="https://habr.com/ru/post/358882/" target="_blank" rel="noopener">Supercell</a>.</p><p><strong><code>- Делать игры компанией – всегда челлендж, сверх-усилие и рисковая ставка на вашу игру всей командой.</code></strong></p><p> Т.е. нужно быть немного азартным, и чувствовать себя <em>причастным</em> (как бы по сектантски это не звучало) к тому, что происходит.</p><p>Наверное, это меньше ощущается, если фрилансить (хотя написание кода в больших проектах аутсорсят намного реже, чем арт), или заниматься чем-то, что не связано с выпуском игры (например, писать игровой редактор или движок).</p><p><a href="https://kdicast.com/" target="_blank" rel="noopener">https://kdicast.com/</a> - можно послушать, чтобы вникнуть немного, чем живут разработчики игр.<br><a href="https://habr.com/ru/post/500320/" target="_blank" rel="noopener">https://habr.com/ru/post/500320/</a> - автор пытался провести исследование про кол-во людей в разных компаниях, можно представить себе разные по объёму и сложности игр компании.</p><h2 id="Периоды-разработки-игры"><a href="#Периоды-разработки-игры" class="headerlink" title="Периоды разработки игры"></a>Периоды разработки игры</h2><p>Одно из самых прикольных ощущений – понять, что участвовал в разработки игры с чистого листа и до релиза. Оценить, как труд десятков (или сейчас скорее даже сотен) людей воплощается в виде конечного продукта, в который будут играть миллионы пользователей.</p><p>Самые веселые периоды разработки: <code>придумывание концепта</code>, и стадия, когда становится понятно, <code>что представляет собой игра и какая она будет</code>.<br>Самые сложные: <code>полировка игры</code> (когда уже почти не добавляется ничего нового), и <code>кранчи перед релизом</code>.</p><p>Печально известные кранчи являются чуть ли не стандартом в разработке игр, их сейчас активно обсуждают повсюду (примеры <a href="https://habr.com/ru/post/489946/" target="_blank" rel="noopener">один</a>, <a href="https://dtf.ru/games/29454-kranchi-v-igrovoy-industrii-analiz-prichiny-posledstviya" target="_blank" rel="noopener">два</a>, <a href="https://dtf.ru/gamedev/14956-rabota-na-iznos-prichiny-i-posledstviya-kranchey-v-igrovoy-industrii" target="_blank" rel="noopener">три</a> ну или гуглите дальше самостоятельно). Интересно, изменится ли что-то от этих обсуждений :) . В результате люди устают и выгорают.</p><p>Последняя ночь перед выходом игры – это нервозное состояние, в котором ты находишься дни/недели/месяцы, и когда ты понимаешь, что от тебя и ещё нескольких человек зависит, получится ли что-то или не придётся ли чинить игру сразу же, как её попробуют игроки. Если поискать плюсы, то это лучший способ тимбилдинга (остальные – это по сути пьянки на деньги компании, что тоже конечно нужно), и проверка волевых качеств людей. В целом, ничего хорошего в этом, естественно, нет, особенно если ты старше 30, и понимаешь, что следующий апдейт/игра будут доделываться в точности так же.</p><p>Старая заметка из 2012 года, как вообще работать в таком режиме: <a href="/blog/19419/" title="Ускорение написания кода">Ускорение написания кода</a></p><h2 id="Как-развиваться"><a href="#Как-развиваться" class="headerlink" title="Как развиваться"></a>Как развиваться</h2><p>Старые заметки:<br><a href="/blog/1048/" title="2011 – Как устроиться на работу программистом">2011 – Как устроиться на работу программистом</a> – за короткий промежуток времени несколько одногруппников и один преподаватель задали этот вопрос, поэтому проще было давать им сразу ссылку :)<br><a href="/blog/15798/" title="2020 – Уровень программирования: Middle">2020 – Уровень программирования: Middle</a> – как быть, когда подрос немного.</p><p>В нормальных компаниях есть назначаемые менторы/товарищи, которые помогут влиться, и проследят за тем, чтобы не заваливали однообразными тасками, и была возможность делать что-то интересное. В целом, в геймдеве можно и нужно интересоваться всем, что происходит в команде. Тогда среди хаосы и суеты, можно начать видеть закономерности и процессы, и в них участвовать. Если этого нет, стоит хотя бы самому следить за тем, что вообще происходит в индустрии.</p><ul><li>Что происходит с рынком игр?</li><li>Какие тенденции у индустрии вообще?</li><li>Какие есть конкуренты у игры, которую вы делаете?</li><li>Какие игры вообще делает ваша компания, чем она особенная?</li><li>Что вы будете делать через год?</li><li>Новости: какие игры/платформы выходят, чем занимаются крупные студии?</li></ul><p>Если с ответами на эти вопросы всё ок (либо вас не особо волнуют), можно задуматься и о том, что изучать.</p><p>В первую очередь, конечно язык и движок, которыми пользуетесь, но с опытом вы поймёте, что программировать умеет много кто, а вот людей с пониманием всего процесса разработки намного меньше.</p><p>В маленьких командах вынужденно существует совмещение ролей - т.е. программист немного узнаёт о геймдизайне, маркетинге, издании игры, психологии игроков (понимании своей аудитории), и ещё о разных вещах по чуть-чуть. И если в большой команде какой-нибудь хитрец мог “выпустить игру”, просто гребя в одной лодке с теми, кто её действительно делал (или вообще, в сторонке кофе попивая на кухне), то в маленькой человек с большой долей вероятности знает в ней (в игре, да и в его команде) всё от начала до конца.</p><p>Преимуществом же работы в большой команде является то, что только в таких можно поучаствовать в создании действительно “большой” игры, на которую в маленькой просто не хватило бы ресурсов. Отдельный опыт – это вырасти с компанией от маленькой до большой, изучая, как меняется подход к разработке всё более продвинутых игр.</p><h2 id="Техническое-развитие"><a href="#Техническое-развитие" class="headerlink" title="Техническое развитие"></a>Техническое развитие</h2><p><em>“Что всё-таки почитать программисту игр?”</em><br>Найти какой-нибудь список литературы легко - <a href="https://github.com/miloyip/game-programmer" target="_blank" rel="noopener">https://github.com/miloyip/game-programmer</a><br>(По большей части там ненужные книги, но среди них есть все несколько хороших).</p><p>Вся литература делится на 4 категории:</p><p><strong><code>- Мануалы к инструменту.</code></strong><br>Нужны только в начале карьеры, с опытом проще просто документацией пользоваться, а не книгой</p><p><strong><code>- Набор суперполезных практик</code></strong><br>Здесь стоит читать всё, что получится достать и понять (некоторые целиком сразу не осилить).<br>Про такие книги стоит написать отдельно более детально, сейчас просто список:<br> <code>Стив Макконнел. &quot;Совершенный код&quot;</code><br> <code>Скотт Мейерс. &quot;Эффективное использование С++&quot;/&quot;Эффективный и современный С++&quot;/&quot;Наиболее эффективное использование С++&quot;</code> (все 3 хороши и покрывают разные темы)<br> <code>Банда четырёх. &quot;Приемы объектно-ориентированного проектирования. Паттерны проектирования&quot;</code><br> <code>Robert Nystrom &quot;Game programming patters&quot;</code> (<a href="https://gameprogrammingpatterns.com/" target="_blank" rel="noopener">ссылка</a>)</p><p><strong><code>- Фундаментальные книги.</code></strong><br>Нужны, но только когда появляется желание глубже разбираться в предмете. Обычно читать всё не нужно, достаточно выбрать только по своей специализации. Примеры:<br> <code>Нати Хофман, Томас Мёллер, и Эрик Хэйнс. &quot;Real-Time Rendering&quot;</code><br> <code>Джейсон Грегори. &quot;Архитектура игровых движков&quot;</code><br> <code>Глейзер Джошуа и Мадхав Санджай. &quot;Многопользовательские игры. Разработка сетевых приложений&quot; (единственная нормальная про сетевые игры)</code></p><p><strong><code>- Книги-справочники/сборники статей.</code></strong><br>Как все серии книг <code>Gems</code>. Не особо нужны, процентов 80% материала вам там никогда не понадобятся, а если и будет сходная с реальной задача, окажется, что информации для её решения там недостаточно, и всё равно нужно дальше копать.</p><p>Кроме книг, чтобы быть в курсе того, что происходит, нужно найти и следить за людьми из тех, кто занимается решением сложных проблем, и находится “на острие прогресса”:</p><p><code>Выступает с интересными техническими докладами (gdc, siggraph, тематические unity/unreal конференции)</code>.</p><p><code>Авторы интересных библиотек/движков/фреймворков</code>.  (для мониторинга: их гитхаб, блоги, твиттеры, reddit/hacker news-сообщества). Почти бесполезны митапы, бесполезные конфы, тусовочки, подкасты.</p><p><code>Изучить обновляемые подборки open-source библиотек</code>.<br><a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">Awesome c++</a>/<a href="https://github.com/Caerind/AwesomeCppGameDev" target="_blank" rel="noopener">Awesome C++ gamedev</a>/<a href="https://github.com/skywind3000/awesome-gamedev" target="_blank" rel="noopener">Awesowe gamedev tools</a>/подобные</p><p><code>&quot;Витрины&quot; тулзов и ассетов - Unity asset store, itch.io и подобные</code>.</p><p><code>Новые движки и подходы</code>.<br>Когда-то новыми были <strong>Unity</strong>, и открытый публике <strong>Unreal</strong>, из открытых можно было изучать <strong>Cocos-2d</strong>, <strong>Ogre3D</strong>, сейчас, к примеру, <strong>Godot</strong>, middleware инструменты вроде <strong>Bgfx</strong></p><h2 id="Гештальты-геймдева"><a href="#Гештальты-геймдева" class="headerlink" title="Гештальты геймдева"></a>Гештальты геймдева</h2><p>Объём того, что нужно знать программисту игр, вызывает лёгкую тоску. Это нормально. Вдобавок, знания приходится обновлять где-то раз в 5 лет (это нормально, наверное, для любой области CS). Но, кроме этого, после начала изучения некоторых областей встречаешься с ещё одним явлением, которое я называю “гештальтом”. Проще объяснить это на примере. </p><p><strong><code>Графическое программирование</code></strong><br>Начинающий программист заканчивает читать первую книгу или набор уроков по <code>OpenGL</code>/<code>DirectX</code>, пробует нарисовать что-либо, и обнаруживает, что кроме текстурированных кубиков и чайников, ничего не получается, вдобавок, они у него какие-то тусклые. Остаётся незакрытый гештальт - желание программировать графику и писать шейдеры, без понимания, как это сделать. Думаю, именно этим вызвано излишне романтизированное отношение начинающих программистов игр к шейдерам и программированию визуальных эффектов.</p><p>Почему же ничего не получается? API к видеокарте – это не всё, что нужно изучить. После этого необходимо разобраться с <code>математикой</code>,чтобы понять, как вообще устроена компьютерная графика. Это сложнее, чем просто разобраться с API, но зато после понимания основ уже почти не останется вопросов, почему конвейер видеокарты построен именно так. И, наконец, станет возможным реализовать задуманный эффект без того, чтобы слепо копировать его из учебников и статей. Можно попробовать заняться <a href="https://en.wikipedia.org/wiki/Creative_coding" target="_blank" rel="noopener">креативным программированием</a> или, наконец, написать шейдер сложнее, чем просто повторяющий стандартные модели освещения. Но и этого недостаточно, чтобы программировать графику для игр.</p><p>Есть и “третья сторона медали” – <code>изучение железа</code>, на котором будут выполняться программы. Игры обновляют изображение на экране 30-60 раз в секунду, и нужно научиться представлять себе, что можно успеть сделать за время отрисовки одного кадра на целевой платформе. Где-то на этом этапе по другому начинаешь смотреть на доступное API, и ощущать все его ограничения. Но зато – гештальт с желанием создавать графику наконец может быть закрыт.</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODY4IiBoZWlnaHQ9IjEyOCIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDg2OCAxMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTEwNC41IDQ0LjUgTDEwNC41IDY0LjUgTDI2Ni44IDg0LjUgTDI2Ni44IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI1Mi45IDg4LjIgTDI2MC4xIDgzLjcgTDI1NC4yIDc3LjYgTDI2Ni44IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zOTIuNSA0NC41IEwzOTIuNSA2NC41IEwzOTIuNSA4NC41IEwzOTIuNSA4NC41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0zODcuMiA3MS4yIEwzOTIuNSA3Ny44IEwzOTcuOCA3MS4yIEwzOTIuNSA4NC41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNzIyLjUgNDQuNSBMNzIyLjUgNjQuNSBMNTM2LjYgODQuNSBMNTM2LjYgODQuNSAiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNNTQ5LjMgNzcuOCBMNTQzLjIgODMuOCBMNTUwLjQgODguNCBMNTM2LjYgODQuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHJlY3QgeD0iMTMuNSIgeT0iMTMuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjE4MiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjIxLjUiIHk9IjM1IiBzdHlsZT0iIj7QmNC30YPRh9C10L3QuNC1IEFQSTwvdGV4dD4KPHJlY3QgeD0iMTk1LjUiIHk9Ijg0LjUiIGhlaWdodD0iMzEiIHdpZHRoPSIzOTQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMDMuOCIgeT0iMTA2IiBzdHlsZT0iIj7Qn9GA0L7Qs9GA0LDQvNC80LjRgNC+0LLQsNC90LjQtSDQs9GA0LDRhNC40LrQuDwvdGV4dD4KPHJlY3QgeD0iMjM1LjUiIHk9IjEzLjUiIGhlaWdodD0iMzEiIHdpZHRoPSIzMTQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyNDMuOCIgeT0iMzUiIHN0eWxlPSIiPtCY0LfRg9GH0LXQvdC40LUg0LDQu9Cz0L7RgNC40YLQvNC+0LI8L3RleHQ+CjxyZWN0IHg9IjU4OS41IiB5PSIxMy41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjY2IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iNTk3LjgiIHk9IjM1IiBzdHlsZT0iIj7Qn9C+0L3QuNC80LDQvdC40LUg0LbQtdC70LXQt9CwPC90ZXh0Pjwvc3ZnPg==" /><p>Чаще всего эти три направления изучаются именно в таком порядке, из-за доступности материалов и сложности понимания, но они не базируются друг на друге. Т.е. изучить только железо, или только алгоритмы компьютерной графики можно, не это не даст инсайта <em>“ага, теперь я могу писать крутые шейдеры”</em>, необходимо разобраться в каждом из трёх.</p><p>Из-за того, что эти направления не связаны друг с другом, легко застрять на каком-то этапе на несколько лет с “незакрытым гештальтом”, без понимания, из-за чего же не получается выполнять практические задачи. Знаю по себе. Когда-то сам так застрял и смотрел на демосцену как на какое-то непостижимое чудо – <a href="/blog/10414/" title="2012 – inout">2012 – inout</a></p><p><strong><code>Сетевое программирование</code></strong><br>Второй обнаруженный мной гештальт – <code>программирование MMO</code>. Здесь тоже прежде чем начать что-то делать, необходимо понять сразу несколько идей, без которых перейти от базового повторения готовых идей и простых игр к серьёзным невозможно. Тут я не могу так чётко отделить “домены знаний” друг от друга, но попробую выделить такие направления изучения:</p><ul><li>Протоколы передачи данных</li><li>Создание игрового протокола</li><li>Общая архитектура игры</li><li>Архитектура клиента с авторитарным сервером</li><li>Архитектура масштабируемого сервера</li><li>Архитектура бекэнда и сервисов</li></ul><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzgwIiBoZWlnaHQ9IjUwNCIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDM4MCA1MDQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHJlY3QgeD0iMTMuNSIgeT0iMTMuNSIgaGVpZ2h0PSI0NzgiIHdpZHRoPSIzNTQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMS41IiB5PSIzNSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtCe0LHRidCw0Y8g0LDRgNGF0LjRgtC10LrRgtGD0YDQsDwvdGV4dD4KPHRleHQgeD0iMjMxLjIiIHk9IjEzOS41IiBzdHlsZT0iZm9udC13ZWlnaHQ6bm9ybWFsOyI+0J/RgNC+0YLQvtC60L7Qu9GLPC90ZXh0Pgo8cGF0aCBkPSJNMjIzLjIgMTE5LjUgTDIwOCAxMzkuNSBMMjA4IDE1OS41IEwyMDggMTU5LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTIwMi43IDE0Ni4yIEwyMDggMTUyLjggTDIxMy4zIDE0Ni4yIEwyMDggMTU5LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yMTkuNCAxMzMuMyBMMjE5LjIgMTI0LjggTDIxMC45IDEyNi45IEwyMjMuMiAxMTkuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMjE2IiB5PSIzNDIuNSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtCf0YDQvtGC0L7QutC+0LvRizwvdGV4dD4KPHBhdGggZD0iTTIwOCAzMjIuNSBMMjA4IDM0Mi41IEwyMjMuMiAzNjIuNSBMMjIzLjIgMzYyLjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTIxMC45IDM1NS4xIEwyMTkuMiAzNTcuMiBMMjE5LjQgMzQ4LjcgTDIyMy4yIDM2Mi41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNMjEzLjMgMzM1LjggTDIwOCAzMjkuMiBMMjAyLjcgMzM1LjggTDIwOCAzMjIuNSBaIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojMzMzMjJFO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5My44IDExOS41IEwzMDkgMTM5LjUgTDMwOSAzNDIuNSBMMzA5IDM0Mi41IEwyOTMuOCAzNjIuNSBMMjkzLjggMzYyLjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTI5Ny42IDM0OC43IEwyOTcuOCAzNTcuMiBMMzA2LjEgMzU1LjEgTDI5My44IDM2Mi41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNMzA2LjEgMTI2LjkgTDI5Ny44IDEyNC44IEwyOTcuNiAxMzMuMyBMMjkzLjggMTE5LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxyZWN0IHg9IjI2LjUiIHk9IjU3LjUiIGhlaWdodD0iMzEiIHdpZHRoPSI5NiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjM0LjUiIHk9Ijc5IiBzdHlsZT0iIj7QntCx0YnQtdC1PC90ZXh0Pgo8cmVjdCB4PSIxNjIuNSIgeT0iMjYuNSIgaGVpZ2h0PSI5MyIgd2lkdGg9IjE5MiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjIxMC41IiB5PSI0OCIgc3R5bGU9IiI+0JrQu9C40LXQvdGCPC90ZXh0Pgo8cGF0aCBkPSJNMTYyLjUgNTcuNSBMMzU0LjUgNTcuNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+Cjx0ZXh0IHg9IjE3MC41IiB5PSI3OSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtC70L7Qs9C40LrQsDwvdGV4dD4KPHBhdGggZD0iTTE2Mi41IDg4LjUgTDM1NC41IDg4LjUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8dGV4dCB4PSIxNzAuNSIgeT0iMTEwIiBzdHlsZT0iZm9udC13ZWlnaHQ6bm9ybWFsOyI+0LDRgNGF0LjRgtC10LrRgtGD0YDQsDwvdGV4dD4KPHJlY3QgeD0iMTQ3LjUiIHk9IjE1OS41IiBoZWlnaHQ9IjE2MyIgd2lkdGg9IjEyMiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6I2VlZThkNTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3JlY3Q+Cjx0ZXh0IHg9IjE2MC41IiB5PSIxODEiIHN0eWxlPSIiPtCh0LXRgNCy0LXRgDwvdGV4dD4KPHBhdGggZD0iTTE0Ny41IDE5MC41IEwyNjkuNSAxOTAuNSIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+Cjx0ZXh0IHg9IjE1NS41IiB5PSIyMTIiIHN0eWxlPSJmb250LXdlaWdodDpub3JtYWw7Ij7RgdC10YDQstC10YAxPC90ZXh0Pgo8cGF0aCBkPSJNMTQ3LjUgMjIxLjUgTDI2OS41IDIyMS41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMTU1LjUiIHk9IjI0MyIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtGB0LXRgNCy0LXRgDE8L3RleHQ+CjxwYXRoIGQ9Ik0xNDcuNSAyNTIuNSBMMjY5LjUgMjUyLjUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cGF0aCBkPSJNMTQ3LjUgMjYwLjUgTDI2OS41IDI2MC41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMTU1LjUiIHk9IjI4MiIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtGB0LXRgNCy0LXRgDI8L3RleHQ+CjxwYXRoIGQ9Ik0xNDcuNSAyOTEuNSBMMjY5LjUgMjkxLjUiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8dGV4dCB4PSIxNTUuNSIgeT0iMzEzIiBzdHlsZT0iZm9udC13ZWlnaHQ6bm9ybWFsOyI+0YHQtdGA0LLQtdGAMjwvdGV4dD4KPHJlY3QgeD0iMTk0LjUiIHk9IjM2Mi41IiBoZWlnaHQ9IjkzIiB3aWR0aD0iMTI4IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEwLjUiIHk9IjM4NCIgc3R5bGU9IiI+0JHQtdC60Y3QvdC0PC90ZXh0Pgo8cGF0aCBkPSJNMTk0LjUgMzkzLjUgTDMyMi41IDM5My41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMjAyLjUiIHk9IjQxNSIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPkRCPC90ZXh0Pgo8cGF0aCBkPSJNMTk0LjUgNDI0LjUgTDMyMi41IDQyNC41IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHRleHQgeD0iMjAyLjUiIHk9IjQ0NiIgc3R5bGU9ImZvbnQtd2VpZ2h0Om5vcm1hbDsiPtCh0LXRgNCy0LjRgdGLPC90ZXh0Pjwvc3ZnPg==" /><p><em>Примерная диаграмма игры, может отличаться в разных проектах.</em></p><p>Несмотря на то, что на диаграмме различные компоненты нарисованы отдельно, заниматься разработкой отдельной части без базового понимания архитектуры и устройства других компонент не получится (В целом, отделяется бекэнд, и связь между клиентом и сервером; но писать клиент без знания игрового и лежащего под ним протокола и существования авторитарного сервера не выйдет).</p><p>Кроме непосредственно архитектуры отдельных компонент, сами части тоже имеют определённые уровни понимания. Например, для игрового сервера:</p><ul><li>дизайн асинхронных систем</li><li>работа с ОС</li><li>знание о уровнях сетевых протоколов ниже прикладного</li><li>понимание причин задержек и умение их устранять</li><li>синхронизация данных</li><li>навыки написания надёжного кода</li></ul><p>Собрать нужную для освоения информацию и проверить её здесь немного сложнее, чем с графикой.</p><p><strong><code>Движки</code></strong></p><p>Движок выглядит как огромная монолитная система для игрового программиста, со своими правилами, подходами и идиомами.</p><p>Ему приходится смотреть на новый движок так:<br><img src="/blog/3652741154/game-engine.png" alt="game-engine"><br><em>(Схема из книги Джейсона Грегори. “Архитектура игровых движков”)</em></p><p>В комплекте с движком обязательно идут игровые тулзы и инструменты, для их описания можно было бы нарисовать ещё одну такую же по размерам схему.</p><p>Движки в целом, конечно, намного лучше разбиты на компоненты, которые не требуют понимания других частей системы, но показательно то, что существует очень мало отделяемых от движка компонент, которые могут быть использованными в других игровых движках. Например, на приведённой выше схеме отделяемым и переносимым компонентами отведена <strong>ОДНА</strong> строчка.</p><p>Из-за этого я с энтузиазмом на проекты с попытками вынести в отделяемые компоненты, то что ранее не отделялось, например <a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">Bgfx</a>.</p><p><strong><code>Не гештальты</code></strong><br>Сначала хотел попытаться выделить в гештальты ещё какие-либо подходы к <code>дизайну</code> систем, однако понял, что это совсем не так – проектировать программы можно без понимания “всей картины”. Навыки построения хорошей архитектуры, к счастью, прокачиваются (если их прокачивать) с каждой следующей попыткой.</p><p>Также не является гештальтом <code>навык программирования</code> в целом. Вполне можно писать программы, не понимая как-либо важных концепций computer science, например, без рекурсии, лямбда-исчисления, или даже указателей. Понимание новых идей расширит арсенал выбора решений и может (только может, не обязано) сделать код компактнее, надёжнее, быстрее, и главное, <strong>ПРОЩЕ</strong>, но не откроет доступ к чему-то принципиально недостижимому ранее.</p><p><a href="https://www.youtube.com/watch?v=SzJ46YA_RaA&amp;ab_channel=DoS-DomainofScience" target="_blank" rel="noopener">Карта информатики</a> занимательна для изучения, но необязательна, чтобы заниматься любой из областей компьютерных наук.</p><h2 id="Инструменты"><a href="#Инструменты" class="headerlink" title="Инструменты"></a>Инструменты</h2><p>Одним из свойств человека, возвышающим его над другими животными, является умение и желание создавать инструменты для решения задач. Уровень сложности и скорость решения задач, которые мы можем решить, ограничены тем, можем ли мы найти или создать необходмый инструмент. Сами программы являются нашими инструментами, но иногда, особенно, новичкам, кажется, что инструменты программиста – это ТОЛЬКО программы.</p><p><strong><code>Железо</code></strong></p><p><code>Исследуйте железо и платформу, на которой будет работать ваша игра</code><br>(актульально и для других типов программ, не только игр)</p><p>Большой обман индустрии - <em>“Software is a platform”</em>. Но карта не территория – <em>“Hardware is a platform”</em>.<br>Тут проще не пересказывать дальше, а просто взять доклад Майкла Эктона - <a href="https://www.gdcvault.com/play/1012200/Three-Big-Lies-Typical-Design" target="_blank" rel="noopener">Three Big Lies: Typical Design Failures in Game Programming</a> (Тайминг 18:52). Или этот вариант на youtube:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/rX0ItVEVjHc" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><br>Что вам даст понимание железа?</p><p><code>Возможность получить больше от железа</code> - или даже подойти к тому, чтобы выжать максимум производительности.<br><code>Использовать особенности железа в свою пользу</code> - aka “Хакинг”. Можно выйти и за пределы максимума.<br><code>Закрытие гештальтов</code> - добраться наконец до понимания и начать делать крутые вещи.<br><code>Выкинуть клоунов из машины</code> - <a href="https://youtu.be/p65Yt20pw0g?t=112" target="_blank" rel="noopener">ссылка</a>. Железо телефонов и консолей чаще всего достаточно мощное, но вы не можете его использовать оптимально. Если ваша машина едет недостаточно быстро, то, возможно, проблема не в движке, а в том, что машина полна клоунов.<br><img src="/blog/3652741154/clowns.jpg" alt="clowns"><br><a href="https://tonsky.me/blog/disenchantment/ru/" target="_blank" rel="noopener">Разочаровние в софте</a> - статья Никиты Прокопова о деградации современного софта.</p><p><strong><code>Изучайте способы получения информации о вашей игре</code></strong><br>Даже понимая устройство железа, сложно предсказать поведение игры с учётом ВСЕХ его особенностей вместе. Оптимизация может не дать ожидаемого результата из-за чего-то неучтённого заранее. Поэтому не стоит забывать об измерениях на реальном железе, или на созданных синтетических тестах. </p><p>Естественно, базовые способы получения информации - это измерение скорости выполнения отдельных частей кода и количества потребляемой памяти.</p><p>Возможный выбор улучшаемых параметров игры:<br><code>Уменьшение времени запуска игры</code><br><code>Уменьшение потребления памяти в основных сценах</code><br><code>Уменьшение требований к мощности процессора и видеокарты игры</code><br><code>Уменьшение дистрибутива игры</code></p><p>Ну и в дополнение к железным параметрам, геймплейные и маркетинговые:<br><code>Уменьшение времени до получения игроков удовольствия от игры (игровая сессия или её часть)</code><br><code>Уменьшение необходимых усилий по трате игроков денег</code></p><p>С учётом времени сборки игры и выполнения самих тестов, стоит задуматься также:<br><code>Уменьшение времени сборки и доставки игры команде разработки, тестирования, поддержки (и остальным)</code><br><code>Уменьшение времени проведения проверок и тестов</code><br><code>Уменьшение времени реакции на ошибки и их исправления</code></p><p><strong><code>Старайтесь создавать и находить совместимые друг с другом компоненты</code></strong></p><p>  <a href="/blog/381238762/" title="ECS. Ссылки">ECS. Ссылки</a> - entity-component-system - подход к дизайну программ, одной из особенностей которого является проектирование компонент так, чтобы переиспользовать их.</p><p>  <a href="/blog/3291927125/" title="Модульность в дизайне уровней">Модульность в дизайне уровней</a> - не только в программировании.</p><p>Это сложнее, чем создавать или использовать готовые монолитные решения, и имеет смысл только в длительной перспективе, но даёт возможность переиспользования отдельных частей в других похожих проектах.</p><h2 id="Языки-программирования"><a href="#Языки-программирования" class="headerlink" title="Языки программирования"></a>Языки программирования</h2><p>Рассуждения о языках:<br><a href="https://floooh.github.io/2018/06/02/one-year-of-c.html" target="_blank" rel="noopener">One year of C</a> - Andre Weissflog о разных языках и их качествах<br><a href="https://habr.com/ru/post/259831/" target="_blank" rel="noopener">Как я нашёл лучший язык программирования</a> - Андрей Платов о поисках лучшего в мире языка</p><p>Знать один язык программирования в современном мире для разработчика катастрофически мало.</p><p>Во-первых, в многих областях в проектах используется по несколько языков изначально (веб, разделеный по языкам бекенд и фронтенд, системы сборки как недо-язык, скриптовый язык для гуи или логики программы).</p><p>Во-вторых, даже если есть “супер-подходящий” для какой-либо области язык, существует большой шанс остаться динозавром, когда ему на смену придёт что-то другое. Даже если кажется, что язык в своей нише будет использоваться много лет, с текущей скоростью обновления версий языков, разница между несколькими версиями одного языка выглядит значительной (программист, знающий только ранние версии C#, Java, C++, скорее всего вообще не поймёт код на современных версиях). “Новые” фичи из обновленных стандартов языков - на самом деле уже обкатаны в других менее известных языках, и значительно проще начинать пользоваться ими не с нуля.</p><p>В-третьих, рано или поздно наступает “смена эпох”, когда приходит новая парадигма, позволяющая решать задачи быстрее. Это одно из важнейших качеств языка - увеличивать производительность программиста, использующего его (точнее даже, речь не только о самом языке, правильнее наверное называть это сменой технологии). Раньше других обнаружить такое может быть полезно для получения преимуществ над конкурентами.</p><p>В-четвёртых, даже если языка хватает для работы, есть ещё программирование “для души”. Языки “для работы” могут быть эффективными в какой-либо предметной области (или просто являться де-факто стандартом, не имея каких-либо преимуществ), но быть совершенно неудобными для того, что использовать их для создания домашних проектов. Найти что-то принципиально отличающееся от используемого обычно языка позволяет “расширить сознание” - начать получать больше удовольствия от программирования, по новому взглянуть на старый хорошо известный язык.</p><p>Однако изучать все языки подряд не хватит ни времени, ни сил, поэтому удобно подобрать набор языков, из которых составится личный “швейцарский нож” для решения максимально широкого спектра задач.<br>Моя основная пара языков – С++ и Python.</p><p><strong><code>C++</code></strong><br>Основной годами используемый мной в работе язык - С++, естественно, в разработке игр выбор невелик. Очень хорошо подходит для:</p><p><code>Разработка движков игр</code>. Основная причина, по которой используется именно он - это один из немногих языков, которые позволяют писать как на максимально низком уровне, позволяя детально контролировать место и способы расположения данных в памяти, так и на достаточно высоком, не вдаваясь в эти детали там, где это не нужно (правда, и по скорости такой код будет “обычным”). Плата за это - сложность языка и необходимость понимания многих деталей его работы. Причём сложность возрастает с каждым новым обновлением стандарта, и чтобы разобрать все нюансы правил, необходима бригада трактовщиков стандарта, а также специалистов по всем компиляторам, которыми должна быть собрана программа. С++ - это единственный известный мне язык, в котором абсолютно необходимы запреты на использование различных его частей. Для разработки логики игр могут быть использованы и другие языки.<br><a href="https://floooh.github.io/2013/06/21/sane-c.html" target="_blank" rel="noopener">Sane C++</a> - небольшая статья про C++ в геймдеве</p><p>Для логики игр C++ в основном используют там, где по какой-то причине нельзя использовать другие языки. Или если сложно разделить движковый и игровой код, или нужно остаться в рамках одного языка по другой причине, чтобы не требовать знания двух языков от разработчика. Но идея с вынесением логики на lua или c# (как в Unity) здравая.</p><p><code>Кросс-языковые библиотеки</code>. Практически все языки имеют возможность взаимодействовать в библиотеками, написанными на языке C. Если планируется, что код может быть вызван из десятка других языков - лучше написать его на C (или на сильно ограниченном подмножестве языка C++).</p><p>Немного хуже для:<br><code>Низкоуровневый код</code>. Тут наверное даже лучше подходит C, как “обёртка над ассемблером”, если где-то это ещё нужно. Почти не сталкивался (для NES собирал бинарники с помощью CC65), возможно лучше подойдёт Go.</p><p><code>Достоинства</code> - С++98 платформонезависимый код, написанный десятки лет назад, вероятно скомпилируется и будет работать (минус - и он до сих пор может вам попасться). Код легко собрать под любую архитектуру (хотя с появлением компиляторов в LLVM байт-код, это стало проще и для других языков).<br><code>Минусы</code> - язык-франкенштейн, к которому продолжают пришивать куски. Надстройки над языком - шаблоны, которые не очень органично сочетаются с самим языком (сообщения об ошибках в шаблонах до сих пор могут взорвать мозг неподготовленному программисту), порождающие свой стиль программирования, тяжелый для изучения; макросы, никак не проверяющие корректность предложенной замены. Ошибки доступа к памяти - утечки, сегфолты, нулевые указатели. Легко упустить ситуацию, когда объекты классов могут выполнить очень много неочевидных действий, ускользнувших от внимания программиста. При работе в команде вам придётся отслеживать различные попытки использовать язык неправильно, или устанавливать запреты на использование “нехороших” (медленных, опасных, недоделанных) фич языка.</p><p>Возможные замены:</p><ul><li>D - попытка исправить недостатки С++, малопопулярный язык. </li><li>Objective C/Objective C++ - такая же <em>“франкенштейновость”</em>, vendor-привязка к Apple.</li><li>Rust - сырой (не production-ready для игр).</li></ul><p><strong><code>Python</code></strong></p><p>Зная только его, можно сделать очень многое!<br>Очень хорошо подходит для:</p><p><code>Автоматизации всего</code> - множество готовых модулей для всего, что только можно. Изначально я изучил его на работе и был впечатлён именно этим - можно было упростить большое количество рутинных задач, причём решения можно записать в несколько строк. Также на тот момент сильно порадовала простая работа с файлами и сетью (хотя, если разбираться глубже, с этим есть проблемы - то баги работы с протоколами в стандартной библиотеки, то ад с заданием кодировок, но это всё было во времена Python 2.4. Второй питон и медленный переход на третий вообще, имхо, был главной проблемой языка). Альтернативы в этом особо нет, возможно, Perl, который отпугивает синтаксисом.</p><p><code>Cкриптование своих и чужих программ</code>. Python относительно легко встроить в свои программы, чтобы получить возможность использовать их в качестве библиотеки, или дать возможность продвинутым пользователям выполнять их собственные задачи с помощью вашей программы. Также, он очень часто встроен в различные профессиональные программы, и навыки работы с ним помогут вам пользоваться ими в полной мере. Для скриптования встречается Lua в тех программах, где нужна легковесность взамен мощи, и JavaScript там, где, гмм, программа представляет собой страничку для отображения контента (шутка, на самом деле тоже очень интересный вариант для скриптования). </p><p><code>Научных рассчётов</code>. Много готовых библиотек - NumPy/SciPy - стандарт для “серьёзной науки”. При этом чаще всего код, критичный по производительности, пишется на С, и компилируется в динамическую библиотеку, после чего её можно импортировать как модуль в Python. Также очень круто выглядит Jupyter Notebook - в котором можно как писать код, так и оформлять статьи. Про него вообще лучше рассказать как про отдельный инструмент - это оболочка для интерактивной работы с любыми языками, для пользователя выглядящая как страничка в браузере. Альтернативы - Matlab и специализированные программы, или вообще оставаться в рамках си ради скорости.</p><p>Немного хуже подходит для:<br><code>Прототипирование</code>. Быстрая сборка на коленке сложных вещей – моя любимая часть в программировании. Вначале это очень впечатляет, однако именно из-за этой области хочется добавить в свой арсенал какой-нибудь язык, который при сопоставимой скорости разработки и доступности библиотек не имел бы недостатков Python - низкой скорости быстронаписанного кода, невозможности легко запаковать приложение в standalone исполняемый файл (фактически есть два пути - либо учить пользователей ставить интерпретатор и запускать скрипты, либо паковать весь Python и модули вместе с приложением). Также не особо радует динамическая типизация, не хочется отказываться от возможностей компилятора в проверке и оптимизации кода. В качестве замены мог бы подойти <a href="https://nim-lang.org/" target="_blank" rel="noopener">Nim</a></p><p><code>Недостатки</code> - не очень хорошо подходит для функционального стиля программирования (анонимные функции искусственно ограничены в синтаксисе, не всегда возможно красиво записать в “функциональный однострочник” то, что хочется); различия в версиях интерпретатора усложняют проверку кода и библиотек.<br>Достоинства - код очень идиоматичен, среди множества различных способов что-либо сделать можно найти “самый красивый”; приятный синтаксис; учится за несколько дней. Кроссплатформенный для десктопных ОС (если очень постараться, можно с ограничениями использовать для мобильных платформ, из-за ограничений все прелести теряются - ни для одной из перечисленных целей полноценно использовать не получится).</p><p>Вместо Python для прототипирования пробовал:</p><ul><li>Swift<br>Бегло, приятный python-inspired синтаксис, но за пределами операционных систем от Apple не ясно, как это будет жить.</li><li>C#/Scala/Kotlin<br>Внимательно. Выразительные языки, после некоторого шаманства можно добавить возможность интерактивной работы и скриптования, с большой базой готовых кроссплатформенных библиотек .Net/JVM и возможностью использовать в связке с другими языками (на самом деле, это не особо удобно именно в плане смешивания языков, чисто совместимость на уровне байткода и интерфейсы к классам), главный минус - раздутость виртуальных машин, для небольших pet-проектов тащить таких монстров грустно. У функциональных языков иногда слишком “математический” синтаксис, к которому нужно привыкнуть.</li></ul><p>Кроме C++/Python могут быть полезны, на мой взгляд:<br><code>C#</code> - быстро накидать формочки гуи и начать писать логику.<br><code>JavaScript</code> - расковырять что-нибудь в браузере, минимальный код в веб-страничке. Парсинг интернета<br>Что-нибудь из функциональных языков - просто практиковаться в изучении систем типов.</p><h2 id="Культура-разработки"><a href="#Культура-разработки" class="headerlink" title="Культура разработки"></a>Культура разработки</h2><p><code>Пускай код остаётся простым!</code><br><a href="https://www.youtube.com/watch?v=eWbPLSJZ5Zw" target="_blank" rel="noopener">Simple Made Easy</a> - доклад Рича Хикки о том, как сохранять простоту.<br>Основное занятие программистов – это борьба с возникающей сложностью, а в простом неспутанном коде сложности будет меньше. Вязанный замок переделать будет сложнее, чем замок, собранный из кубиков лего.<br><img src="/blog/3652741154/castles.png" alt="castles"></p><p><a href="/blog/503948690/" title="2016 - Строители и ломатели">2016 - Строители и ломатели</a> - моя заметка про строителей и ломателей замков.</p><p>Часто в ООП ищут способ дизайна программ, однако (как из названия понятно), его там нет. Так что, подходы к дизайну можно и нужно изучать отдельно.<br><a href="https://dataorienteddesign.com/dodbook/" target="_blank" rel="noopener">Data-Oriented Design</a> - книга Richard Fabian.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Когда-то давно, когда я учился в университете на втором курсе, мой одногруппник скинул мне ссылку на раздел местного форума о поиске работы. &lt;a href=&quot;https://www.gaijinent.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“Гайдзины”&lt;/a&gt; искали программистов в офис в Севастополе.&lt;br&gt;Я уже тогда решил для себя, что хочу делать игры, но не особо хотел бросать учёбу. Сходил на собеседование, после которого мне сказали, что подумают.&lt;/p&gt;
&lt;p&gt;Подумали они около месяца, после чего в январе 2008 года пригласили в офис, чтобы начинать работать. Я отнёсся к этому как к стажировке (в универе всё равно были каникулы между семестрами), и согласился.&lt;br&gt;После каникул решил остаться там работать на полставки (работа, конечно, мешала учёбе, но зато можно было делать игры, и получать за это деньги).&lt;/p&gt;
&lt;p&gt;В универе я успел покататься по олимпиадам по программированию, и заработать хорошую репутацию, так что на мои пропуски закрывали глаза, поэтому удавалось балансировать между работой и учёбой ещё 4 года (с учебными отпусками, временным самоувольнением поучиться семестр, и просто с забитием на универ к концу). Посчитал, что с учётом отпусков и перерывов, я профессионально занимаюсь разработкой игр уже около 10 лет.&lt;/p&gt;
&lt;p&gt;У меня нет какой-то особенной мудрости, накопленной за эти годы, и поучающих советов другим (даже несмотря на то, что некоторые разделы поста выглядят как советы). Эти заметки написаны просто для себя.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
      <category term="dev" scheme="http://spiiin.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>Итоги 2020</title>
    <link href="http://spiiin.github.io/blog/307513906/"/>
    <id>http://spiiin.github.io/blog/307513906/</id>
    <published>2021-01-17T14:36:47.000Z</published>
    <updated>2021-01-18T00:20:42.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Никогда не подводил итогов года, но почему бы не начать в этом.</p><a id="more"></a><p><strong><code>Дисклеймер</code></strong><br>Я, как и все остальные люди, склонен обращать больше внимания на успехи в своей жизни, чем на пиздецы и фейлы, поэтому перед позитивными итогами этого года, сначала немного негативные итоги предыдущих, но сжато.</p><p>Прошлый год стал для меня переломным в том плане, что прекратил попытки решить все накопленные проблемы одновременно. А накопились они по причине того, что загнал себя в замкнутый круг попыткой решать их не по одной, а все сразу - наладить личную жизнь, заняться обустройством дома и поменять работу одновременно.</p><p>Вместо полноценной работы выбрал несколько часов фриланса в день, чтобы хватало времени на ремонт старого дома, однако в таком режиме не хватало денег на отдых. Для того, чтобы найти нормальные отношения не хватало времени из-за ремонта и фриланса, а на полноценную работу не хватало времени из-за отношений и ремонта. Сейчас я понимаю, что стоило просто посоветоваться с кем-то, кто был опытнее и умнее, или просто мог посмотреть на мои проблемы со стороны (такие люди были, просто я их не замечал или не слушал). Но спасибо и тем, кто просто был рядом, без всяких советов.</p><p>В итоге, после того, как слёг на несколько недель с температурой, пришлось начинать с нуля ещё раз, на этот раз с упором на работу. Мир устроен так, что с помощью денег остальное тоже становится проще, главное не забывать, что это лишь средство, а не цель. Ну и то, что это средство решать не только ваши персональные проблемы, но ещё и тех, кому вы хотите помочь.</p><p>Попутно, к сожалению или к счастью, прекратил общение со многими старыми знакомыми – до сих пор плохо умею разрывать контакты. Кто-то перестал общаться со мной, часто обоснованно. Пришлось усвоить несколько неприятных уроков общения, и то, что люди могут быть опаснее для окружающих, чем показывают, и даже, чем думают сами. Самый опасный хищник – тот, кто считает себя праведником.</p><p>Тем не менее, я всё ещё уверен, что большинство людей в мире по-умолчанию стремятся к построению любых отношений с другими по принципу win-win, и это прекрасно.</p><p>Йоханга.</p><p><strong><code>Путешествия</code></strong><br>В конце прошлого года, перед рождеством, побывал в Сингапуре, в небольшой командировке. Яркий футуристический неоновый город с небоскрёбами, казино и красивейшими Botanic Gargdens.</p><p><img src="/blog/307513906/singapur_small.jpg" alt="foxy"></p><p>В этом съездил в Крым зимой и летом – увидеться с родственниками, и погулять с палатками по разным уголкам и устроить гастротур по местным малоизвестным ресторанчикам. Бахчисарай-Севастополь-Инжир-Айа-Коктебель. Хотелось ещё заскочить в западный Крым, но немного не хватило времени.</p><p><img src="/blog/307513906/ingir_small.jpg" alt="ingir"></p><p><strong><code>Работа</code></strong></p><p>За пару месяцев перед началом локдауна я стал лидом проекта, который скоро нужно было запускать на софт. Поэтому после закрытия офисов (учитывая, что работа вне офиса до этого не практиковалась), баланс между кодингом и решением всевозможных организационных вопросов сместился где-то на 15%/85%, что было очень сильно непривычно в начале. Софт, естественно, немного задержался, но явно меньше, чем мог бы. Хотя в итоге после выхода игры, ещё где-то неделю до отпуска было ощущение не то, что выгорания, а сгорания.</p><p>Сама игра – <a href="https://mytona.com/game/6" target="_blank" rel="noopener">Crooked Pines</a></p><p><img src="/blog/307513906/cp_small.jpg" alt="cp"></p><p>Одно из самых ярких впечатлений года - в апреле собрались попрощаться втроём в Парке 300-летия с ребятами, с которыми за время работы в офисе установилась какая-то безумная творческая атмосфера, когда понимаешь, что получаешь настоящий кайф от работы, восхищаешься тем, что делают другие и делаешь сам. Грустно понимать, что вчера было так, а через несколько дней разлетаемся на 6000 километров.</p><p><img src="/blog/307513906/park_small.jpg" alt="park"></p><p>Ещё разок удалось вспомнить, что такое тимбилдинг и командный дух во время одного из релизов апдейтов - когда к 4-5 утра исправляются последние ошибки, и нервные шутки от команды QA перед последней (или непоследней, как повезёт) проверкой игры. Это выматывает физически и психологически, зато объединяет, формирует ядро команды, и проявляет волевые качества людей. Все остальные формы корпоративного “тимбилдинга” - это просто пьянки на деньги компании (что, конечно, тоже здорово).</p><p>Дальше - обустройство домашнего рабочего места и попытки найти себя в новой реальности пандемии.</p><p><img src="/blog/307513906/home_small.jpg" alt="home"></p><p><strong><code>Личное</code></strong></p><p>Работая в it-компании, программисты (особо после релокейта) не особо заморачиваются с обустройством жилища, так как всё равно местом обитания является офис со всеми возможными плюшками, а дом является место ночлежки. Поэтому если приходится проводить дома почти всё время, вынужденно приходится привести рабочее место в порядок (отдельная приятная опция работы в хорошей компании - возмещение расходов на все минимально необходимые вещи).</p><p>Надежды, что пандемия закончится быстро, я не питал, поэтому просто принялся перестраивать быт с расчётом на то, что придётся отсиживаться долго. Т.е. просто изучил всё что, было рядом с домом. Я живу в Питере на Пискарёвке - кругом обнаружилось множество парков, старое Богословское кладбище и железнодорожная станция с электричками, на которых можно было начать изучать Ленобласть и окрестности. Особенно запомнились поездки на Хепоярви - там можно бродить пешком, кататься на великах, жарить шашлыки и заниматься активным отдыхом.</p><p><img src="/blog/307513906/hepoyarvi_small.jpg" alt="hepoyarvi"></p><p>Чтобы минимизировать риск заразиться, но не сойти с ума в изоляции, пытался общаться с небольшой замкнутой компанией друзей и коллег, также поддерживающих подобную стратегию изоляции.</p><p>Случайно встретил свою вторую половинку.<br>Просто наплевали на все правила, пили пиво на закрытой на карантин детской площадке (какая разница, если вокруг пост-апокалипсис?), гуляли по всё тому же Парку 300-летия ночью, смотрели на рассвет с какой-то крыши, и поняли, что нашли друг друга.</p><p><img src="/blog/307513906/foxy_small.jpg" alt="foxy"></p><p><strong><code>Музыка</code></strong><br>Мой гимн этой весны, в связи с коронавирусом, однозначно - <code>AnnenMayKantereit &amp; K.I.Z. - Hurra die Welt geht unter</code><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/0nouhZQqtx4" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Также моим личным открытием стал электро-свинг - музыка и танцы. Мечтаю разучить несколько движений и научиться совмещаться их с жонглёрскими движениями.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/S_874GjbUII" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p>Ну, и знатный стёб от Гудкова - <code>Cream Soda - Никаких больше вечеринок</code>. В одном из клипов нашёл прикольное место, которое хочется посетить в 2021 году – <a href="https://www.google.com/search?q=%D0%BA%D0%BE%D0%BD%D0%B4%D1%83%D0%BA%D0%B8&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=2ahUKEwiknfXktKPuAhUomYsKHfKoCUwQ_AUoAXoECBMQAw&amp;biw=1920&amp;bih=947" target="_blank" rel="noopener">Кондуки</a><br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/M95iEQx20Ag" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><strong><code>Приобретения</code></strong></p><p>Ещё вначале года я был уверен, что никогда не решусь завести собаку в квартире, и вообще, с собаками так грустно прощаться, что хочется завести её лет за 15-20 до собственной смерти, не раньше. Но к середине года я решил, что мне нужен друг и товарищ, с которым можно бродить по паркам и дрессировать его. Всё детство я жил в частном доме, в котором были дворняги, но при заведения собственного собакена решил попробовать породистого.</p><p>С трудом удержался от охотничьего по натуре джека-рассела, переключившись на генетических пастухов – корги. После поездки за город в питомник, у меня дома появился двухмесячный разноглазый кардиган-мерль Халк (потому что цветом как камень <code>Халцедон</code>).</p><p><img src="/blog/307513906/corgi_small.jpg" alt="corgi"></p><p>Чтобы играть в свободное время, купил себе <code>Nintendo Switch</code>, играл в основном в хиты от самой нинтендо, ну и ещё в пару игр. Больше всего зашли:</p><p><code>- Witcher 3</code><br>Люблю всю серию, во всех проявлениях, особенно приятно попробовать ещё раз на мобильной платформе в дороге.<br><code>- Legend of Zelda: Breath of the Wild</code><br>Интересная песочница, сильно погружает в простой сказочный мир<br><code>- Spiritfarer</code><br>Ферма с несколькими историями про прощание перед смертью, трогательная и в начале, но с запоротой концовкой.</p><p><strong><code>Развитие</code></strong></p><p>Этот год в основном прошёл в работе (причём, в работе с головой), больше в прокачке софт-скиллов.</p><p>Тем не менее, немного занимался более внимательным изучением новых стандартов C++ (11-17), минималистичного подхода в дизайне библиотек для C/C++ (<code>fmt</code>, <code>sokol</code>, <code>imgui</code>, <code>bgfx</code>, etc), а также паттерна <code>ECS</code>.</p><p>Раньше для любого пет-проджекта хотелось взять что-нибудь отличное от C++, из-за очарования battery-included философии Python и C# - проще было взять готовый монструозный пакет со всем сразу, и быстрее начинать писать код. Сейчас стало интереснее научиться решать задачу минимально необходимыми средствами, без виртуальных машин ради простого скрипта. Одно из неочевидных отличий в подходах заключается в том, что в первом случае для решения берётся первый попавшийся инструмент, с помощью которого точно знаешь, что сможешь решить задачу, а во-втором – пытаешься выбрать самый лучший подходящий для задачи инструмент среди всех доступных.</p><p>Также к концу года, за время отпуска, нашёл таки время практически закончить экспорт <code>блога</code> из <a href="https://spiiin.livejournal.com/" target="_blank" rel="noopener">ЖЖ</a> на <a href="https://spiiin.github.io/">гитхаб</a>. Долго выбирал <a href="/blog/47121/" title="статический генератор">статический генератор</a>, тему к нему, и изучал языки разметки и описания стилей. Быстро нашёл и пофиксил <a href="https://github.com/spiiin/stuff/tree/master/export_lj" target="_blank" rel="noopener">скрипт экспорта постов из жж</a> в формат markdown. Затем долго чистил совсем бессмысленные посты и экспортировал оставшиеся (часто, с ручными фиксами разметки). В конце думал, оставлять ли что-то в жж, или нет, и решал, что чем меньше там останется контента (как полезного, так и личного), тем лучше.</p><p><img src="/blog/307513906/fox.png" alt="fox"></p><p>За год повзрослел эмоционально, нашёл себя, и снова стал счастливым</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Никогда не подводил итогов года, но почему бы не начать в этом.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="log" scheme="http://spiiin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Райан Гордон</title>
    <link href="http://spiiin.github.io/blog/413676133/"/>
    <id>http://spiiin.github.io/blog/413676133/</id>
    <published>2021-01-13T21:09:08.000Z</published>
    <updated>2021-01-17T14:37:13.697Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/MeMPCSqQ-34" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p><a href="https://en.wikipedia.org/wiki/Ryan_C._Gordon" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ryan_C._Gordon</a></p><p>Хакер, инди-разработчик, фрилансер.</p><p>Портирует “стафф” на линукс и макось. Среди “стаффа” - игры из серий:</p><ul><li>Unreal Tournament</li><li>Serious Sam</li><li>Civilization</li><li>Spider-Man</li><li>Quake</li><li>Left 4 Dead<br>и многие другие, а также приложения Second Life и Google Earth.<br>Проще перечислить, что он не портировал.</li></ul><p><a href="http://icculus.org/" target="_blank" rel="noopener">http://icculus.org/</a> - его сайт с open-source версиями нескольких из старых крупных проектов.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;style&gt;.embed
      
    
    </summary>
    
    
    
      <category term="люди" scheme="http://spiiin.github.io/tags/%D0%BB%D1%8E%D0%B4%D0%B8/"/>
    
  </entry>
  
  <entry>
    <title>ECS для казуальных игр</title>
    <link href="http://spiiin.github.io/blog/1488389622/"/>
    <id>http://spiiin.github.io/blog/1488389622/</id>
    <published>2021-01-07T20:11:49.000Z</published>
    <updated>2021-01-08T16:14:15.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Чем может быть полезно применение паттерна <strong><code>Entity Component System</code></strong> в казуальных играх.</p><p>TL,DR:</p><ul><li>Уменьшается связность между классами</li><li>DOD упрощает управление параметрами из нескольких мест</li><li>Упрощается написание читов</li><li>Возможно, игра будет работать быстрее</li></ul><a id="more"></a><h2 id="Уменьшается-связность-между-классами"><a href="#Уменьшается-связность-между-классами" class="headerlink" title="Уменьшается связность между классами"></a>Уменьшается связность между классами</h2><p>Это первое и самое важное, одного этого пункта хватило бы.</p><p>Геймдев не особо богат на архитектурные паттерны. Часто, высший уровень абстракции игровой логики (описание сцены и геймплея) - это классы <strong><code>&quot;поле&quot;</code></strong> (<em>уровень/сцена/зона/whatever</em>), и наследники <strong><code>&quot;игровых объектов&quot;</code></strong>. Часто встречаются ещё какие-нибудь <strong><code>&quot;фабрики эффектов&quot;</code></strong>, содержащиеся методы для запуска всего, чего только можно.</p><p>Первая освещаемая в <a href="/blog/381238762/" title="презентациях по ECS">презентациях по ECS</a>  проблема - это то, что игровых объектов очень много, разных типов, со взаимно-пересекающейся функциональностью.</p><p>К примеру, в <code>RTS</code> это могут быть юниты, герои, здания, ландшафт, снаряды. В <code>match-3</code> - множество отдельных типов клеток, фишек, существующих вне игровых клеток и между клетками механик, бустеры и бонусные фишки. В простом <code>скролл-шутере</code> – игрок, враги, стены и снаряды. В <a href="https://www.gamedevs.org/uploads/data-driven-game-object-system.pdf" target="_blank" rel="noopener">докладе о разработке Dungeon Siege</a> упоминается о &gt;7300 уникальных типов объектов. </p><p>Выстроить такое количество объектов в иерархию наследования практически невозможно, выделить несколько простых базовых классов, от которых наследуются все объекты – тоже. Возможное решение проблемы – выделять не базовые классы, а компоненты, из которых как из кирпичиков будут составлены объекты.</p><p>При таком подходе, судя по различным докладам, в зависимости от игры, может получиться 50-150 компонентов, которыми возможно описать все типы игровых объектов.</p><hr><p>Вторая проблема, более серьёзная с точки зрения архитектуры игры - <strong>куда писать код логики игры?</strong>.<br>Паттерн ECS обещает, что ответ будет чуть более простым, чем при использовании ООП - в системы, отвечающие за необходимый функционал.</p><p>Несколько примеров из одной match-3 игры, в которой используются компоненты для описания игровых фишек, но нет систем.</p><p>Реалзиция механика спецфишки “самолёт” (типа <a href="https://youtu.be/PqF3uKDgLsA?t=412" target="_blank" rel="noopener">такого</a>) в ней выглядит как показано ниже.</p><p>Самолёт запускается методом:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createAirplaneExplosion</span><span class="params">(airplaneBlock* plane, match3cell* parentCell, <span class="keyword">const</span> explosionSpineSettings&amp; settings)</span></span>;</span><br></pre></td></tr></table></figure></p><p>Сам самолёт состоит из компонентов:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">airplaneBlock</span> :</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithVisualFeedback, <span class="comment">//имеет анимацию</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithCombination,    <span class="comment">//может участвовать в комбинациях</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceDestructive,        <span class="comment">//может быть разрушен</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithObjective,      <span class="comment">//может быть целью уровня</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> customPieceWithDynamicLayer    <span class="comment">//может динамически менять слой</span></span><br><span class="line">    ...                                           <span class="comment">//и т.д.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//но так же имеет и методы, которые кто-то должен вызывать :(</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playDestroyAnimation</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Event*)&gt; callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHighestLayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restoreLayer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Соответственно, без использования ECS встаёт вопрос о том, куда дописывать код и где искать проблемы, когда они появляются.</p><p>Один из случаев в этом проекте:</p><p><strong>Иногда самолёты запускаются при старте игры</strong><br>В качестве бонуса игроку на старте. При этом другие бонусы от различных событий или покупок игрока расставляются по полю динамически. Программисту приходит баг от QA, что иногда поле от этого нестабильно (самолеты бьют в те клетки, куда не должны - логика самолётов подразумевает, что они умеют кружить по полю до того момента, пока одна из клеток не станет стабильной, т.е. в ней до момента удара гарантировано не будет происходить других событий). </p><p>Механика игры подразумевает, что можно заблокировать клетку от удара самолёта через метод <code>match3cell-&gt;lock</code>, но куда вставить его вызов?</p><ul><li>в коде <code>createAirplaneExplosion</code>?</li><li>в коде самого <code>airplaneBlock</code>? (тогда он будет знать о существовании всего поля и клеток на нём)</li><li>в коде событий, добавляющих на поле бустеры?</li><li>добавить компонент особой блокировки в класс клетку match3cell?</li><li>Программист, которому прилетел баг, пошёл ещё дальше, и добавил блокировку в код туториала на старте уровня %).</li></ul><p>В подходе с ECS, код, по идее, должен был бы выглядеть понятнее:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSystems</span><span class="params">(<span class="keyword">float</span> dt)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">createPreboosterAirplaneSystem(dt);  <span class="comment">//выставить компонент блокировки клеток поля на старте полёта самолётов</span></span><br><span class="line">createOtherPreboostersSystem(dt);  <span class="comment">//обновить логику всех бонусов игрока, отработки которых нужно дождаться</span></span><br><span class="line">normalGamePlayLogic(dt);         <span class="comment">//обычная геймплейная логика, </span></span><br><span class="line">         <span class="comment">//включает в себя обновление самолётов:</span></span><br><span class="line">         <span class="comment">//"если нет блокировки, ударить по клетке, иначе  - продолжать летать над полем"</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Т.е. на вопрос <strong><code>&quot;куда дописать логику блокировки клеток от удара самолётами-пребустерами&quot;</code></strong> следует очевидный ответ <strong><code>&quot;в систему создания блокировки от удара самолётами-пребустерами&quot;</code></strong>, вместо распутывания ада взаимных вызовов и колбеков между полем, клеткой, самолётом, суперклассом запуска всех событий или ещё какими-нибудь объектами, и медитации на тему, какой из объектов более отвечает за это.</p><p>Поиск по коду суперкласса запуска всех событий даёт 25 мест, в которых клетка может быть заблокирована или разблокирована обратно %). Гораздо лучше было бы иметь 4-5 систем, которые выбирают все сущности с компонентами блокировки и удаляют эти компоненты или создают их.</p><hr><p>Одна из фишек архитектуры ECS - возможность отследить связи между системами и компонентами - <a href="https://youtu.be/W3aieHjyNvw?t=324" target="_blank" rel="noopener">пример в докладе Тимоти Форда по Overwatch</a>. Я попробовал перевести на ECS (с использованием библиотеки EnTT) готовую игру - сделанный за день для хакатона <a href="https://apps.apple.com/ru/app/comatosis/id1537791573#?platform=ipad" target="_blank" rel="noopener">небольшой shoot-them-up</a> на закрытом движке, использующем Component Systems. Заменил часть, отвечающую за апдейт на системы, и оставил без изменений систему рендера (она использует Scene Graph).</p><p>На мой взгляд, небольшие игры с хакатонов хорошо подходят для подобных тестов - бардак в коде, вызванный нехваткой времени сделать “как правильно”, реалистично симулирует состояние кода игры после длительного периода разработки, а небольшой объём кода позволяет довести задуманное до конца.</p><p>Для визуализации связей сделал такой скрипт на питоне:<br><a href="https://gist.github.com/spiiin/c70c3bf0711fd952d48e505ead7bffe5" target="_blank" rel="noopener">https://gist.github.com/spiiin/c70c3bf0711fd952d48e505ead7bffe5</a><br><img src="/blog/1488389622/diagram1.png" alt="ecs-doc"></p><p>Кашу из зависимостей между игровыми классами удалось превратить в 24 системы и 30 компонентов. При этом большинство систем использует 2-4 компонента, большинство компонентов используется 1-2-3 системами. Большая часть систем может быть без особых усилий переделана на <code>реактивные</code> (чтобы вызывать их не каждый кадр, а по колбекам на изменение каких-либо компонент на любой из сущностей) или на <code>владеющие компонентами</code> (для оптимизации по скорости обходов, <a href="https://skypjack.github.io/2019-04-12-entt-tips-and-tricks-part-1/" target="_blank" rel="noopener">статья с объяснением</a>).</p><p>Компоненты по способы использования разделяются на <code>логические</code> (для композиции из них сущностей - в основном, игровых объектов), <code>события</code> (для передачи информации между системами и выделения сущностей, с которыми произошло действие), <code>синглтоны</code> (существующие в единственном экземпляре для всего пула сущностей), и <code>прокси-компоненты</code> (для передачи данных в подсистемы движка/игры, написанные без ecs, и получения данных из этих подсистем).</p><h2 id="DOD-упрощает-управление-параметрами-из-нескольких-мест"><a href="#DOD-упрощает-управление-параметрами-из-нескольких-мест" class="headerlink" title="DOD упрощает управление параметрами из нескольких мест"></a>DOD упрощает управление параметрами из нескольких мест</h2><p>Простейший пример -<strong> <code>возможность удаления игрового объекта из нескольких разных мест</code></strong>.<br>Игровой снаряд может быть уничтожен через 5 секунд по окончании времени жизни, либо при столкновениях во стеной или врагом, то удаление в ООП парадигме может выглядеть так:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bullet = createBullet();</span><br><span class="line"><span class="keyword">auto</span> waitAction = createWaitAction(<span class="number">5.0f</span>); <span class="comment">//создаём объект действия ожидания</span></span><br><span class="line"><span class="comment">//в конце действия уничтожаем объект</span></span><br><span class="line">waitAction.onEnd = [bullet]() &#123;</span><br><span class="line">    <span class="comment">//тут не забыть проверить, что за 5 секунд объект может быть уничтожен кем-либо ещё</span></span><br><span class="line">    bullet-&gt;destroySelf();</span><br><span class="line">&#125;;</span><br><span class="line">bullet-&gt;addAction(waitAction); <span class="comment">//добавляем действие на объект пули</span></span><br></pre></td></tr></table></figure><p>Как проверить, что пуля не была уничтожена?<br>Один из способ из стандартной библиотеки с++ – использование слабого указателя на объект. Такие проверки необходимо добавлять в каждое асинхронное действие.</p><p>Другой подход - перепроверять, жив ли объект в текущий момент, через глобальный менеджер объектов. Более детально про организацию этого в игровых движках - <a href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html" target="_blank" rel="noopener">статья Andre Weissflog</a>. В этом случае хендлер объекта часто представлен в виде пары <strong><code>(индекс объекта в массиве, номер поколения)</code></strong>. Использование номера поколения позволяет избежать случайного обращения к уже удалённому объекту при размещении на месте удалённого объекта следующего созданного.</p><p>Если решать проблему с использованием ECS-подхода, решение может быть таким: система обновления жизни пули (и других объектов с компонентом <code>lifetimeComponent</code>) читает компонент таймера жизни и уменьшают его. В случае если таймер дошёл до нуля - система просто добавляет на сущность компонент-событие <code>removeNodeComponent</code> - маркер, что в конце кадра сущность должна быть уничтожена.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLifetimeSystem</span><span class="params">(<span class="keyword">float</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//read components </span></span><br><span class="line">    <span class="comment">// &lt;------------------------------------------------(0)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lifetimeView = ECS().view&lt;nodeComponent, lifetimeComponent&gt;(entt::exclude&lt;removeNodeComponent&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//logic</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [entity, nodeComponent, lifetimeComp] : lifetimeView.each()) &#123;</span><br><span class="line">        lifetimeComp.lifetime -= delta;</span><br><span class="line">        <span class="keyword">if</span> (lifetimeComp.lifetime &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> action = MEActionFactory::changeAlphaAction(<span class="number">0.0f</span>, lifetimeComp.fadeinTime);</span><br><span class="line">            action-&gt;onEnd = [entity=entity](MENode* node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ECS().valid(entity)) &#123;  <span class="comment">//&lt;-------  (1)</span></span><br><span class="line">                    ECS().emplace_or_replace&lt;removeNodeComponent&gt;(entity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (!nodeComponent.dead) &#123;      <span class="comment">//&lt;-------- (2)</span></span><br><span class="line">                nodeComponent.node-&gt;addAction(action);</span><br><span class="line">                ECS().<span class="built_in">remove</span>&lt;lifetimeComponent&gt;(entity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(0) - выборка всех сущностей, у которых есть компоненты <code>nodeComponent</code> (визуальное отображение), <code>lifetimeComponent</code> (время жизни), но нет компонента <code>removeNodeComponent</code> (умирает)<br>(1) - так как используется отложенное действие - нужно проверить, что сущность ещё жива и не была уничтожена (проверка через менеджер) - <code>ECS().valid</code><br>(2) - компонент для хранения не владеющего указателя, имеет кроме указателя флаг <code>nodeComponent.dead</code> , показывающий не был ли уничтожен объект, вместо использования weak_ptr/intrusive_ptr. Вместо флага может быть использован счётчик, если нужно shared-владение.</p><hr><p>Другой пример - есть стратегия с игровым полем с персонажами на нём, и по желаниям гейм-дизайнеров, персонажи на этом поле должны плавно исчезать при открытии окна режима редактирования зданий или появления немодального игрового окна (и соответственно, плавно появляться обратно при закрытии этих режимов). Появление персонажей не мгновенно, и игроки могут успеть за это время запустить исчезновение обратно. <strong><code>Как добиться того, чтобы появление/исчезновение персонажей работало корректно в этом случае?</code></strong></p><p>В <code>ООП-подходе</code> каждое из действие появления напрямую должно попытаться влезть в другие действия, навешенные на персонажа, и узнать, нет ли на нём действий исчезновения и как-то обработать ситуацию, если персонажи одновременно появляются и исчезают.</p><p>С <code>ECS-подходом</code> - можно выделить два различных компонента исчезновения и появления персонажа, и различные системы для работы с ними. Одной из идиом работы совместной работы таких систем является непосредственное применение сайд-эффектов в одном месте (сайд-эффект в этом случае - это непосредственное изменение альфа-компонента цвета для рендер-системы). <a href="https://youtu.be/W3aieHjyNvw?t=1062" target="_blank" rel="noopener">Объяснение причин в докладе по Overwatch</a> - если системы A, B, C как-либо меняют логическое состояние компонента, то лучше собрать их действие в отдельном компоненте для системы D, которые непосредственно применит все собранные изменения в одном месте.</p><p>Так формула рассчёта альфа компонента персонажа будет находиться в одном месте и её можно будет изменить по желанию гейм-дизайнеров. Например, можно будет настроить поведение в таком случае одновременного появления и исчезновения персонажа - выстроить ли эти действия в цепочку, мгновенно завершить действие, которое было начато раньше, или же настроить таймеры действия так, чтобы они доигрались быстрее.</p><h2 id="Упрощается-написание-читов"><a href="#Упрощается-написание-читов" class="headerlink" title="Упрощается написание читов"></a>Упрощается написание читов</h2><p>Не секрет, что при разработке игр редко заморачиваются с покрытием кода тестами, поэтому часто читы - это средство создания сложных сценариев проверки игры, так что они становятся настолько важными, насколько важно вообще провести QA-проверку игры.</p><p>ECS подход должен помочь:</p><p><strong><code>- Легко включать и отключать каждую отдельную систему через читы</code></strong><br>Лучше даже, группу систем, отвечающую за определённую логику.</p><p>Отключение системы может само по себе быть удобным готовым читом, который при ООП подходе необходимо создавать дополнительно к основной логике (отключение системы получения урона, отключение системы коллизий, отключение ИИ).</p><p>При проектировании объектов редко задумываются о том, чтобы частично отключать функционал класса. С системами, вызов которых сгруппирован в одном месте, это может быть сильно проще.</p><p><strong><code>- Проще сделать загрузку/сохранение сцены, проигрывание повторов</code></strong><br>Сохранение - это просто сериализация всех сущностей со всеми компонентами. Если после этого запустить все системы - логика игры должна начать работать также, как если бы состояние сущностей/компонент было получено любым другим образом.</p><p><strong><code>- Проще составить сценарии тестирования</code></strong><br>Включение/отключение систем может быть сериализовано или включено в запись повтора, результаты работы после нескольких циклов могут быть сериализованы и сверены с эталонным результатом.</p><h2 id="Возможно-игра-будет-работать-быстрее"><a href="#Возможно-игра-будет-работать-быстрее" class="headerlink" title="Возможно, игра будет работать быстрее"></a>Возможно, игра будет работать быстрее</h2><p>(не проверял, пересказ чужих докладов)</p><p><strong><code>- Проще запустить системы, несвязанные с другими, в отдельном потоке</code></strong><br>Если отслеживать граф зависимостей компонентов, с которыми работают системы, то можно найти системы, которые могут работать параллельно с другими. С обычным ООП подходом сложно перенести часть логики в отдельный поток.</p><p><strong><code>- Прирост скорости за счёт более быстрого обхода и чтения из кеша</code></strong><br>Компоненты хранятся в памяти отдельными массивами, однако можно добиться того, чтобы ECS хранила контейнер для каждой группы сущностей с определённой группой компонент в памяти последовательно.</p><p>Для ECS на архетипах это делается по умолчанию (при создании или удалении компонента для сущности, они будет перенесена в другой контейнер).</p><p>Для ECS на разреженных множествах также существуют способы организовать хранение сущностей с одинаковыми компонентами в памяти последовательно. Для EnTT - это группы (<code>group</code>) - <a href="https://github.com/abeimler/ecs_benchmark" target="_blank" rel="noopener">синтетические бенчмарки</a> показывают, что это наиболее быстрый способ работы.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Чем может быть полезно применение паттерна &lt;strong&gt;&lt;code&gt;Entity Component System&lt;/code&gt;&lt;/strong&gt; в казуальных играх.&lt;/p&gt;
&lt;p&gt;TL,DR:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Уменьшается связность между классами&lt;/li&gt;
&lt;li&gt;DOD упрощает управление параметрами из нескольких мест&lt;/li&gt;
&lt;li&gt;Упрощается написание читов&lt;/li&gt;
&lt;li&gt;Возможно, игра будет работать быстрее&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
  </entry>
  
  <entry>
    <title>ECS. Ссылки</title>
    <link href="http://spiiin.github.io/blog/381238762/"/>
    <id>http://spiiin.github.io/blog/381238762/</id>
    <published>2021-01-04T22:09:45.000Z</published>
    <updated>2021-02-24T21:45:54.772Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>ECS - паттерн программирования, используемый в геймдеве. Основная идея - есть пул сущностей (<code>entities</code>), на которые можно добавлять компоненты (данные без логики - <code>components</code>). Сущности и компоненты читаются, модифицируются, создаются и удаляются только с помощью систем(<code>systems</code>). Подход немного отличен от традционного ООП, и от ECs (сущности разбиваются на  компоненты - логика хранится как в классах-сущностях, так и в компонентах), так что требует ознакомления и практики перед использованием<br><a id="more"></a></p><h2 id="История-и-примеры-практического-применения-в-больших-играх"><a href="#История-и-примеры-практического-применения-в-больших-играх" class="headerlink" title="История и примеры практического применения в больших играх"></a>История и примеры практического применения в больших играх</h2><p><code>Dungeon Siege</code> - <a href="https://www.gamedevs.org/uploads/data-driven-game-object-system.pdf" target="_blank" rel="noopener">A Data-Driven Game Object System</a><br><code>Operation Flashpoint 2</code><br><code>GrexEngine</code> (движок для mmo-rpg) - <a href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/" target="_blank" rel="noopener">Cерия статей</a>, и ссылка ещё на одну презу из dungeon siege<br><code>World of Tanks Blitz</code> - <a href="https://habr.com/ru/company/wargaming/blog/245321/" target="_blank" rel="noopener">Создание World of Tanks Blitz на базе собственного движка DAVA</a><br><code>Wooga</code> (немецкая студия, разрабатывает казуалки) - для матч-3 и стратегии. Ссылки на видео в следующем разделе.<br><code>Overwatch</code> - Ссылка на видео в следующем разделе (в комментариях к ютуб лекции ещё несколько разработчиков игр отписывались, например <code>Mercenaries 2</code>)<br><code>Minecraft</code> - Использует библиотеку <a href="https://minecraft.net/en-us/attribution/" target="_blank" rel="noopener">entt</a>.</p><h2 id="Видео-презентации"><a href="#Видео-презентации" class="headerlink" title="Видео презентации"></a>Видео презентации</h2><p><code>Entitas - Entity System Architecture with Unity - Unite Europe 2015.</code><br>Доклад от Макса Закса и Саймона Шмидта о библиотеке Entitas для Unity - идеи, и как совмещать объектами Unity.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/1wvMXur19M4" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Unite Europe 2016 - ECS architecture with Unity by example</code><br>От них же, практическое применение библиотеки Entitas для решения конкретной задачи, создания интерфейса в стиле Clash Royale.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/lNTaC-JWmdI" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Кирилл Надеждин (Kumo Kairo) - ECS в разработке игр — хорошая архитектура приложений для всех</code><br>Обзор entitas и ссылки на другие примеры использования ECS в играх, на русском. Примеры проблем, которые приводят к тому, чтобы перейти на ECS.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/pp5sYybOidg" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Wargaming.net: Архитектура современных 3D движков (DevGAMM Minsk 2014)</code><br>Архитектура современных 3D движков, Виталий Бородовский, Technical Director WoT Blitz<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/1zLqgQ_-F84" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>Overwatch Gameplay Architecture and Netcode</code><br>Разбирается внутренняя ECS близзрад. Cамая объёмная и сложная для понимания презентация, тут на 0.75 лучше смотреть. Почему пришли к применению ECS, с какими проблемами сталкивались и как их решали. Обзор после 3х лет использования такой архитектуры на практике.<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/W3aieHjyNvw" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><p><code>itCppCon19 - ECS back and forth (Michele Caini)</code><br>Обзор внутреннего устройства ECS на C++ - разбор двух типов архитектур - на основе “архетипов” и “разреженных множеств”. Можно также почитать в ECS-FAQ (ссылка в следующем разделе)<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/WB5bRKKGRUk" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><h2 id="Обзоры-библиотек"><a href="#Обзоры-библиотек" class="headerlink" title="Обзоры библиотек"></a>Обзоры библиотек</h2><p><a href="https://github.com/SanderMertens/ecs-faq" target="_blank" rel="noopener">Entity Component System FAQ</a> - общий обзор подхода, терминология, список библиотек, примеры применения в продакшене.<br><a href="https://github.com/abeimler/ecs_benchmark" target="_blank" rel="noopener">Entity-Component-Systems Benchmark</a> - бенчмарк различных библиотек<br><a href="https://github.com/skypjack/entt" target="_blank" rel="noopener">EnTT</a> - production-ready c++ библиотека, с примерами использования (самый простой - <a href="https://github.com/Kerndog73/EnTT-Pacman" target="_blank" rel="noopener">pacman</a>, <a href="https://github.com/skypjack/entt/wiki/EnTT-in-Action" target="_blank" rel="noopener">документацией</a> и <a href="https://skypjack.github.io/tags/#entt" target="_blank" rel="noopener">блогом</a><br><a href="https://github.com/SanderMertens/flecs" target="_blank" rel="noopener">flecs</a> - c/c++ библиотека с большим количеством <a href="https://github.com/SanderMertens/flecs/tree/master/examples" target="_blank" rel="noopener">примеров</a> и функционала (есть модули для сериализации, рефлексии, продвинутое api для обращения с сущностями). <a href="https://github.com/SanderMertens/flecs/blob/master/docs/Manual.md" target="_blank" rel="noopener">Мануал</a><br><a href="https://github.com/sschmid/Entitas-CSharp" target="_blank" rel="noopener">Entitas</a> - библиотека на C# для использования с Unity (порты на другие языки можно не смотреть. Возможно, стоит смотреть сразу штатный ECS для Unity - Unity DOTS.</p><h2 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h2><p><a href="https://gamedev.ru/code/forum/?id=198194&amp;m=3785006#m8" target="_blank" rel="noopener">Обсуждение на gamedev.ru</a> - пост с большой коллекцией ссылок<br><a href="http://entity-systems.wikidot.com/" target="_blank" rel="noopener">Entity Systems Wiki</a> - вики с терминологией, ссылками, список библиотек для разных языков.<br><a href="http://gamadu.com/artemis/" target="_blank" rel="noopener">Artemis</a> - академическая реализация ECS на Java, посмотреть как задумано.</p><h2 id="Data-oriented-Design-DoD"><a href="#Data-oriented-Design-DoD" class="headerlink" title="Data-oriented Design (DoD)"></a>Data-oriented Design (DoD)</h2><p>Теория, если сходу не очень понятны идеи ECS.<br><a href="https://www.dataorienteddesign.com/dodbook/" target="_blank" rel="noopener">Data-Oriented Design</a> - фундаментальная книжка по DoD от Richard Fabian<br><a href="https://github.com/dbartolini/data-oriented-design" target="_blank" rel="noopener">Data Oriented Design Resources</a> - список материалов по DOD<br><a href="https://habr.com/ru/post/472052/" target="_blank" rel="noopener">Data-Oriented Design (или почему, используя ООП, вы, возможно, стреляете себе в ногу)</a> - перевод статьи Noel Llopis<br><a href="https://asawicki.info/news_1422_data-oriented_design_-_links_and_thoughts.html" target="_blank" rel="noopener">Data-Oriented Design - Links and Thoughts</a> - коллекция ссылок на статьи, многие gamedev-related.<br><a href="https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/introduction-to-data-oriented-design.pdf" target="_blank" rel="noopener">DOD в Battlefield</a> - исследование прироста скорости от правильного расположения структур в памяти, полезные ссылки в конце доклада<br><a href="https://www.youtube.com/watch?v=yy8jQgmhbAU" target="_blank" rel="noopener">Stoyan Nikolov “OOP Is Dead, Long Live Data-oriented Design”</a> - видео доклада Стояна Николова с примером разницы подходов к решению практической задачи - OOP vs DoD.</p><p>Примеры проектов, используещие подход:<br><a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">Dear ImGui</a><br><a href="https://github.com/bkaradzic/bgfx" target="_blank" rel="noopener">bgfx</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECS - паттерн программирования, используемый в геймдеве. Основная идея - есть пул сущностей (&lt;code&gt;entities&lt;/code&gt;), на которые можно добавлять компоненты (данные без логики - &lt;code&gt;components&lt;/code&gt;). Сущности и компоненты читаются, модифицируются, создаются и удаляются только с помощью систем(&lt;code&gt;systems&lt;/code&gt;). Подход немного отличен от традционного ООП, и от ECs (сущности разбиваются на  компоненты - логика хранится как в классах-сущностях, так и в компонентах), так что требует ознакомления и практики перед использованием&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://spiiin.github.io/tags/c/"/>
    
      <category term="link" scheme="http://spiiin.github.io/tags/link/"/>
    
      <category term="c#" scheme="http://spiiin.github.io/tags/c/"/>
    
      <category term="gamedev" scheme="http://spiiin.github.io/tags/gamedev/"/>
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Уровень программирования: Middle</title>
    <link href="http://spiiin.github.io/blog/15798/"/>
    <id>http://spiiin.github.io/blog/15798/</id>
    <published>2020-08-12T08:58:00.000Z</published>
    <updated>2021-01-02T22:01:36.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Часто встречающиеся у программистов-новичков ошибки и часто встречающие у опытных программистов ошибки. С позиции “среднего” разработчика.<br><a id="more"></a></p><p>…</p><hr><h2 id="Ошибки-новичков"><a href="#Ошибки-новичков" class="headerlink" title="Ошибки новичков"></a>Ошибки новичков</h2><p><code>1. Использование примитивов вместо высокоуровневых абстракций</code></p><p>Новички часто пишут код “с нуля”, забывая о возможностях используемых фреймворков или библиотек. Фактически это просто неумение работать со сложными типами и игнорирование возможностей системы типов используемого языка (точнее даже - возможностей выражать через типы ограничения и связи сущностей).</p><blockquote><p>Каждый раз, когда необходимо завести переменную типа <code>int</code> - подумайте, действительно ли нужен просто целочисленный тип, или же с помощью типа можно сказать ещё что-то полезное о переменной</p></blockquote><p><code>2. Реализация всей логики в одной функции</code></p><p>Если какой-то кусок кода можно вынести в именованную функцию (даже если она не будет использоваться повторно), стоит так сделать. Функции проще объединять в классы или модули, чем “голый” код и разрастающиеся безымянные функции. Это нужно, чтобы уменьшить вероятность копи-пасты кода (точнее даже, уменьшения количества необходимых для изменения логики мест в коде).</p><blockquote><p>Можно ли описать одним небольшим предложением, что делает функция? Что делает класс? Что описано в файле/namespace/модуле?</p></blockquote><p><code>3. Игнорирование инкапсуляции</code></p><p>Инкапсуляция часто ошибочно трактуется новичками как необходимость делать все данные класса закрытыми. На практике лучше понимать и использовать её как средство сделать объект не ломаемым пользователем. Т.е. если изменение переменных не может привести к тому, что класс будет находиться в невалидном состоянии - то и не надо их прятать. Если же для корректной работы с объектом у него нужно вызвать 5 разных методов в строго определенном порядке (а в других случаях программа падает), значит, нет у него никакой инкапсуляции. Пользователь объекта не должен помнить о том, что нельзя делать с объектов, чтобы не сломать его внутреннюю логику - сам объект должен быть не ломаемым для пользователя.</p><blockquote><p>Таким образом в некоторых языках отказываются “ломающихся” абстракций и возможностей (<code>goto</code>, отказ от указателей, отказ от ручного освобождения памяти, отказ от мутабельности).</p></blockquote><p><code>4. Персональный стиль</code></p><p>По большей части, все программы пишутся несколькими людьми, так что вместо того, что писать в строго выработанном правильном стиле, стоит учиться подстраиваться под стиль уже написанного кода. Код на некоторых языках имеет стандартные правила написания, но даже с учётом этого необходимо помнить, что программа могла писаться, когда в ходу были другие правила, или же по каким-либо другим причинам использовать другой подход. Стоит писать так, чтобы стиль всей программы был одинаковый - так у читающего код будет меньше вопросов, почему в разных местах программы используются разные варианты (и какой стиль выбрать при изменении кода).</p><blockquote><p>Прежде чем писать код, прочитайте уже написанный</p></blockquote><p><code>5. Неправильные вопросы опытным программистам</code></p><p><em>“Какой язык учить?”</em> - неверно, опытные скорее могут рассказать, что уже учить не стоит. Новые знания можно копать самим, в больших количествах.<br><em>“Как быстро получить прибавку к зарплате”</em> - неверно. Самый быстрый способ прокачки - менять работу каждые полгода-год, с повышением рангов. Но с определенного уровня начинают ценить лояльность, прыгающий между проектами профессионал стоит только того, чтобы выжать из него максимум и отпустить дальше. В компаниях с грамотным управлениям вашу работу и так отметят (если отметка соответствует ожиданиям - всё отлично, если нет - лучше уточнять, что не так). К счастью, обычно с определённого уровня программистам достаточно денег для того, чтобы хватало на жизнь (дойти до этого уровня можно за год-два-три - как повезёт).</p><p>Стоит максимально вникать в предметную область, опасно зависать на несколько лет в очень узкой нише.</p><blockquote><p>Полезно раз в месяц-два изучать как минимум одну статью профессиональной тематики, раз в полгода-год читать книгу, раз в 2-3 месяца изучать библиотеки/фреймворки/движки, похожие на те, что используются в работе.</p></blockquote><h2 id="Ошибки-опытных"><a href="#Ошибки-опытных" class="headerlink" title="Ошибки опытных"></a>Ошибки опытных</h2><p><code>1. Нежелание трогать плохой код</code></p><p>“Это надо разбираться с половиной программы” - нормальная с точки зрения опытного программиста отмазка, чтобы не выполнять рефакторинг кода. В запущенных случаях это даже перерастает в нежелание трогать свой плохой код.</p><blockquote><p>Иногда таки надо разобраться с половиной программы, чтобы сделать код лучше. На костылях далеко не уёдешь, рано или поздно предстоит выбросить их и сделать нормальные колёса.</p></blockquote><p><code>2. Нежелание отказываться от своих подходов</code></p><p>Иногда (редко но бывает), нужно сделать свой код хуже, чтобы он вписывался в проект. Иногда нужно выучить новую парадигму - очень сильно неприятно, когда ты 15-20 лет писал код и решал проблемы в одном стиле, а теперь их в проекте решают по другому, так как ты ещё не умеешь. Иногда нужно выучить новый язык, когда уже очень хорошо знаешь старый.</p><p>Грустно, но во многих компаниях уровни роста программиста - это скорее стаж, чем реальный опыт, а с учётом того, что в IT практически никогда не понижают при переходе между компаниями, оказывается также, что умение писать хороший код приходит (если вообще приходит)  где-то на уровне “senior+”.</p><blockquote><p>Время движется вперёд, и любые идеи могут устареть, даже те, которые ты считаешь основополагающими. Нужно не забывать их переоценивать</p></blockquote><p><code>3. Игнорирование soft-skills</code></p><p>Рано или поздно в ходе роста программиста необходимо научиться нормально взаимодействовать с командой. На начальных этапах всё взаимодействие - это передача по конвейеру: получение задач от лидов/тм, передача выполненного к QA. </p><p>Но на более поздних необходимо взаимодействие со всеми вокруг - уточнение формулировки задач (и умение исправить или даже переделать постановку исходной задачи), корректировки сроков. Ещё позднее - формирование команды и умение улаживать конфликты в команде. Даже если ты собираешься расти в “техническую”, а не “управленческую” сторону, всё равно не избежать растущего количества взаимодействия, а умение взаимодействовать тоже нужно прокачивать.</p><p>В некоторых компаниях отрицательный отзыв по софт-скиллам блокирует твой карьерный рост.</p><blockquote><p>В любой сфере достаточно людей, которые умеют программировать, но не хватает тех, которые умеют программировать, и при этом разбираются в предметной области.</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Часто встречающиеся у программистов-новичков ошибки и часто встречающие у опытных программистов ошибки. С позиции “среднего” разработчика.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="code" scheme="http://spiiin.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Карта прохождения игр</title>
    <link href="http://spiiin.github.io/blog/1563/"/>
    <id>http://spiiin.github.io/blog/1563/</id>
    <published>2020-08-04T19:11:37.000Z</published>
    <updated>2020-09-01T18:10:28.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Список игр на прохождение<br><a id="more"></a></p><h2 id="Current-list"><a href="#Current-list" class="headerlink" title="Current list"></a>Current list</h2><p><code>Captain Toad</code> - 90%<br><code>Age of Mythologies</code> - 50%<br><code>Gta 5</code> - 30%<br><code>The Witcher 2</code> - 5%</p><h2 id="Coop"><a href="#Coop" class="headerlink" title="Coop"></a>Coop</h2><p><code>The Stratchers</code> - 33%<br><code>Trine 4</code> - 30%<br><code>Minecraft</code> - 5%</p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><p><code>Yoshi&#39;s Crafted World</code><br><code>The Forest</code></p><h2 id="Completed"><a href="#Completed" class="headerlink" title="Completed"></a>Completed</h2><p><code>Mario+Rabbids</code><br><code>Witcher</code><br><code>Legend of Zelda: BotW</code><br><code>Warhammer 40k: Mechanicus</code></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Список игр на прохождение&lt;br&gt;
    
    </summary>
    
    
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
  </entry>
  
  <entry>
    <title>Привет, Hexo</title>
    <link href="http://spiiin.github.io/blog/47121/"/>
    <id>http://spiiin.github.io/blog/47121/</id>
    <published>2020-07-18T14:14:53.000Z</published>
    <updated>2021-05-22T08:47:42.526Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>После нескольких дней возни в очередной попытке собрать на <code>jekyll</code> статический блог, решил забить на него и попробовать использовать для блога <a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>. Получилось сильно проще и приятнее.</p><p>Во-первых, <code>hexo</code> запускается легче, и темы работают сходу. И, что удобно для блога программисту, подсветка синтаксиса кода интегрирована в движок лучше, из чего следует, что темы скорее всего будут совместимы с ней (у <code>jekyll</code> подобрать работающую пару “тема+плагин подсветки синтаксиса” оказалось очень непросто, то съезжала нумерация длинных строк, то весь блок с кодом выглядел коряво, то были проблемы с корректным отображения цвета строк или фона)</p><a id="more"></a><p>Единственное, для корректной работы тем, иногда опытным путём, необходимо выяснить, какие плагины необходимо доустановить из <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">списка</a>.</p><h2 id="Темы"><a href="#Темы" class="headerlink" title="Темы"></a>Темы</h2><p>Далее, выбор <a href="https://hexo.io/themes/" target="_blank" rel="noopener">тем</a>. Достаточно много качественных и приятных глазу, из тёмных и минималистичных интересными показались:</p><ul><li><a href="https://github.com/howardliu-cn/hexo-theme-clean-dark" target="_blank" rel="noopener">clean-dark</a><ul><li><a href="https://www.howardliu.cn/" target="_blank" rel="noopener">Пример</a></li><li>Оригинальная <a href="http://pavelmakhov.com/jekyll-clean-dark" target="_blank" rel="noopener">тема для jekyll</a>, которая была взята в качестве основы для этой темы</li></ul></li><li><a href="https://github.com/maochunguang/black-blue" target="_blank" rel="noopener">black-blue</a><ul><li><a href="http://maochunguang.github.io/" target="_blank" rel="noopener">Пример</a></li></ul></li><li><a href="https://github.com/tzvetkov75/solar-theme-hexo/" target="_blank" rel="noopener">solar</a><ul><li><a href="https://tzvetkov75.github.io/demo_blog/public/" target="_blank" rel="noopener">Пример</a>.</li><li>Тема на основе <a href="https://probberechts.github.io/hexo-theme-cactus/cactus-dark/public/" target="_blank" rel="noopener">cactus</a></li></ul></li><li><a href="https://github.com/lyndonoc/hexo-theme-pandollo" target="_blank" rel="noopener">pandollo</a><ul><li><a href="https://lyndonoc.github.io/" target="_blank" rel="noopener">Пример</a></li></ul></li></ul><h2 id="Настройка-темы"><a href="#Настройка-темы" class="headerlink" title="Настройка темы"></a>Настройка темы</h2><p>Минимальная настройка темы включает правку файла <code>config.yml</code>, какие именно настройки поддерживаются, обычно написано на сайте темы.</p><p>Дополнительно, на примере темы <code>pandolo</code> - можно донастроить стиль, разобравшись с правкой файлов в папке <code>themes/pandollo/source/scss</code>.</p><p>Дальше нужно выполнить команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sass --style&#x3D;compressed .&#x2F;main.scss ..&#x2F;css&#x2F;main.css</span><br></pre></td></tr></table></figure></p><p>Для того, чтобы сгенерировать упакованную версию файла стилей, которую будет использовать блог.</p><p>После небольших правок получилась примерно такая “лисья” тема:<br><img src="/blog/47121/hexo-fox.png" alt="hexo-fox"></p><h2 id="Настройка-плагинов"><a href="#Настройка-плагинов" class="headerlink" title="Настройка плагинов"></a>Настройка плагинов</h2><p>Для выбранной темы пригодятся следующие плагины:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  ...</span><br><span class="line">  "hexo-asset-link": "^2.0.1",</span><br><span class="line">  "hexo-generator-fragments": "^1.0.0",</span><br><span class="line">  "hexo-renderer-kramed": "^0.1.4",</span><br><span class="line">  "hexo-renderer-jade": "^0.5.0",</span><br><span class="line">  "hexo-abbrlink": "^2.2.1",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/liolok/hexo-asset-link" target="_blank" rel="noopener">hexo-asset-link</a> - позволяет использовать в постах ссылку на ассет в виде относительного пути: <code>POST_NAME/asset_name.png</code> (также нужно включить в <code>config.yml</code> опцию: <code>post_asset_folder: true</code>, чтобы hexo создавал отдельную папку для ассетов к каждому посту).</p><p><a href="https://github.com/mamboer/hexo-generator-fragments" target="_blank" rel="noopener">hexo-generator-fragments</a> - необходим для темы - генерирует preview для постов для главной страницы, позволяет использоватьв в постах тег <code>&lt;!-- more --&gt;</code> чтобы отмечать краткую короткую preview-версию поста.</p><p><a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> - плагины, содержащие в названии renderer, позволяют hexo генерировать посты из разных форматов файла. Данный плагин используется для рендера из файлов <code>*.md</code> в формате <code>github flavored markdown</code>, который используется на серверах <code>github</code>.<br>В комплекте с <code>hexo</code> уже идёт плагин, который рендерит markdown-файлы, поэтому чтобы использовать альтернативный, предварительно нужно его удалить:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/hexojs/hexo-renderer-jade" target="_blank" rel="noopener">hexo-renderer-jade</a> - необходимый для темы плагин, позволяющий рендерить pug-файлы (собственно, сама тема описана в этом формате).</p><p><a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> - генерирует для каждого поста идентификатор. Для генерации имён постов необходимо в <code>config.yml</code> добавить строку:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br></pre></td></tr></table></figure><br>Для того, чтобы указать ссылку на пост, нужно использовать тег:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Написание-постов"><a href="#Написание-постов" class="headerlink" title="Написание постов"></a>Написание постов</h2><p>После установки и настройки темы можно попробовать добавить пост:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post hello-hexo.md</span><br></pre></td></tr></table></figure><br>Вместо md можно попробовать использовать другие форматы, для которых установлены render-плагины. В качестве редактора постов я бы посоветовал использовать (Visual Studio Code)[<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a>], вместе с плагином <a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/" target="_blank" rel="noopener">Markdown Enchanced Preview</a>.</p><p>Чтобы проверить, как выглядит пост, нужно запустить команду:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure><br>и открыть в браузере страницу <code>http://127.0.0.1:4000/</code> (hexo отслеживает изменения исходников и сразу обновляет открытую страницу).</p><p>Сгенерировать статический сайт можно так:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p><p>Весь сгенерированный сайт будет содержаться в папке <code>public</code>, её можно заливать на хостинг руками или воспользоваться плагинами для автоматизации этих процессов.</p><h2 id="Итог"><a href="#Итог" class="headerlink" title="Итог"></a>Итог</h2><p>В кажущейся простой задаче “отрендерить markdown-статью в html”, cкрыт выбор целого стека способов решения (генераторы сайтов со своими языками, рендеры разных форматов и диалектов разметки, языки описания стилей и шаблонов сайта, темы, плагины, подсветка кода, системы развёртывания сайта).</p><p>В <code>hexo</code> эти вещи более-менее целостно сшиты вместе в единую систему, которой можно начать пользоваться достаточно быстро.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;После нескольких дней возни в очередной попытке собрать на &lt;code&gt;jekyll&lt;/code&gt; статический блог, решил забить на него и попробовать использовать для блога &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;. Получилось сильно проще и приятнее.&lt;/p&gt;
&lt;p&gt;Во-первых, &lt;code&gt;hexo&lt;/code&gt; запускается легче, и темы работают сходу. И, что удобно для блога программисту, подсветка синтаксиса кода интегрирована в движок лучше, из чего следует, что темы скорее всего будут совместимы с ней (у &lt;code&gt;jekyll&lt;/code&gt; подобрать работающую пару “тема+плагин подсветки синтаксиса” оказалось очень непросто, то съезжала нумерация длинных строк, то весь блок с кодом выглядел коряво, то были проблемы с корректным отображения цвета строк или фона)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="meta" scheme="http://spiiin.github.io/tags/meta/"/>
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://spiiin.github.io/blog/16107/"/>
    <id>http://spiiin.github.io/blog/16107/</id>
    <published>2020-07-01T12:45:28.000Z</published>
    <updated>2021-03-14T21:31:41.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><strong>Hello, world!</strong><br>Немного тестов разметки<br><a id="more"></a></p><hr><p>Заголовки</p><h1 id="Заголовок1"><a href="#Заголовок1" class="headerlink" title="Заголовок1"></a>Заголовок1</h1><h2 id="Заголовок2"><a href="#Заголовок2" class="headerlink" title="Заголовок2"></a>Заголовок2</h2><hr><p>Код:</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">echo <span class="string">"code without line numbers"</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Code"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"with"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"line"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"numbers"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; end;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>hello.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;0,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="built_in">std</span>::string_view; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;1,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="built_in">std</span>::<span class="keyword">size_t</span>; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">tuple_element</span>&lt;2,Config&gt; &#123;</span> <span class="keyword">using</span> type = <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Цитаты:</p><blockquote><p>“Citate from me”</p><footer><strong>spiiin</strong></footer></blockquote><hr><p>Списки:</p><ul><li>список1</li><li>список2<ul><li>список21</li><li>список22<ul><li><em>список221</em></li></ul></li></ul></li><li>список3</li></ul><p>Тест 2</p><ul><li><strong>Языки</strong><ul><li><a href="https://c++" target="_blank" rel="noopener">C++</a></li><li>C#</li><li>Python</li></ul></li><li><strong>Движки</strong><ul><li>Unity</li><li>Cocos2d</li><li>Godot</li></ul></li></ul><hr><p>Большой список с уточнениями:</p><p><strong><code>- Один</code></strong><br>Объяснение на много<br>много<br>много строк.</p><p><strong><code>- Два</code></strong><br>Длинное объяснение</p><p><strong><code>- Три</code></strong><br>Ещё одно объснение, в несколько предложений.<br>Или абзацев.</p><hr><p>Текст</p><p>болд - <strong>text</strong><br>курсив - <em>text</em><br>болд+курсив - <strong><em>text</em></strong><br>код - <code>code</code><br>код-болд - <strong><code>code-bold</code></strong></p><hr><p>Ссылки</p><p>Глобальная - <a href="https://google.com/" target="_blank" rel="noopener">Google</a><br>На пост в блоге - <a href="/blog/47121/" title="Hello, hexo">Hello, hexo</a></p><hr><p>Спойлер:</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        gist    </div>    <div class='spoiler-content'>        <script src="//gist.github.com/44721f2e5a70294fa390218ad92385e4.js?file=james_bond_nim.nim"></script>    </div></div><hr><details><summary>Развернуть</summary><p>Текст</p></details><hr><p>Хинт</p><p>Не работает в начале строки - <span class="hint--info hint--rounded hint--top" data-hint="Multilinehint" ontouchstart>Test</span></p><hr><p>Таблицы</p><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center"><em>right-aligned</em></td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><code>Table Header 1</code></th><th><code>Table Header 2</code></th><th><code>Table Header 3</code></th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr></tbody></table></div><p>Backticks escape: `are` these!</p><hr><p>Картинки</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/blog/16107/fox.png" alt="fox"></h2><hr><p>Плагин для youtube:<br><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/GR18emXxAi0" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div></p><hr><p>Плагин valkyr-url:</p><div class="vkr-url-wrapper"><style>.vkr-url-wrapper {    padding: 10px;    border-radius: 5px;    border: 1px solid;    border-color: #eee #ddd #bbb;    box-shadow: rgba(0,0,0,.14) 0 1px 3px;    margin-bottom: 10px;    display: flex;}.vkr-url-wrapper .desc-wrapper > hr {    margin: 10px 0;    height: 1px;}.vkr-url-wrapper .avatar {    width: 100px;    height: 100px;    border: solid 1px #eee;    box-shadow: none!important;    margin: 0;    margin-right: 10px;}.vkr-url-wrapper h2 {    border: none;    margin: 0;    padding: 0;}.vkr-url-wrapper .desc-wrapper {    flex: 1;}.vkr-url-wrapper .desc-wrapper a {    font-size: 22px;    font-weight: 700;}</style>            <a href="https://github.com/spiiin/CadEditor" target="_blank" rel="noopener"><img class="avatar" src="https://raw.githubusercontent.com/spiiin/CadEditor/master/CadEditor/cadIco.png" ></a>        <div class="desc-wrapper">        <a href="https://github.com/spiiin/CadEditor" target="_blank" rel="noopener">Cad Editor</a>        <hr />        <div class="desc">CadEditor is level editor for many classic console games</div>    </div></div><hr><p>Nomnoml diagram</p><img style="background-color:white;" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIyIiBoZWlnaHQ9IjE5OSIgdmVyc2lvbj0iMS4xIiBiYXNlUHJvZmlsZT0iZnVsbCIgdmlld2JveD0iMCAwIDIyMiAxOTkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmV2PSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMiIHN0eWxlPSJmb250LXdlaWdodDpib2xkOyBmb250LXNpemU6MTJwdDsgZm9udC1mYW1pbHk6J0NhbGlicmknLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7O3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpyb3VuZCI+PHBhdGggZD0iTTE3Ny41IDQ0LjUgTDE3Ny41IDY0LjUgTDE3Ny41IDg0LjUgTDE3Ny41IDg0LjUgIiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcGF0aD4KPHBhdGggZD0iTTE3Mi4yIDcxLjIgTDE3Ny41IDc3LjggTDE4Mi44IDcxLjIgTDE3Ny41IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik00Ni41IDQzIEwyNi41IDY0LjUgTDI2LjUgODQuNSBMMjYuNSA4NC41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yMS4yIDcxLjIgTDI2LjUgNzcuOCBMMzEuOCA3MS4yIEwyNi41IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik03Mi41IDQzIEw5Mi41IDY0LjUgTDkyLjUgODQuNSBMOTIuNSA4NC41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik04Ny4yIDcxLjIgTDkyLjUgNzcuOCBMOTcuOCA3MS4yIEw5Mi41IDg0LjUgWiIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6IzMzMzIyRTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yNi41IDExNS41IEwyNi41IDEzNS41IEwyNi41IDE1NS41IEwyNi41IDE1NS41ICIgc3R5bGU9InN0cm9rZTojMzMzMjJFO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5Om5vbmU7Ij48L3BhdGg+CjxwYXRoIGQ9Ik0yMS4yIDE0Mi4yIEwyNi41IDE0OC44IEwzMS44IDE0Mi4yIEwyNi41IDE1NS41IFoiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiMzMzMyMkU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9wYXRoPgo8cmVjdCB4PSI0Ni41IiB5PSIxMy41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjYiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSI1NC44IiB5PSIzNSIgc3R5bGU9IiI+MTwvdGV4dD4KPHJlY3QgeD0iMTMuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjI2IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMjEuOCIgeT0iMTA2IiBzdHlsZT0iIj4yPC90ZXh0Pgo8cmVjdCB4PSI3OS41IiB5PSI4NC41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjYiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSI4Ny44IiB5PSIxMDYiIHN0eWxlPSIiPjM8L3RleHQ+CjxyZWN0IHg9IjEzLjUiIHk9IjE1NS41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iMjYiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIyMS44IiB5PSIxNzciIHN0eWxlPSIiPjQ8L3RleHQ+CjxyZWN0IHg9IjE0NS41IiB5PSIxMy41IiBoZWlnaHQ9IjMxIiB3aWR0aD0iNjQiIHN0eWxlPSJzdHJva2U6IzMzMzIyRTtmaWxsOiNlZWU4ZDU7c3Ryb2tlLWRhc2hhcnJheTpub25lOyI+PC9yZWN0Pgo8dGV4dCB4PSIxNTMuOCIgeT0iMzUiIHN0eWxlPSIiPmhlbGxvPC90ZXh0Pgo8cmVjdCB4PSIxNDUuNSIgeT0iODQuNSIgaGVpZ2h0PSIzMSIgd2lkdGg9IjY0IiBzdHlsZT0ic3Ryb2tlOiMzMzMyMkU7ZmlsbDojZWVlOGQ1O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTsiPjwvcmVjdD4KPHRleHQgeD0iMTUzLjgiIHk9IjEwNiIgc3R5bGU9IiI+d29ybGQ8L3RleHQ+PC9zdmc+" /><hr><p>Плагин для qrcode </p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAAAAAAc6VLmAAAA6klEQVR42u3ZwQ6EIAxFUf7/p3GniaHlVZlMi7crDbHHBaEFWptHP+N6vY22NYGURepWmKlHo34WpHLSaJaYqU3JzIK0o6TOQqQPSKPUv5l7SFkkvz75AysrIVICSeg7hadF3TLSf6UejqefIdWQ1NmlrkGTVgapmuQ3rcLG1uxskIpIyo9E2ly5zCElldQWJXR2KmyAkbJKai5h1ZosU0iFJLkFFdcvuwgipZce3qnFz0mRKkmvz8LkSohUSApVpdB1C9KOUuiixH5F2kYSSpNymo5USApdncUv25AqSeo+129IhZNVpPTSAVWCHQugeNVrAAAAAElFTkSuQmCC" alt="hello, world" title="hello, world" class="hello world"></h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Hello, world!&lt;/strong&gt;&lt;br&gt;Немного тестов разметки&lt;br&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://spiiin.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>CadEditor v5.0 Changelog</title>
    <link href="http://spiiin.github.io/blog/1634/"/>
    <id>http://spiiin.github.io/blog/1634/</id>
    <published>2018-05-09T07:54:00.000Z</published>
    <updated>2021-01-02T16:38:46.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Обновления редактора <a href="https://github.com/spiiin/cadeditor" target="_blank" rel="noopener">CadEditor</a> за год с <a href="https://spiiin.livejournal.com/108403.html" target="_blank" rel="noopener">версии 4.1</a>  </p><p>Почти для всех игр описан способ построения блоков из данных ROM-файла вместо картинок. Фактически, реализована наконец идея создания универсального редактора блоков, когда новые форматы могут быть добавлены с помощью файлов настроек, без изменения кода редактора.  </p><p>Почти для всех поддерживаемых игр добавлены конфиги блоков для всех основных уровней. Большая часть работы сделана другими пользователями. Хотя для добавления новых игр нет документации, большое количество примеров позволило пользователям добавлять подобные игры комбинированием готовых примеров.  </p><p>Написано несколько <a href="https://spiiin.github.io/CadEditor/">статей</a>, описывающих примеры работы с редактором, большинство - с видеопримерами. Создана <a href="https://spiiin.github.io/CadEditor/cadeditor-supported-games.html">нотация</a> для документирования того, как описаны уровни во всех поддерживаемых играх. Добавлено большое исследование устройства <a href="https://spiiin.livejournal.com/124652.html" target="_blank" rel="noopener">спецэффектов в NES-играх</a>.  </p><p>Добавлено редактирование игры со сжатием для NES (Felix the Cat), пока с примером ручного пережатия отредактированных данных с помощью <a href="https://github.com/spiiin/JupyterCadEditor/blob/master/CadEditor-Felix-decompress.ipynb" target="_blank" rel="noopener">скрипта на Python</a>.  </p><p>Проект <a href="https://github.com/spiiin/JupyterCadEditor" target="_blank" rel="noopener">JupyterCadEditor</a> (использование CadEditord в качестве библиотеки для Python в ноутбуках Jupyter) вынесен в отдельный репозиторий. Добавлены скрипты, позволяющие по конфигу игры для одного региона находить такие же данные для версии игры другого региона, что позволяет легко добавлять поддержку игр для разных регионов.  </p><p>Упрощён и улучшен рендер панелей и редакторов, убраны лишние масштабирования и “замыливание” при отрисовке.  </p><p>Добавлен плагин <a href="https://www.patreon.com/posts/september-2-2017-14324437" target="_blank" rel="noopener">экспорта карты в формат TMX</a>, для последующего использования её в редакторе <a href="https://www.mapeditor.org/" target="_blank" rel="noopener">Tiled</a>. Улучшены плагины экпорта блоков и экранов в картинки и бинарные файлы.  </p><p>Добавлено множество lua-скриптов для упрощения исследования игр и добавления их в редактор. Переписаны с Python на Lua скрипты автоматического поиска блоков различных форматов в видеопамяти - теперь они позволяют находить блоки прямо во время прохождения игры, без необходимости делать дампы памяти вручную.   </p><p>Добавлены lua-скрипты для эмулятора Mesen, позволяющие исследовать <a href="https://spiiin.livejournal.com/121112.html" target="_blank" rel="noopener">спецэффекты</a> в NES-играх, а также расширяющие возможности эмулятора в отладке.  </p><p>Добавлены утилиты для проверки целостности конфигов при обновлении версии редактора и исследования функций конфига без запуска самого редактора.  </p><p>Добавлен плагин, позволяющий пережимать данные и запаковывать их в ROM - <a href="https://www.youtube.com/watch?v=NfIWeDwu68w" target="_blank" rel="noopener">компрессор</a> для игры Contra Hard Corps.  </p><p>Плагин для запуска пользовательских скриптов из редактора и примеры его использования (экспорт скриншотов, экспорт блоков из игры для использования в <a href="https://www.youtube.com/watch?v=GR18emXxAi0" target="_blank" rel="noopener">демо-проектах</a>)  </p><p>Проект перешагнул первую <a href="https://github.com/spiiin/CadEditor/commit/f29ebd2437ae2f44950b1f5fb43a74b1230fc5fc" target="_blank" rel="noopener">тысячу</a> коммитов, а также переведён на .NET Framework 4.0. Редактор содержит более 1500 конфигов блоков и экранов различных уровней для 128 игр. Большая часть этих конфигов добавлена пользователями редактора, так что проект частично стал продуктом сообщества ромхакеров.  </p><p>Возможно, в следующих итерациях в редактор будут добавлены возможности универсального описания редактора объектов для уже добавленных игр, это такая же большая задача, как и создание универсального редактора блоков, но и её возможно решить.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Обновления
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="hack" scheme="http://spiiin.github.io/tags/hack/"/>
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Castlevania HD Pack</title>
    <link href="http://spiiin.github.io/blog/45580/"/>
    <id>http://spiiin.github.io/blog/45580/</id>
    <published>2018-05-04T19:27:00.000Z</published>
    <updated>2021-01-02T16:40:23.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p>Очень здоровская затея в современных эмуляторах - вытащить всю графику, улучшить её качество, и включить в эмуляторе использование этой улучшенной графики.  </p><p><a href="http://www.romhacking.net/forum/index.php?topic=26114" target="_blank" rel="noopener">Улучшенный пак</a> графики и музыки для первой Castlevania под эмулятор Mesen.  </p><style>.embed-container {    position: relative;    padding-bottom: 56.25%;    height: 0;    overflow: hidden;    max-width: 100%;  }  .embed-container iframe, .embed-container object, .embed-container embed {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;  }  </style><div class="embed-container"><iframe src="https://www.youtube.com/embed/D9SQei4eIqY" allowfullscreen frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe></div><p>Записал прохождение, с помощью самописного скрипта для <a href="https://github.com/spiiin/CadEditor/tree/master/Stuff/nes_lua/mesen_savemovies" target="_blank" rel="noopener">перезаписи прохождений</a>, надеюсь автор эмулятора наконец добавит нормальную реализацию перезаписи в ближайших обновлениях.</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;p&gt;Очень здор
      
    
    </summary>
    
    
    
      <category term="nes" scheme="http://spiiin.github.io/tags/nes/"/>
    
      <category term="games" scheme="http://spiiin.github.io/tags/games/"/>
    
      <category term="lua" scheme="http://spiiin.github.io/tags/lua/"/>
    
  </entry>
  
</feed>
